"bundle";
System.registerDynamic("github:systemjs/plugin-text@0.0.3/text", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  exports.translate = function(load) {
    return 'def' + 'ine(function() {\nreturn "' + load.source.replace(/(["\\])/g, '\\$1').replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r").replace(/[\u2028]/g, "\\u2028").replace(/[\u2029]/g, "\\u2029") + '";\n});';
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:systemjs/plugin-text@0.0.3", ["github:systemjs/plugin-text@0.0.3/text"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:systemjs/plugin-text@0.0.3/text");
  global.define = __define;
  return module.exports;
});

System.register("main", [], function(_export) {
  'use strict';
  _export('configure', configure);
  function configure(aurelia) {
    aurelia.use.standardConfiguration();
    aurelia.start().then(function() {
      if ('serviceWorker' in navigator) {
        if (/\/embed/.test(location.href)) {
          aurelia.setRoot('ui/embed/app');
        } else {
          aurelia.setRoot('ui/app');
        }
        return;
      }
      aurelia.setRoot('ui/fallback');
    });
  }
  return {
    setters: [],
    execute: function() {}
  };
});

System.registerDynamic("npm:process@0.11.2/browser", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:process@0.11.2", ["npm:process@0.11.2/browser"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:process@0.11.2/browser");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2/index", ["npm:process@0.11.2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = System._nodeRequire ? process : require("npm:process@0.11.2");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("github:jspm/nodelibs-process@0.1.2", ["github:jspm/nodelibs-process@0.1.2/index"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:jspm/nodelibs-process@0.1.2/index");
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6/client/shim.min", ["github:jspm/nodelibs-process@0.1.2"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  (function(process) {
    !function(b, c, a) {
      "use strict";
      !function(b) {
        function __webpack_require__(c) {
          if (a[c])
            return a[c].exports;
          var d = a[c] = {
            exports: {},
            id: c,
            loaded: !1
          };
          return b[c].call(d.exports, d, d.exports, __webpack_require__), d.loaded = !0, d.exports;
        }
        var a = {};
        return __webpack_require__.m = b, __webpack_require__.c = a, __webpack_require__.p = "", __webpack_require__(0);
      }([function(b, c, a) {
        a(1), a(34), a(40), a(42), a(44), a(46), a(48), a(50), a(51), a(52), a(53), a(54), a(55), a(56), a(57), a(58), a(59), a(60), a(61), a(64), a(65), a(66), a(68), a(69), a(70), a(71), a(72), a(73), a(74), a(76), a(77), a(78), a(80), a(81), a(82), a(84), a(85), a(86), a(87), a(88), a(89), a(90), a(91), a(92), a(93), a(94), a(95), a(96), a(97), a(99), a(103), a(104), a(106), a(107), a(111), a(116), a(117), a(120), a(122), a(124), a(126), a(127), a(128), a(130), a(131), a(133), a(134), a(135), a(136), a(143), a(146), a(147), a(149), a(150), a(151), a(152), a(153), a(154), a(155), a(156), a(157), a(158), a(159), a(160), a(162), a(163), a(164), a(165), a(166), a(167), a(169), a(170), a(171), a(172), a(174), a(175), a(177), a(178), a(180), a(181), a(182), a(183), b.exports = a(186);
      }, function(S, R, b) {
        var r,
            d = b(2),
            c = b(3),
            x = b(8),
            O = b(7),
            o = b(14),
            E = b(15),
            n = b(17),
            N = b(18),
            J = b(19),
            j = b(9),
            p = b(20),
            v = b(13),
            I = b(16),
            Q = b(21),
            y = b(23),
            K = b(25),
            w = b(26),
            h = b(27),
            s = b(24),
            m = b(11)("__proto__"),
            g = b(28),
            A = b(33)(!1),
            B = Object.prototype,
            C = Array.prototype,
            k = C.slice,
            M = C.join,
            F = d.setDesc,
            L = d.getDesc,
            q = d.setDescs,
            u = {};
        x || (r = !j(function() {
          return 7 != F(E("div"), "a", {get: function() {
              return 7;
            }}).a;
        }), d.setDesc = function(b, c, a) {
          if (r)
            try {
              return F(b, c, a);
            } catch (d) {}
          if ("get" in a || "set" in a)
            throw TypeError("Accessors not supported!");
          return "value" in a && (p(b)[c] = a.value), b;
        }, d.getDesc = function(a, b) {
          if (r)
            try {
              return L(a, b);
            } catch (c) {}
          return n(a, b) ? O(!B.propertyIsEnumerable.call(a, b), a[b]) : void 0;
        }, d.setDescs = q = function(a, b) {
          p(a);
          for (var c,
              e = d.getKeys(b),
              g = e.length,
              f = 0; g > f; )
            d.setDesc(a, c = e[f++], b[c]);
          return a;
        }), c(c.S + c.F * !x, "Object", {
          getOwnPropertyDescriptor: d.getDesc,
          defineProperty: d.setDesc,
          defineProperties: q
        });
        var i = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(","),
            H = i.concat("length", "prototype"),
            G = i.length,
            l = function() {
              var a,
                  b = E("iframe"),
                  c = G,
                  d = ">";
              for (b.style.display = "none", o.appendChild(b), b.src = "javascript:", a = b.contentWindow.document, a.open(), a.write("<script>document.F=Object</script" + d), a.close(), l = a.F; c--; )
                delete l.prototype[i[c]];
              return l();
            },
            D = function(a, b) {
              return function(g) {
                var c,
                    e = y(g),
                    f = 0,
                    d = [];
                for (c in e)
                  c != m && n(e, c) && d.push(c);
                for (; b > f; )
                  n(e, c = a[f++]) && (~A(d, c) || d.push(c));
                return d;
              };
            },
            t = function() {};
        c(c.S, "Object", {
          getPrototypeOf: d.getProto = d.getProto || function(a) {
            return a = Q(a), n(a, m) ? a[m] : "function" == typeof a.constructor && a instanceof a.constructor ? a.constructor.prototype : a instanceof Object ? B : null;
          },
          getOwnPropertyNames: d.getNames = d.getNames || D(H, H.length, !0),
          create: d.create = d.create || function(c, d) {
            var b;
            return null !== c ? (t.prototype = p(c), b = new t, t.prototype = null, b[m] = c) : b = l(), d === a ? b : q(b, d);
          },
          keys: d.getKeys = d.getKeys || D(i, G, !1)
        });
        var P = function(d, a, e) {
          if (!(a in u)) {
            for (var c = [],
                b = 0; a > b; b++)
              c[b] = "a[" + b + "]";
            u[a] = Function("F,a", "return new F(" + c.join(",") + ")");
          }
          return u[a](d, e);
        };
        c(c.P, "Function", {bind: function bind(c) {
            var a = v(this),
                d = k.call(arguments, 1),
                b = function() {
                  var e = d.concat(k.call(arguments));
                  return this instanceof b ? P(a, e.length, e) : J(a, e, c);
                };
            return I(a.prototype) && (b.prototype = a.prototype), b;
          }}), c(c.P + c.F * j(function() {
          o && k.call(o);
        }), "Array", {slice: function(f, b) {
            var d = h(this.length),
                g = N(this);
            if (b = b === a ? d : b, "Array" == g)
              return k.call(this, f, b);
            for (var e = w(f, d),
                l = w(b, d),
                i = h(l - e),
                j = Array(i),
                c = 0; i > c; c++)
              j[c] = "String" == g ? this.charAt(e + c) : this[e + c];
            return j;
          }}), c(c.P + c.F * (s != Object), "Array", {join: function join(b) {
            return M.call(s(this), b === a ? "," : b);
          }}), c(c.S, "Array", {isArray: b(30)});
        var z = function(a) {
          return function(g, d) {
            v(g);
            var c = s(this),
                e = h(c.length),
                b = a ? e - 1 : 0,
                f = a ? -1 : 1;
            if (arguments.length < 2)
              for (; ; ) {
                if (b in c) {
                  d = c[b], b += f;
                  break;
                }
                if (b += f, a ? 0 > b : b >= e)
                  throw TypeError("Reduce of empty array with no initial value");
              }
            for (; a ? b >= 0 : e > b; b += f)
              b in c && (d = g(d, c[b], b, this));
            return d;
          };
        },
            f = function(a) {
              return function(b) {
                return a(this, b, arguments[1]);
              };
            };
        c(c.P, "Array", {
          forEach: d.each = d.each || f(g(0)),
          map: f(g(1)),
          filter: f(g(2)),
          some: f(g(3)),
          every: f(g(4)),
          reduce: z(!1),
          reduceRight: z(!0),
          indexOf: f(A),
          lastIndexOf: function(d, e) {
            var b = y(this),
                c = h(b.length),
                a = c - 1;
            for (arguments.length > 1 && (a = Math.min(a, K(e))), 0 > a && (a = h(c + a)); a >= 0; a--)
              if (a in b && b[a] === d)
                return a;
            return -1;
          }
        }), c(c.S, "Date", {now: function() {
            return +new Date;
          }});
        var e = function(a) {
          return a > 9 ? a : "0" + a;
        };
        c(c.P + c.F * (j(function() {
          return "0385-07-25T07:06:39.999Z" != new Date(-5e13 - 1).toISOString();
        }) || !j(function() {
          new Date(NaN).toISOString();
        })), "Date", {toISOString: function toISOString() {
            if (!isFinite(this))
              throw RangeError("Invalid time value");
            var a = this,
                b = a.getUTCFullYear(),
                c = a.getUTCMilliseconds(),
                d = 0 > b ? "-" : b > 9999 ? "+" : "";
            return d + ("00000" + Math.abs(b)).slice(d ? -6 : -4) + "-" + e(a.getUTCMonth() + 1) + "-" + e(a.getUTCDate()) + "T" + e(a.getUTCHours()) + ":" + e(a.getUTCMinutes()) + ":" + e(a.getUTCSeconds()) + "." + (c > 99 ? c : "0" + e(c)) + "Z";
          }});
      }, function(b, c) {
        var a = Object;
        b.exports = {
          create: a.create,
          getProto: a.getPrototypeOf,
          isEnum: {}.propertyIsEnumerable,
          getDesc: a.getOwnPropertyDescriptor,
          setDesc: a.defineProperty,
          setDescs: a.defineProperties,
          getKeys: a.keys,
          getNames: a.getOwnPropertyNames,
          getSymbols: a.getOwnPropertySymbols,
          each: [].forEach
        };
      }, function(g, j, c) {
        var b = c(4),
            d = c(5),
            h = c(6),
            i = c(10),
            f = c(12),
            e = "prototype",
            a = function(k, j, o) {
              var g,
                  m,
                  c,
                  s,
                  v = k & a.F,
                  p = k & a.G,
                  u = k & a.S,
                  r = k & a.P,
                  t = k & a.B,
                  l = p ? b : u ? b[j] || (b[j] = {}) : (b[j] || {})[e],
                  n = p ? d : d[j] || (d[j] = {}),
                  q = n[e] || (n[e] = {});
              p && (o = j);
              for (g in o)
                m = !v && l && g in l, c = (m ? l : o)[g], s = t && m ? f(c, b) : r && "function" == typeof c ? f(Function.call, c) : c, l && !m && i(l, g, c), n[g] != c && h(n, g, s), r && q[g] != c && (q[g] = c);
            };
        b.core = d, a.F = 1, a.G = 2, a.S = 4, a.P = 8, a.B = 16, a.W = 32, g.exports = a;
      }, function(a, d) {
        var b = a.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof c && (c = b);
      }, function(a, d) {
        var c = a.exports = {version: "1.2.6"};
        "number" == typeof b && (b = c);
      }, function(b, e, a) {
        var c = a(2),
            d = a(7);
        b.exports = a(8) ? function(a, b, e) {
          return c.setDesc(a, b, d(1, e));
        } : function(a, b, c) {
          return a[b] = c, a;
        };
      }, function(a, b) {
        a.exports = function(a, b) {
          return {
            enumerable: !(1 & a),
            configurable: !(2 & a),
            writable: !(4 & a),
            value: b
          };
        };
      }, function(a, c, b) {
        a.exports = !b(9)(function() {
          return 7 != Object.defineProperty({}, "a", {get: function() {
              return 7;
            }}).a;
        });
      }, function(a, b) {
        a.exports = function(a) {
          try {
            return !!a();
          } catch (b) {
            return !0;
          }
        };
      }, function(f, i, a) {
        var g = a(4),
            b = a(6),
            c = a(11)("src"),
            d = "toString",
            e = Function[d],
            h = ("" + e).split(d);
        a(5).inspectSource = function(a) {
          return e.call(a);
        }, (f.exports = function(e, a, d, f) {
          "function" == typeof d && (d.hasOwnProperty(c) || b(d, c, e[a] ? "" + e[a] : h.join(String(a))), d.hasOwnProperty("name") || b(d, "name", a)), e === g ? e[a] = d : (f || delete e[a], b(e, a, d));
        })(Function.prototype, d, function toString() {
          return "function" == typeof this && this[c] || e.call(this);
        });
      }, function(b, e) {
        var c = 0,
            d = Math.random();
        b.exports = function(b) {
          return "Symbol(".concat(b === a ? "" : b, ")_", (++c + d).toString(36));
        };
      }, function(b, e, c) {
        var d = c(13);
        b.exports = function(b, c, e) {
          if (d(b), c === a)
            return b;
          switch (e) {
            case 1:
              return function(a) {
                return b.call(c, a);
              };
            case 2:
              return function(a, d) {
                return b.call(c, a, d);
              };
            case 3:
              return function(a, d, e) {
                return b.call(c, a, d, e);
              };
          }
          return function() {
            return b.apply(c, arguments);
          };
        };
      }, function(a, b) {
        a.exports = function(a) {
          if ("function" != typeof a)
            throw TypeError(a + " is not a function!");
          return a;
        };
      }, function(a, c, b) {
        a.exports = b(4).document && document.documentElement;
      }, function(d, f, b) {
        var c = b(16),
            a = b(4).document,
            e = c(a) && c(a.createElement);
        d.exports = function(b) {
          return e ? a.createElement(b) : {};
        };
      }, function(a, b) {
        a.exports = function(a) {
          return "object" == typeof a ? null !== a : "function" == typeof a;
        };
      }, function(a, c) {
        var b = {}.hasOwnProperty;
        a.exports = function(a, c) {
          return b.call(a, c);
        };
      }, function(a, c) {
        var b = {}.toString;
        a.exports = function(a) {
          return b.call(a).slice(8, -1);
        };
      }, function(b, c) {
        b.exports = function(c, b, d) {
          var e = d === a;
          switch (b.length) {
            case 0:
              return e ? c() : c.call(d);
            case 1:
              return e ? c(b[0]) : c.call(d, b[0]);
            case 2:
              return e ? c(b[0], b[1]) : c.call(d, b[0], b[1]);
            case 3:
              return e ? c(b[0], b[1], b[2]) : c.call(d, b[0], b[1], b[2]);
            case 4:
              return e ? c(b[0], b[1], b[2], b[3]) : c.call(d, b[0], b[1], b[2], b[3]);
          }
          return c.apply(d, b);
        };
      }, function(a, d, b) {
        var c = b(16);
        a.exports = function(a) {
          if (!c(a))
            throw TypeError(a + " is not an object!");
          return a;
        };
      }, function(a, d, b) {
        var c = b(22);
        a.exports = function(a) {
          return Object(c(a));
        };
      }, function(b, c) {
        b.exports = function(b) {
          if (b == a)
            throw TypeError("Can't call method on  " + b);
          return b;
        };
      }, function(b, e, a) {
        var c = a(24),
            d = a(22);
        b.exports = function(a) {
          return c(d(a));
        };
      }, function(a, d, b) {
        var c = b(18);
        a.exports = Object("z").propertyIsEnumerable(0) ? Object : function(a) {
          return "String" == c(a) ? a.split("") : Object(a);
        };
      }, function(a, d) {
        var b = Math.ceil,
            c = Math.floor;
        a.exports = function(a) {
          return isNaN(a = +a) ? 0 : (a > 0 ? c : b)(a);
        };
      }, function(a, f, b) {
        var c = b(25),
            d = Math.max,
            e = Math.min;
        a.exports = function(a, b) {
          return a = c(a), 0 > a ? d(a + b, 0) : e(a, b);
        };
      }, function(a, e, b) {
        var c = b(25),
            d = Math.min;
        a.exports = function(a) {
          return a > 0 ? d(c(a), 9007199254740991) : 0;
        };
      }, function(d, i, b) {
        var e = b(12),
            f = b(24),
            g = b(21),
            h = b(27),
            c = b(29);
        d.exports = function(b) {
          var i = 1 == b,
              k = 2 == b,
              l = 3 == b,
              d = 4 == b,
              j = 6 == b,
              m = 5 == b || j;
          return function(p, v, x) {
            for (var o,
                r,
                u = g(p),
                s = f(u),
                w = e(v, x, 3),
                t = h(s.length),
                n = 0,
                q = i ? c(p, t) : k ? c(p, 0) : a; t > n; n++)
              if ((m || n in s) && (o = s[n], r = w(o, n, u), b))
                if (i)
                  q[n] = r;
                else if (r)
                  switch (b) {
                    case 3:
                      return !0;
                    case 5:
                      return o;
                    case 6:
                      return n;
                    case 2:
                      q.push(o);
                  }
                else if (d)
                  return !1;
            return j ? -1 : l || d ? d : q;
          };
        };
      }, function(d, g, b) {
        var e = b(16),
            c = b(30),
            f = b(31)("species");
        d.exports = function(d, g) {
          var b;
          return c(d) && (b = d.constructor, "function" != typeof b || b !== Array && !c(b.prototype) || (b = a), e(b) && (b = b[f], null === b && (b = a))), new (b === a ? Array : b)(g);
        };
      }, function(a, d, b) {
        var c = b(18);
        a.exports = Array.isArray || function(a) {
          return "Array" == c(a);
        };
      }, function(d, f, a) {
        var c = a(32)("wks"),
            e = a(11),
            b = a(4).Symbol;
        d.exports = function(a) {
          return c[a] || (c[a] = b && b[a] || (b || e)("Symbol." + a));
        };
      }, function(d, f, e) {
        var a = e(4),
            b = "__core-js_shared__",
            c = a[b] || (a[b] = {});
        d.exports = function(a) {
          return c[a] || (c[a] = {});
        };
      }, function(b, f, a) {
        var c = a(23),
            d = a(27),
            e = a(26);
        b.exports = function(a) {
          return function(j, g, k) {
            var h,
                f = c(j),
                i = d(f.length),
                b = e(k, i);
            if (a && g != g) {
              for (; i > b; )
                if (h = f[b++], h != h)
                  return !0;
            } else
              for (; i > b; b++)
                if ((a || b in f) && f[b] === g)
                  return a || b;
            return !a && -1;
          };
        };
      }, function(W, V, b) {
        var e = b(2),
            x = b(4),
            d = b(17),
            w = b(8),
            f = b(3),
            G = b(10),
            H = b(9),
            J = b(32),
            s = b(35),
            S = b(11),
            A = b(31),
            R = b(36),
            C = b(37),
            Q = b(38),
            P = b(30),
            O = b(20),
            p = b(23),
            v = b(7),
            I = e.getDesc,
            i = e.setDesc,
            k = e.create,
            z = C.get,
            g = x.Symbol,
            l = x.JSON,
            m = l && l.stringify,
            n = !1,
            c = A("_hidden"),
            N = e.isEnum,
            o = J("symbol-registry"),
            h = J("symbols"),
            q = "function" == typeof g,
            j = Object.prototype,
            y = w && H(function() {
              return 7 != k(i({}, "a", {get: function() {
                  return i(this, "a", {value: 7}).a;
                }})).a;
            }) ? function(c, a, d) {
              var b = I(j, a);
              b && delete j[a], i(c, a, d), b && c !== j && i(j, a, b);
            } : i,
            L = function(a) {
              var b = h[a] = k(g.prototype);
              return b._k = a, w && n && y(j, a, {
                configurable: !0,
                set: function(b) {
                  d(this, c) && d(this[c], a) && (this[c][a] = !1), y(this, a, v(1, b));
                }
              }), b;
            },
            r = function(a) {
              return "symbol" == typeof a;
            },
            t = function defineProperty(a, b, e) {
              return e && d(h, b) ? (e.enumerable ? (d(a, c) && a[c][b] && (a[c][b] = !1), e = k(e, {enumerable: v(0, !1)})) : (d(a, c) || i(a, c, v(1, {})), a[c][b] = !0), y(a, b, e)) : i(a, b, e);
            },
            u = function defineProperties(a, b) {
              O(a);
              for (var c,
                  d = Q(b = p(b)),
                  e = 0,
                  f = d.length; f > e; )
                t(a, c = d[e++], b[c]);
              return a;
            },
            F = function create(b, c) {
              return c === a ? k(b) : u(k(b), c);
            },
            E = function propertyIsEnumerable(a) {
              var b = N.call(this, a);
              return b || !d(this, a) || !d(h, a) || d(this, c) && this[c][a] ? b : !0;
            },
            D = function getOwnPropertyDescriptor(a, b) {
              var e = I(a = p(a), b);
              return !e || !d(h, b) || d(a, c) && a[c][b] || (e.enumerable = !0), e;
            },
            B = function getOwnPropertyNames(g) {
              for (var a,
                  b = z(p(g)),
                  e = [],
                  f = 0; b.length > f; )
                d(h, a = b[f++]) || a == c || e.push(a);
              return e;
            },
            M = function getOwnPropertySymbols(f) {
              for (var a,
                  b = z(p(f)),
                  c = [],
                  e = 0; b.length > e; )
                d(h, a = b[e++]) && c.push(h[a]);
              return c;
            },
            T = function stringify(e) {
              if (e !== a && !r(e)) {
                for (var b,
                    c,
                    d = [e],
                    f = 1,
                    g = arguments; g.length > f; )
                  d.push(g[f++]);
                return b = d[1], "function" == typeof b && (c = b), (c || !P(b)) && (b = function(b, a) {
                  return c && (a = c.call(this, b, a)), r(a) ? void 0 : a;
                }), d[1] = b, m.apply(l, d);
              }
            },
            U = H(function() {
              var a = g();
              return "[null]" != m([a]) || "{}" != m({a: a}) || "{}" != m(Object(a));
            });
        q || (g = function Symbol() {
          if (r(this))
            throw TypeError("Symbol is not a constructor");
          return L(S(arguments.length > 0 ? arguments[0] : a));
        }, G(g.prototype, "toString", function toString() {
          return this._k;
        }), r = function(a) {
          return a instanceof g;
        }, e.create = F, e.isEnum = E, e.getDesc = D, e.setDesc = t, e.setDescs = u, e.getNames = C.get = B, e.getSymbols = M, w && !b(39) && G(j, "propertyIsEnumerable", E, !0));
        var K = {
          "for": function(a) {
            return d(o, a += "") ? o[a] : o[a] = g(a);
          },
          keyFor: function keyFor(a) {
            return R(o, a);
          },
          useSetter: function() {
            n = !0;
          },
          useSimple: function() {
            n = !1;
          }
        };
        e.each.call("hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), function(a) {
          var b = A(a);
          K[a] = q ? b : L(b);
        }), n = !0, f(f.G + f.W, {Symbol: g}), f(f.S, "Symbol", K), f(f.S + f.F * !q, "Object", {
          create: F,
          defineProperty: t,
          defineProperties: u,
          getOwnPropertyDescriptor: D,
          getOwnPropertyNames: B,
          getOwnPropertySymbols: M
        }), l && f(f.S + f.F * (!q || U), "JSON", {stringify: T}), s(g, "Symbol"), s(Math, "Math", !0), s(x.JSON, "JSON", !0);
      }, function(c, f, a) {
        var d = a(2).setDesc,
            e = a(17),
            b = a(31)("toStringTag");
        c.exports = function(a, c, f) {
          a && !e(a = f ? a : a.prototype, b) && d(a, b, {
            configurable: !0,
            value: c
          });
        };
      }, function(b, e, a) {
        var c = a(2),
            d = a(23);
        b.exports = function(g, h) {
          for (var a,
              b = d(g),
              e = c.getKeys(b),
              i = e.length,
              f = 0; i > f; )
            if (b[a = e[f++]] === h)
              return a;
        };
      }, function(d, h, a) {
        var e = a(23),
            b = a(2).getNames,
            f = {}.toString,
            c = "object" == typeof window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
            g = function(a) {
              try {
                return b(a);
              } catch (d) {
                return c.slice();
              }
            };
        d.exports.get = function getOwnPropertyNames(a) {
          return c && "[object Window]" == f.call(a) ? g(a) : b(e(a));
        };
      }, function(b, d, c) {
        var a = c(2);
        b.exports = function(b) {
          var c = a.getKeys(b),
              d = a.getSymbols;
          if (d)
            for (var e,
                f = d(b),
                h = a.isEnum,
                g = 0; f.length > g; )
              h.call(b, e = f[g++]) && c.push(e);
          return c;
        };
      }, function(a, b) {
        a.exports = !1;
      }, function(c, d, b) {
        var a = b(3);
        a(a.S + a.F, "Object", {assign: b(41)});
      }, function(c, f, a) {
        var b = a(2),
            d = a(21),
            e = a(24);
        c.exports = a(9)(function() {
          var a = Object.assign,
              b = {},
              c = {},
              d = Symbol(),
              e = "abcdefghijklmnopqrst";
          return b[d] = 7, e.split("").forEach(function(a) {
            c[a] = a;
          }), 7 != a({}, b)[d] || Object.keys(a({}, c)).join("") != e;
        }) ? function assign(n, q) {
          for (var g = d(n),
              h = arguments,
              o = h.length,
              j = 1,
              f = b.getKeys,
              l = b.getSymbols,
              m = b.isEnum; o > j; )
            for (var c,
                a = e(h[j++]),
                k = l ? f(a).concat(l(a)) : f(a),
                p = k.length,
                i = 0; p > i; )
              m.call(a, c = k[i++]) && (g[c] = a[c]);
          return g;
        } : Object.assign;
      }, function(c, d, a) {
        var b = a(3);
        b(b.S, "Object", {is: a(43)});
      }, function(a, b) {
        a.exports = Object.is || function is(a, b) {
          return a === b ? 0 !== a || 1 / a === 1 / b : a != a && b != b;
        };
      }, function(c, d, a) {
        var b = a(3);
        b(b.S, "Object", {setPrototypeOf: a(45).set});
      }, function(d, h, b) {
        var e = b(2).getDesc,
            f = b(16),
            g = b(20),
            c = function(b, a) {
              if (g(b), !f(a) && null !== a)
                throw TypeError(a + ": can't set as prototype!");
            };
        d.exports = {
          set: Object.setPrototypeOf || ("__proto__" in {} ? function(f, a, d) {
            try {
              d = b(12)(Function.call, e(Object.prototype, "__proto__").set, 2), d(f, []), a = !(f instanceof Array);
            } catch (g) {
              a = !0;
            }
            return function setPrototypeOf(b, e) {
              return c(b, e), a ? b.__proto__ = e : d(b, e), b;
            };
          }({}, !1) : a),
          check: c
        };
      }, function(d, e, a) {
        var c = a(47),
            b = {};
        b[a(31)("toStringTag")] = "z", b + "" != "[object z]" && a(10)(Object.prototype, "toString", function toString() {
          return "[object " + c(this) + "]";
        }, !0);
      }, function(d, g, c) {
        var b = c(18),
            e = c(31)("toStringTag"),
            f = "Arguments" == b(function() {
              return arguments;
            }());
        d.exports = function(d) {
          var c,
              g,
              h;
          return d === a ? "Undefined" : null === d ? "Null" : "string" == typeof(g = (c = Object(d))[e]) ? g : f ? b(c) : "Object" == (h = b(c)) && "function" == typeof c.callee ? "Arguments" : h;
        };
      }, function(c, d, a) {
        var b = a(16);
        a(49)("freeze", function(a) {
          return function freeze(c) {
            return a && b(c) ? a(c) : c;
          };
        });
      }, function(c, f, a) {
        var b = a(3),
            d = a(5),
            e = a(9);
        c.exports = function(a, g) {
          var c = (d.Object || {})[a] || Object[a],
              f = {};
          f[a] = g(c), b(b.S + b.F * e(function() {
            c(1);
          }), "Object", f);
        };
      }, function(c, d, a) {
        var b = a(16);
        a(49)("seal", function(a) {
          return function seal(c) {
            return a && b(c) ? a(c) : c;
          };
        });
      }, function(c, d, a) {
        var b = a(16);
        a(49)("preventExtensions", function(a) {
          return function preventExtensions(c) {
            return a && b(c) ? a(c) : c;
          };
        });
      }, function(c, d, a) {
        var b = a(16);
        a(49)("isFrozen", function(a) {
          return function isFrozen(c) {
            return b(c) ? a ? a(c) : !1 : !0;
          };
        });
      }, function(c, d, a) {
        var b = a(16);
        a(49)("isSealed", function(a) {
          return function isSealed(c) {
            return b(c) ? a ? a(c) : !1 : !0;
          };
        });
      }, function(c, d, a) {
        var b = a(16);
        a(49)("isExtensible", function(a) {
          return function isExtensible(c) {
            return b(c) ? a ? a(c) : !0 : !1;
          };
        });
      }, function(c, d, a) {
        var b = a(23);
        a(49)("getOwnPropertyDescriptor", function(a) {
          return function getOwnPropertyDescriptor(c, d) {
            return a(b(c), d);
          };
        });
      }, function(c, d, a) {
        var b = a(21);
        a(49)("getPrototypeOf", function(a) {
          return function getPrototypeOf(c) {
            return a(b(c));
          };
        });
      }, function(c, d, a) {
        var b = a(21);
        a(49)("keys", function(a) {
          return function keys(c) {
            return a(b(c));
          };
        });
      }, function(b, c, a) {
        a(49)("getOwnPropertyNames", function() {
          return a(37).get;
        });
      }, function(h, i, a) {
        var c = a(2).setDesc,
            e = a(7),
            f = a(17),
            d = Function.prototype,
            g = /^\s*function ([^ (]*)/,
            b = "name";
        b in d || a(8) && c(d, b, {
          configurable: !0,
          get: function() {
            var a = ("" + this).match(g),
                d = a ? a[1] : "";
            return f(this, b) || c(this, b, e(5, d)), d;
          }
        });
      }, function(f, g, a) {
        var b = a(2),
            c = a(16),
            d = a(31)("hasInstance"),
            e = Function.prototype;
        d in e || b.setDesc(e, d, {value: function(a) {
            if ("function" != typeof this || !c(a))
              return !1;
            if (!c(this.prototype))
              return a instanceof this;
            for (; a = b.getProto(a); )
              if (this.prototype === a)
                return !0;
            return !1;
          }});
      }, function(q, p, b) {
        var c = b(2),
            h = b(4),
            i = b(17),
            j = b(18),
            l = b(62),
            k = b(9),
            n = b(63).trim,
            d = "Number",
            a = h[d],
            e = a,
            f = a.prototype,
            o = j(c.create(f)) == d,
            m = "trim" in String.prototype,
            g = function(i) {
              var a = l(i, !1);
              if ("string" == typeof a && a.length > 2) {
                a = m ? a.trim() : n(a, 3);
                var b,
                    c,
                    d,
                    e = a.charCodeAt(0);
                if (43 === e || 45 === e) {
                  if (b = a.charCodeAt(2), 88 === b || 120 === b)
                    return NaN;
                } else if (48 === e) {
                  switch (a.charCodeAt(1)) {
                    case 66:
                    case 98:
                      c = 2, d = 49;
                      break;
                    case 79:
                    case 111:
                      c = 8, d = 55;
                      break;
                    default:
                      return +a;
                  }
                  for (var f,
                      g = a.slice(2),
                      h = 0,
                      j = g.length; j > h; h++)
                    if (f = g.charCodeAt(h), 48 > f || f > d)
                      return NaN;
                  return parseInt(g, c);
                }
              }
              return +a;
            };
        a(" 0o1") && a("0b1") && !a("+0x1") || (a = function Number(h) {
          var c = arguments.length < 1 ? 0 : h,
              b = this;
          return b instanceof a && (o ? k(function() {
            f.valueOf.call(b);
          }) : j(b) != d) ? new e(g(c)) : g(c);
        }, c.each.call(b(8) ? c.getNames(e) : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","), function(b) {
          i(e, b) && !i(a, b) && c.setDesc(a, b, c.getDesc(e, b));
        }), a.prototype = f, f.constructor = a, b(10)(h, d, a));
      }, function(b, d, c) {
        var a = c(16);
        b.exports = function(b, e) {
          if (!a(b))
            return b;
          var c,
              d;
          if (e && "function" == typeof(c = b.toString) && !a(d = c.call(b)))
            return d;
          if ("function" == typeof(c = b.valueOf) && !a(d = c.call(b)))
            return d;
          if (!e && "function" == typeof(c = b.toString) && !a(d = c.call(b)))
            return d;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(g, m, b) {
        var c = b(3),
            h = b(22),
            i = b(9),
            d = "	\n\f\r   ᠎             　\u2028\u2029\ufeff",
            a = "[" + d + "]",
            f = "​",
            j = RegExp("^" + a + a + "*"),
            k = RegExp(a + a + "*$"),
            e = function(a, e) {
              var b = {};
              b[a] = e(l), c(c.P + c.F * i(function() {
                return !!d[a]() || f[a]() != f;
              }), "String", b);
            },
            l = e.trim = function(a, b) {
              return a = String(h(a)), 1 & b && (a = a.replace(j, "")), 2 & b && (a = a.replace(k, "")), a;
            };
        g.exports = e;
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Number", {EPSILON: Math.pow(2, -52)});
      }, function(d, e, a) {
        var b = a(3),
            c = a(4).isFinite;
        b(b.S, "Number", {isFinite: function isFinite(a) {
            return "number" == typeof a && c(a);
          }});
      }, function(c, d, a) {
        var b = a(3);
        b(b.S, "Number", {isInteger: a(67)});
      }, function(a, e, b) {
        var c = b(16),
            d = Math.floor;
        a.exports = function isInteger(a) {
          return !c(a) && isFinite(a) && d(a) === a;
        };
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Number", {isNaN: function isNaN(a) {
            return a != a;
          }});
      }, function(e, f, a) {
        var b = a(3),
            c = a(67),
            d = Math.abs;
        b(b.S, "Number", {isSafeInteger: function isSafeInteger(a) {
            return c(a) && d(a) <= 9007199254740991;
          }});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Number", {MAX_SAFE_INTEGER: 9007199254740991});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Number", {MIN_SAFE_INTEGER: -9007199254740991});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Number", {parseFloat: parseFloat});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Number", {parseInt: parseInt});
      }, function(f, g, b) {
        var a = b(3),
            e = b(75),
            c = Math.sqrt,
            d = Math.acosh;
        a(a.S + a.F * !(d && 710 == Math.floor(d(Number.MAX_VALUE))), "Math", {acosh: function acosh(a) {
            return (a = +a) < 1 ? NaN : a > 94906265.62425156 ? Math.log(a) + Math.LN2 : e(a - 1 + c(a - 1) * c(a + 1));
          }});
      }, function(a, b) {
        a.exports = Math.log1p || function log1p(a) {
          return (a = +a) > -1e-8 && 1e-8 > a ? a - a * a / 2 : Math.log(1 + a);
        };
      }, function(c, d, b) {
        function asinh(a) {
          return isFinite(a = +a) && 0 != a ? 0 > a ? -asinh(-a) : Math.log(a + Math.sqrt(a * a + 1)) : a;
        }
        var a = b(3);
        a(a.S, "Math", {asinh: asinh});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Math", {atanh: function atanh(a) {
            return 0 == (a = +a) ? a : Math.log((1 + a) / (1 - a)) / 2;
          }});
      }, function(d, e, a) {
        var b = a(3),
            c = a(79);
        b(b.S, "Math", {cbrt: function cbrt(a) {
            return c(a = +a) * Math.pow(Math.abs(a), 1 / 3);
          }});
      }, function(a, b) {
        a.exports = Math.sign || function sign(a) {
          return 0 == (a = +a) || a != a ? a : 0 > a ? -1 : 1;
        };
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Math", {clz32: function clz32(a) {
            return (a >>>= 0) ? 31 - Math.floor(Math.log(a + .5) * Math.LOG2E) : 32;
          }});
      }, function(d, e, c) {
        var a = c(3),
            b = Math.exp;
        a(a.S, "Math", {cosh: function cosh(a) {
            return (b(a = +a) + b(-a)) / 2;
          }});
      }, function(c, d, a) {
        var b = a(3);
        b(b.S, "Math", {expm1: a(83)});
      }, function(a, b) {
        a.exports = Math.expm1 || function expm1(a) {
          return 0 == (a = +a) ? a : a > -1e-6 && 1e-6 > a ? a + a * a / 2 : Math.exp(a) - 1;
        };
      }, function(k, j, e) {
        var f = e(3),
            g = e(79),
            a = Math.pow,
            d = a(2, -52),
            b = a(2, -23),
            i = a(2, 127) * (2 - b),
            c = a(2, -126),
            h = function(a) {
              return a + 1 / d - 1 / d;
            };
        f(f.S, "Math", {fround: function fround(k) {
            var f,
                a,
                e = Math.abs(k),
                j = g(k);
            return c > e ? j * h(e / c / b) * c * b : (f = (1 + b / d) * e, a = f - (f - e), a > i || a != a ? j * (1 / 0) : j * a);
          }});
      }, function(d, e, b) {
        var a = b(3),
            c = Math.abs;
        a(a.S, "Math", {hypot: function hypot(i, j) {
            for (var a,
                b,
                e = 0,
                f = 0,
                g = arguments,
                h = g.length,
                d = 0; h > f; )
              a = c(g[f++]), a > d ? (b = d / a, e = e * b * b + 1, d = a) : a > 0 ? (b = a / d, e += b * b) : e += a;
            return d === 1 / 0 ? 1 / 0 : d * Math.sqrt(e);
          }});
      }, function(d, e, b) {
        var a = b(3),
            c = Math.imul;
        a(a.S + a.F * b(9)(function() {
          return -5 != c(4294967295, 5) || 2 != c.length;
        }), "Math", {imul: function imul(f, g) {
            var a = 65535,
                b = +f,
                c = +g,
                d = a & b,
                e = a & c;
            return 0 | d * e + ((a & b >>> 16) * e + d * (a & c >>> 16) << 16 >>> 0);
          }});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Math", {log10: function log10(a) {
            return Math.log(a) / Math.LN10;
          }});
      }, function(c, d, a) {
        var b = a(3);
        b(b.S, "Math", {log1p: a(75)});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Math", {log2: function log2(a) {
            return Math.log(a) / Math.LN2;
          }});
      }, function(c, d, a) {
        var b = a(3);
        b(b.S, "Math", {sign: a(79)});
      }, function(e, f, a) {
        var b = a(3),
            c = a(83),
            d = Math.exp;
        b(b.S + b.F * a(9)(function() {
          return -2e-17 != !Math.sinh(-2e-17);
        }), "Math", {sinh: function sinh(a) {
            return Math.abs(a = +a) < 1 ? (c(a) - c(-a)) / 2 : (d(a - 1) - d(-a - 1)) * (Math.E / 2);
          }});
      }, function(e, f, a) {
        var b = a(3),
            c = a(83),
            d = Math.exp;
        b(b.S, "Math", {tanh: function tanh(a) {
            var b = c(a = +a),
                e = c(-a);
            return b == 1 / 0 ? 1 : e == 1 / 0 ? -1 : (b - e) / (d(a) + d(-a));
          }});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Math", {trunc: function trunc(a) {
            return (a > 0 ? Math.floor : Math.ceil)(a);
          }});
      }, function(f, g, b) {
        var a = b(3),
            e = b(26),
            c = String.fromCharCode,
            d = String.fromCodePoint;
        a(a.S + a.F * (!!d && 1 != d.length), "String", {fromCodePoint: function fromCodePoint(h) {
            for (var a,
                b = [],
                d = arguments,
                g = d.length,
                f = 0; g > f; ) {
              if (a = +d[f++], e(a, 1114111) !== a)
                throw RangeError(a + " is not a valid code point");
              b.push(65536 > a ? c(a) : c(((a -= 65536) >> 10) + 55296, a % 1024 + 56320));
            }
            return b.join("");
          }});
      }, function(e, f, a) {
        var b = a(3),
            c = a(23),
            d = a(27);
        b(b.S, "String", {raw: function raw(g) {
            for (var e = c(g.raw),
                h = d(e.length),
                f = arguments,
                i = f.length,
                b = [],
                a = 0; h > a; )
              b.push(String(e[a++])), i > a && b.push(String(f[a]));
            return b.join("");
          }});
      }, function(b, c, a) {
        a(63)("trim", function(a) {
          return function trim() {
            return a(this, 3);
          };
        });
      }, function(d, e, a) {
        var b = a(3),
            c = a(98)(!1);
        b(b.P, "String", {codePointAt: function codePointAt(a) {
            return c(this, a);
          }});
      }, function(c, f, b) {
        var d = b(25),
            e = b(22);
        c.exports = function(b) {
          return function(j, k) {
            var f,
                h,
                g = String(e(j)),
                c = d(k),
                i = g.length;
            return 0 > c || c >= i ? b ? "" : a : (f = g.charCodeAt(c), 55296 > f || f > 56319 || c + 1 === i || (h = g.charCodeAt(c + 1)) < 56320 || h > 57343 ? b ? g.charAt(c) : f : b ? g.slice(c, c + 2) : (f - 55296 << 10) + (h - 56320) + 65536);
          };
        };
      }, function(h, i, b) {
        var c = b(3),
            e = b(27),
            g = b(100),
            d = "endsWith",
            f = ""[d];
        c(c.P + c.F * b(102)(d), "String", {endsWith: function endsWith(i) {
            var b = g(this, i, d),
                j = arguments,
                k = j.length > 1 ? j[1] : a,
                l = e(b.length),
                c = k === a ? l : Math.min(e(k), l),
                h = String(i);
            return f ? f.call(b, h, c) : b.slice(c - h.length, c) === h;
          }});
      }, function(b, e, a) {
        var c = a(101),
            d = a(22);
        b.exports = function(a, b, e) {
          if (c(b))
            throw TypeError("String#" + e + " doesn't accept regex!");
          return String(d(a));
        };
      }, function(c, g, b) {
        var d = b(16),
            e = b(18),
            f = b(31)("match");
        c.exports = function(b) {
          var c;
          return d(b) && ((c = b[f]) !== a ? !!c : "RegExp" == e(b));
        };
      }, function(a, d, b) {
        var c = b(31)("match");
        a.exports = function(b) {
          var a = /./;
          try {
            "/./"[b](a);
          } catch (d) {
            try {
              return a[c] = !1, !"/./"[b](a);
            } catch (e) {}
          }
          return !0;
        };
      }, function(f, g, b) {
        var c = b(3),
            e = b(100),
            d = "includes";
        c(c.P + c.F * b(102)(d), "String", {includes: function includes(b) {
            return !!~e(this, b, d).indexOf(b, arguments.length > 1 ? arguments[1] : a);
          }});
      }, function(c, d, a) {
        var b = a(3);
        b(b.P, "String", {repeat: a(105)});
      }, function(b, e, a) {
        var c = a(25),
            d = a(22);
        b.exports = function repeat(f) {
          var b = String(d(this)),
              e = "",
              a = c(f);
          if (0 > a || a == 1 / 0)
            throw RangeError("Count can't be negative");
          for (; a > 0; (a >>>= 1) && (b += b))
            1 & a && (e += b);
          return e;
        };
      }, function(h, i, b) {
        var c = b(3),
            f = b(27),
            g = b(100),
            d = "startsWith",
            e = ""[d];
        c(c.P + c.F * b(102)(d), "String", {startsWith: function startsWith(i) {
            var b = g(this, i, d),
                j = arguments,
                c = f(Math.min(j.length > 1 ? j[1] : a, b.length)),
                h = String(i);
            return e ? e.call(b, h, c) : b.slice(c, c + h.length) === h;
          }});
      }, function(d, e, b) {
        var c = b(98)(!0);
        b(108)(String, "String", function(a) {
          this._t = String(a), this._i = 0;
        }, function() {
          var b,
              d = this._t,
              e = this._i;
          return e >= d.length ? {
            value: a,
            done: !0
          } : (b = c(d, e), this._i += b.length, {
            value: b,
            done: !1
          });
        });
      }, function(o, r, a) {
        var i = a(39),
            d = a(3),
            n = a(10),
            h = a(6),
            m = a(17),
            f = a(109),
            q = a(110),
            p = a(35),
            l = a(2).getProto,
            c = a(31)("iterator"),
            e = !([].keys && "next" in [].keys()),
            j = "@@iterator",
            k = "keys",
            b = "values",
            g = function() {
              return this;
            };
        o.exports = function(B, v, u, F, s, E, A) {
          q(u, v, F);
          var r,
              x,
              w = function(c) {
                if (!e && c in a)
                  return a[c];
                switch (c) {
                  case k:
                    return function keys() {
                      return new u(this, c);
                    };
                  case b:
                    return function values() {
                      return new u(this, c);
                    };
                }
                return function entries() {
                  return new u(this, c);
                };
              },
              C = v + " Iterator",
              y = s == b,
              z = !1,
              a = B.prototype,
              t = a[c] || a[j] || s && a[s],
              o = t || w(s);
          if (t) {
            var D = l(o.call(new B));
            p(D, C, !0), !i && m(a, j) && h(D, c, g), y && t.name !== b && (z = !0, o = function values() {
              return t.call(this);
            });
          }
          if (i && !A || !e && !z && a[c] || h(a, c, o), f[v] = o, f[C] = g, s)
            if (r = {
              values: y ? o : w(b),
              keys: E ? o : w(k),
              entries: y ? w("entries") : o
            }, A)
              for (x in r)
                x in a || n(a, x, r[x]);
            else
              d(d.P + d.F * (e || z), v, r);
          return r;
        };
      }, function(a, b) {
        a.exports = {};
      }, function(c, g, a) {
        var d = a(2),
            e = a(7),
            f = a(35),
            b = {};
        a(6)(b, a(31)("iterator"), function() {
          return this;
        }), c.exports = function(a, c, g) {
          a.prototype = d.create(b, {next: e(1, g)}), f(a, c + " Iterator");
        };
      }, function(j, k, b) {
        var d = b(12),
            c = b(3),
            e = b(21),
            f = b(112),
            g = b(113),
            h = b(27),
            i = b(114);
        c(c.S + c.F * !b(115)(function(a) {
          Array.from(a);
        }), "Array", {from: function from(t) {
            var n,
                c,
                r,
                m,
                j = e(t),
                l = "function" == typeof this ? this : Array,
                p = arguments,
                s = p.length,
                k = s > 1 ? p[1] : a,
                q = k !== a,
                b = 0,
                o = i(j);
            if (q && (k = d(k, s > 2 ? p[2] : a, 2)), o == a || l == Array && g(o))
              for (n = h(j.length), c = new l(n); n > b; b++)
                c[b] = q ? k(j[b], b) : j[b];
            else
              for (m = o.call(j), c = new l; !(r = m.next()).done; b++)
                c[b] = q ? f(m, k, [r.value, b], !0) : r.value;
            return c.length = b, c;
          }});
      }, function(c, e, d) {
        var b = d(20);
        c.exports = function(d, e, c, g) {
          try {
            return g ? e(b(c)[0], c[1]) : e(c);
          } catch (h) {
            var f = d["return"];
            throw f !== a && b(f.call(d)), h;
          }
        };
      }, function(c, g, b) {
        var d = b(109),
            e = b(31)("iterator"),
            f = Array.prototype;
        c.exports = function(b) {
          return b !== a && (d.Array === b || f[e] === b);
        };
      }, function(c, g, b) {
        var d = b(47),
            e = b(31)("iterator"),
            f = b(109);
        c.exports = b(5).getIteratorMethod = function(b) {
          return b != a ? b[e] || b["@@iterator"] || f[d(b)] : void 0;
        };
      }, function(d, f, e) {
        var a = e(31)("iterator"),
            b = !1;
        try {
          var c = [7][a]();
          c["return"] = function() {
            b = !0;
          }, Array.from(c, function() {
            throw 2;
          });
        } catch (g) {}
        d.exports = function(f, g) {
          if (!g && !b)
            return !1;
          var d = !1;
          try {
            var c = [7],
                e = c[a]();
            e.next = function() {
              d = !0;
            }, c[a] = function() {
              return e;
            }, f(c);
          } catch (h) {}
          return d;
        };
      }, function(c, d, b) {
        var a = b(3);
        a(a.S + a.F * b(9)(function() {
          function F() {}
          return !(Array.of.call(F) instanceof F);
        }), "Array", {of: function of() {
            for (var a = 0,
                d = arguments,
                b = d.length,
                c = new ("function" == typeof this ? this : Array)(b); b > a; )
              c[a] = d[a++];
            return c.length = b, c;
          }});
      }, function(f, h, b) {
        var d = b(118),
            c = b(119),
            e = b(109),
            g = b(23);
        f.exports = b(108)(Array, "Array", function(a, b) {
          this._t = g(a), this._i = 0, this._k = b;
        }, function() {
          var d = this._t,
              e = this._k,
              b = this._i++;
          return !d || b >= d.length ? (this._t = a, c(1)) : "keys" == e ? c(0, b) : "values" == e ? c(0, d[b]) : c(0, [b, d[b]]);
        }, "values"), e.Arguments = e.Array, d("keys"), d("values"), d("entries");
      }, function(e, f, d) {
        var b = d(31)("unscopables"),
            c = Array.prototype;
        c[b] == a && d(6)(c, b, {}), e.exports = function(a) {
          c[b][a] = !0;
        };
      }, function(a, b) {
        a.exports = function(a, b) {
          return {
            value: b,
            done: !!a
          };
        };
      }, function(b, c, a) {
        a(121)("Array");
      }, function(c, g, a) {
        var d = a(4),
            e = a(2),
            f = a(8),
            b = a(31)("species");
        c.exports = function(c) {
          var a = d[c];
          f && a && !a[b] && e.setDesc(a, b, {
            configurable: !0,
            get: function() {
              return this;
            }
          });
        };
      }, function(c, d, a) {
        var b = a(3);
        b(b.P, "Array", {copyWithin: a(123)}), a(118)("copyWithin");
      }, function(d, g, b) {
        var e = b(21),
            c = b(26),
            f = b(27);
        d.exports = [].copyWithin || function copyWithin(m, n) {
          var g = e(this),
              h = f(g.length),
              b = c(m, h),
              d = c(n, h),
              k = arguments,
              l = k.length > 2 ? k[2] : a,
              i = Math.min((l === a ? h : c(l, h)) - d, h - b),
              j = 1;
          for (b > d && d + i > b && (j = -1, d += i - 1, b += i - 1); i-- > 0; )
            d in g ? g[b] = g[d] : delete g[b], b += j, d += j;
          return g;
        };
      }, function(c, d, a) {
        var b = a(3);
        b(b.P, "Array", {fill: a(125)}), a(118)("fill");
      }, function(d, g, b) {
        var e = b(21),
            c = b(26),
            f = b(27);
        d.exports = [].fill || function fill(k) {
          for (var b = e(this),
              d = f(b.length),
              g = arguments,
              h = g.length,
              i = c(h > 1 ? g[1] : a, d),
              j = h > 2 ? g[2] : a,
              l = j === a ? d : c(j, d); l > i; )
            b[i++] = k;
          return b;
        };
      }, function(g, h, b) {
        var c = b(3),
            f = b(28)(5),
            d = "find",
            e = !0;
        d in [] && Array(1)[d](function() {
          e = !1;
        }), c(c.P + c.F * e, "Array", {find: function find(b) {
            return f(this, b, arguments.length > 1 ? arguments[1] : a);
          }}), b(118)(d);
      }, function(g, h, b) {
        var c = b(3),
            f = b(28)(6),
            d = "findIndex",
            e = !0;
        d in [] && Array(1)[d](function() {
          e = !1;
        }), c(c.P + c.F * e, "Array", {findIndex: function findIndex(b) {
            return f(this, b, arguments.length > 1 ? arguments[1] : a);
          }}), b(118)(d);
      }, function(n, m, c) {
        var f = c(2),
            i = c(4),
            k = c(101),
            l = c(129),
            b = i.RegExp,
            d = b,
            j = b.prototype,
            e = /a/g,
            g = /a/g,
            h = new b(e) !== e;
        !c(8) || h && !c(9)(function() {
          return g[c(31)("match")] = !1, b(e) != e || b(g) == g || "/a/i" != b(e, "i");
        }) || (b = function RegExp(c, f) {
          var e = k(c),
              g = f === a;
          return this instanceof b || !e || c.constructor !== b || !g ? h ? new d(e && !g ? c.source : c, f) : d((e = c instanceof b) ? c.source : c, e && g ? l.call(c) : f) : c;
        }, f.each.call(f.getNames(d), function(a) {
          a in b || f.setDesc(b, a, {
            configurable: !0,
            get: function() {
              return d[a];
            },
            set: function(b) {
              d[a] = b;
            }
          });
        }), j.constructor = b, b.prototype = j, c(10)(i, "RegExp", b)), c(121)("RegExp");
      }, function(a, d, b) {
        var c = b(20);
        a.exports = function() {
          var b = c(this),
              a = "";
          return b.global && (a += "g"), b.ignoreCase && (a += "i"), b.multiline && (a += "m"), b.unicode && (a += "u"), b.sticky && (a += "y"), a;
        };
      }, function(c, d, a) {
        var b = a(2);
        a(8) && "g" != /./g.flags && b.setDesc(RegExp.prototype, "flags", {
          configurable: !0,
          get: a(129)
        });
      }, function(c, d, b) {
        b(132)("match", 1, function(c, b) {
          return function match(d) {
            var e = c(this),
                f = d == a ? a : d[b];
            return f !== a ? f.call(d, e) : new RegExp(d)[b](String(e));
          };
        });
      }, function(b, h, a) {
        var c = a(6),
            d = a(10),
            e = a(9),
            f = a(22),
            g = a(31);
        b.exports = function(a, i, j) {
          var b = g(a),
              h = ""[a];
          e(function() {
            var c = {};
            return c[b] = function() {
              return 7;
            }, 7 != ""[a](c);
          }) && (d(String.prototype, a, j(f, b, h)), c(RegExp.prototype, b, 2 == i ? function(a, b) {
            return h.call(a, this, b);
          } : function(a) {
            return h.call(a, this);
          }));
        };
      }, function(c, d, b) {
        b(132)("replace", 2, function(b, c, d) {
          return function replace(e, f) {
            var g = b(this),
                h = e == a ? a : e[c];
            return h !== a ? h.call(e, g, f) : d.call(String(g), e, f);
          };
        });
      }, function(c, d, b) {
        b(132)("search", 1, function(c, b) {
          return function search(d) {
            var e = c(this),
                f = d == a ? a : d[b];
            return f !== a ? f.call(d, e) : new RegExp(d)[b](String(e));
          };
        });
      }, function(c, d, b) {
        b(132)("split", 2, function(b, c, d) {
          return function split(e, f) {
            var g = b(this),
                h = e == a ? a : e[c];
            return h !== a ? h.call(e, g, f) : d.call(String(g), e, f);
          };
        });
      }, function(J, I, b) {
        var r,
            k = b(2),
            F = b(39),
            i = b(4),
            j = b(12),
            y = b(47),
            d = b(3),
            C = b(16),
            E = b(20),
            m = b(13),
            G = b(137),
            w = b(138),
            p = b(45).set,
            A = b(43),
            z = b(31)("species"),
            D = b(139),
            n = b(140),
            e = "Promise",
            o = i.process,
            H = "process" == y(o),
            c = i[e],
            q = function(b) {
              var a = new c(function() {});
              return b && (a.constructor = Object), c.resolve(a) === a;
            },
            g = function() {
              function P2(b) {
                var a = new c(b);
                return p(a, P2.prototype), a;
              }
              var a = !1;
              try {
                if (a = c && c.resolve && q(), p(P2, c), P2.prototype = k.create(c.prototype, {constructor: {value: P2}}), P2.resolve(5).then(function() {}) instanceof P2 || (a = !1), a && b(8)) {
                  var d = !1;
                  c.resolve(k.setDesc({}, "then", {get: function() {
                      d = !0;
                    }})), a = d;
                }
              } catch (e) {
                a = !1;
              }
              return a;
            }(),
            B = function(a, b) {
              return F && a === c && b === r ? !0 : A(a, b);
            },
            s = function(b) {
              var c = E(b)[z];
              return c != a ? c : b;
            },
            t = function(a) {
              var b;
              return C(a) && "function" == typeof(b = a.then) ? b : !1;
            },
            h = function(d) {
              var b,
                  c;
              this.promise = new d(function(d, e) {
                if (b !== a || c !== a)
                  throw TypeError("Bad Promise constructor");
                b = d, c = e;
              }), this.resolve = m(b), this.reject = m(c);
            },
            v = function(a) {
              try {
                a();
              } catch (b) {
                return {error: b};
              }
            },
            l = function(b, d) {
              if (!b.n) {
                b.n = !0;
                var c = b.c;
                n(function() {
                  for (var e = b.v,
                      f = 1 == b.s,
                      g = 0,
                      h = function(a) {
                        var c,
                            h,
                            g = f ? a.ok : a.fail,
                            i = a.resolve,
                            d = a.reject;
                        try {
                          g ? (f || (b.h = !0), c = g === !0 ? e : g(e), c === a.promise ? d(TypeError("Promise-chain cycle")) : (h = t(c)) ? h.call(c, i, d) : i(c)) : d(e);
                        } catch (j) {
                          d(j);
                        }
                      }; c.length > g; )
                    h(c[g++]);
                  c.length = 0, b.n = !1, d && setTimeout(function() {
                    var f,
                        c,
                        d = b.p;
                    x(d) && (H ? o.emit("unhandledRejection", e, d) : (f = i.onunhandledrejection) ? f({
                      promise: d,
                      reason: e
                    }) : (c = i.console) && c.error && c.error("Unhandled promise rejection", e)), b.a = a;
                  }, 1);
                });
              }
            },
            x = function(e) {
              var a,
                  b = e._d,
                  c = b.a || b.c,
                  d = 0;
              if (b.h)
                return !1;
              for (; c.length > d; )
                if (a = c[d++], a.fail || !x(a.promise))
                  return !1;
              return !0;
            },
            f = function(b) {
              var a = this;
              a.d || (a.d = !0, a = a.r || a, a.v = b, a.s = 2, a.a = a.c.slice(), l(a, !0));
            },
            u = function(b) {
              var c,
                  a = this;
              if (!a.d) {
                a.d = !0, a = a.r || a;
                try {
                  if (a.p === b)
                    throw TypeError("Promise can't be resolved itself");
                  (c = t(b)) ? n(function() {
                    var d = {
                      r: a,
                      d: !1
                    };
                    try {
                      c.call(b, j(u, d, 1), j(f, d, 1));
                    } catch (e) {
                      f.call(d, e);
                    }
                  }) : (a.v = b, a.s = 1, l(a, !1));
                } catch (d) {
                  f.call({
                    r: a,
                    d: !1
                  }, d);
                }
              }
            };
        g || (c = function Promise(d) {
          m(d);
          var b = this._d = {
            p: G(this, c, e),
            c: [],
            a: a,
            s: 0,
            d: !1,
            v: a,
            h: !1,
            n: !1
          };
          try {
            d(j(u, b, 1), j(f, b, 1));
          } catch (g) {
            f.call(b, g);
          }
        }, b(142)(c.prototype, {
          then: function then(d, e) {
            var a = new h(D(this, c)),
                f = a.promise,
                b = this._d;
            return a.ok = "function" == typeof d ? d : !0, a.fail = "function" == typeof e && e, b.c.push(a), b.a && b.a.push(a), b.s && l(b, !1), f;
          },
          "catch": function(b) {
            return this.then(a, b);
          }
        })), d(d.G + d.W + d.F * !g, {Promise: c}), b(35)(c, e), b(121)(e), r = b(5)[e], d(d.S + d.F * !g, e, {reject: function reject(b) {
            var a = new h(this),
                c = a.reject;
            return c(b), a.promise;
          }}), d(d.S + d.F * (!g || q(!0)), e, {resolve: function resolve(a) {
            if (a instanceof c && B(a.constructor, this))
              return a;
            var b = new h(this),
                d = b.resolve;
            return d(a), b.promise;
          }}), d(d.S + d.F * !(g && b(115)(function(a) {
          c.all(a)["catch"](function() {});
        })), e, {
          all: function all(g) {
            var c = s(this),
                b = new h(c),
                d = b.resolve,
                e = b.reject,
                a = [],
                f = v(function() {
                  w(g, !1, a.push, a);
                  var b = a.length,
                      f = Array(b);
                  b ? k.each.call(a, function(g, h) {
                    var a = !1;
                    c.resolve(g).then(function(c) {
                      a || (a = !0, f[h] = c, --b || d(f));
                    }, e);
                  }) : d(f);
                });
            return f && e(f.error), b.promise;
          },
          race: function race(e) {
            var b = s(this),
                a = new h(b),
                c = a.reject,
                d = v(function() {
                  w(e, !1, function(d) {
                    b.resolve(d).then(a.resolve, c);
                  });
                });
            return d && c(d.error), a.promise;
          }
        });
      }, function(a, b) {
        a.exports = function(a, b, c) {
          if (!(a instanceof b))
            throw TypeError(c + ": use the 'new' operator!");
          return a;
        };
      }, function(b, i, a) {
        var c = a(12),
            d = a(112),
            e = a(113),
            f = a(20),
            g = a(27),
            h = a(114);
        b.exports = function(a, j, o, p) {
          var n,
              b,
              k,
              l = h(a),
              m = c(o, p, j ? 2 : 1),
              i = 0;
          if ("function" != typeof l)
            throw TypeError(a + " is not iterable!");
          if (e(l))
            for (n = g(a.length); n > i; i++)
              j ? m(f(b = a[i])[0], b[1]) : m(a[i]);
          else
            for (k = l.call(a); !(b = k.next()).done; )
              d(k, m, b.value, j);
        };
      }, function(d, g, b) {
        var c = b(20),
            e = b(13),
            f = b(31)("species");
        d.exports = function(g, h) {
          var b,
              d = c(g).constructor;
          return d === a || (b = c(d)[f]) == a ? h : e(b);
        };
      }, function(n, p, h) {
        var b,
            f,
            g,
            c = h(4),
            o = h(141).set,
            k = c.MutationObserver || c.WebKitMutationObserver,
            d = c.process,
            i = c.Promise,
            j = "process" == h(18)(d),
            e = function() {
              var e,
                  c,
                  g;
              for (j && (e = d.domain) && (d.domain = null, e.exit()); b; )
                c = b.domain, g = b.fn, c && c.enter(), g(), c && c.exit(), b = b.next;
              f = a, e && e.enter();
            };
        if (j)
          g = function() {
            d.nextTick(e);
          };
        else if (k) {
          var m = 1,
              l = document.createTextNode("");
          new k(e).observe(l, {characterData: !0}), g = function() {
            l.data = m = -m;
          };
        } else
          g = i && i.resolve ? function() {
            i.resolve().then(e);
          } : function() {
            o.call(c, e);
          };
        n.exports = function asap(e) {
          var c = {
            fn: e,
            next: a,
            domain: j && d.domain
          };
          f && (f.next = c), b || (b = c, g()), f = c;
        };
      }, function(s, t, b) {
        var c,
            g,
            f,
            k = b(12),
            r = b(19),
            n = b(14),
            p = b(15),
            a = b(4),
            l = a.process,
            h = a.setImmediate,
            i = a.clearImmediate,
            o = a.MessageChannel,
            j = 0,
            d = {},
            q = "onreadystatechange",
            e = function() {
              var a = +this;
              if (d.hasOwnProperty(a)) {
                var b = d[a];
                delete d[a], b();
              }
            },
            m = function(a) {
              e.call(a.data);
            };
        h && i || (h = function setImmediate(a) {
          for (var b = [],
              e = 1; arguments.length > e; )
            b.push(arguments[e++]);
          return d[++j] = function() {
            r("function" == typeof a ? a : Function(a), b);
          }, c(j), j;
        }, i = function clearImmediate(a) {
          delete d[a];
        }, "process" == b(18)(l) ? c = function(a) {
          l.nextTick(k(e, a, 1));
        } : o ? (g = new o, f = g.port2, g.port1.onmessage = m, c = k(f.postMessage, f, 1)) : a.addEventListener && "function" == typeof postMessage && !a.importScripts ? (c = function(b) {
          a.postMessage(b + "", "*");
        }, a.addEventListener("message", m, !1)) : c = q in p("script") ? function(a) {
          n.appendChild(p("script"))[q] = function() {
            n.removeChild(this), e.call(a);
          };
        } : function(a) {
          setTimeout(k(e, a, 1), 0);
        }), s.exports = {
          set: h,
          clear: i
        };
      }, function(a, d, b) {
        var c = b(10);
        a.exports = function(a, b) {
          for (var d in b)
            c(a, d, b[d]);
          return a;
        };
      }, function(d, e, c) {
        var b = c(144);
        c(145)("Map", function(b) {
          return function Map() {
            return b(this, arguments.length > 0 ? arguments[0] : a);
          };
        }, {
          get: function get(c) {
            var a = b.getEntry(this, c);
            return a && a.v;
          },
          set: function set(a, c) {
            return b.def(this, 0 === a ? 0 : a, c);
          }
        }, b, !0);
      }, function(v, w, b) {
        var j = b(2),
            m = b(6),
            o = b(142),
            n = b(12),
            p = b(137),
            r = b(22),
            t = b(138),
            l = b(108),
            d = b(119),
            f = b(11)("id"),
            k = b(17),
            h = b(16),
            q = b(121),
            i = b(8),
            s = Object.isExtensible || h,
            c = i ? "_s" : "size",
            u = 0,
            g = function(a, b) {
              if (!h(a))
                return "symbol" == typeof a ? a : ("string" == typeof a ? "S" : "P") + a;
              if (!k(a, f)) {
                if (!s(a))
                  return "F";
                if (!b)
                  return "E";
                m(a, f, ++u);
              }
              return "O" + a[f];
            },
            e = function(b, c) {
              var a,
                  d = g(c);
              if ("F" !== d)
                return b._i[d];
              for (a = b._f; a; a = a.n)
                if (a.k == c)
                  return a;
            };
        v.exports = {
          getConstructor: function(d, f, g, h) {
            var b = d(function(d, e) {
              p(d, b, f), d._i = j.create(null), d._f = a, d._l = a, d[c] = 0, e != a && t(e, g, d[h], d);
            });
            return o(b.prototype, {
              clear: function clear() {
                for (var d = this,
                    e = d._i,
                    b = d._f; b; b = b.n)
                  b.r = !0, b.p && (b.p = b.p.n = a), delete e[b.i];
                d._f = d._l = a, d[c] = 0;
              },
              "delete": function(g) {
                var b = this,
                    a = e(b, g);
                if (a) {
                  var d = a.n,
                      f = a.p;
                  delete b._i[a.i], a.r = !0, f && (f.n = d), d && (d.p = f), b._f == a && (b._f = d), b._l == a && (b._l = f), b[c]--;
                }
                return !!a;
              },
              forEach: function forEach(c) {
                for (var b,
                    d = n(c, arguments.length > 1 ? arguments[1] : a, 3); b = b ? b.n : this._f; )
                  for (d(b.v, b.k, this); b && b.r; )
                    b = b.p;
              },
              has: function has(a) {
                return !!e(this, a);
              }
            }), i && j.setDesc(b.prototype, "size", {get: function() {
                return r(this[c]);
              }}), b;
          },
          def: function(b, f, j) {
            var h,
                i,
                d = e(b, f);
            return d ? d.v = j : (b._l = d = {
              i: i = g(f, !0),
              k: f,
              v: j,
              p: h = b._l,
              n: a,
              r: !1
            }, b._f || (b._f = d), h && (h.n = d), b[c]++, "F" !== i && (b._i[i] = d)), b;
          },
          getEntry: e,
          setStrong: function(e, b, c) {
            l(e, b, function(b, c) {
              this._t = b, this._k = c, this._l = a;
            }, function() {
              for (var c = this,
                  e = c._k,
                  b = c._l; b && b.r; )
                b = b.p;
              return c._t && (c._l = b = b ? b.n : c._t._f) ? "keys" == e ? d(0, b.k) : "values" == e ? d(0, b.v) : d(0, [b.k, b.v]) : (c._t = a, d(1));
            }, c ? "entries" : "values", !c, !0), q(b);
          }
        };
      }, function(l, n, b) {
        var k = b(4),
            c = b(3),
            g = b(10),
            f = b(142),
            i = b(138),
            j = b(137),
            d = b(16),
            e = b(9),
            h = b(115),
            m = b(35);
        l.exports = function(o, v, y, x, p, l) {
          var t = k[o],
              b = t,
              s = p ? "set" : "add",
              n = b && b.prototype,
              w = {},
              r = function(b) {
                var c = n[b];
                g(n, b, "delete" == b ? function(a) {
                  return l && !d(a) ? !1 : c.call(this, 0 === a ? 0 : a);
                } : "has" == b ? function has(a) {
                  return l && !d(a) ? !1 : c.call(this, 0 === a ? 0 : a);
                } : "get" == b ? function get(b) {
                  return l && !d(b) ? a : c.call(this, 0 === b ? 0 : b);
                } : "add" == b ? function add(a) {
                  return c.call(this, 0 === a ? 0 : a), this;
                } : function set(a, b) {
                  return c.call(this, 0 === a ? 0 : a, b), this;
                });
              };
          if ("function" == typeof b && (l || n.forEach && !e(function() {
            (new b).entries().next();
          }))) {
            var u,
                q = new b,
                z = q[s](l ? {} : -0, 1) != q,
                A = e(function() {
                  q.has(1);
                }),
                B = h(function(a) {
                  new b(a);
                });
            B || (b = v(function(e, d) {
              j(e, b, o);
              var c = new t;
              return d != a && i(d, p, c[s], c), c;
            }), b.prototype = n, n.constructor = b), l || q.forEach(function(b, a) {
              u = 1 / a === -(1 / 0);
            }), (A || u) && (r("delete"), r("has"), p && r("get")), (u || z) && r(s), l && n.clear && delete n.clear;
          } else
            b = x.getConstructor(v, o, p, s), f(b.prototype, y);
          return m(b, o), w[o] = b, c(c.G + c.W + c.F * (b != t), w), l || x.setStrong(b, o, p), b;
        };
      }, function(d, e, b) {
        var c = b(144);
        b(145)("Set", function(b) {
          return function Set() {
            return b(this, arguments.length > 0 ? arguments[0] : a);
          };
        }, {add: function add(a) {
            return c.def(this, a = 0 === a ? 0 : a, a);
          }}, c);
      }, function(n, m, b) {
        var l = b(2),
            k = b(10),
            c = b(148),
            d = b(16),
            j = b(17),
            i = c.frozenStore,
            h = c.WEAK,
            f = Object.isExtensible || d,
            e = {},
            g = b(145)("WeakMap", function(b) {
              return function WeakMap() {
                return b(this, arguments.length > 0 ? arguments[0] : a);
              };
            }, {
              get: function get(a) {
                if (d(a)) {
                  if (!f(a))
                    return i(this).get(a);
                  if (j(a, h))
                    return a[h][this._i];
                }
              },
              set: function set(a, b) {
                return c.def(this, a, b);
              }
            }, c, !0, !0);
        7 != (new g).set((Object.freeze || Object)(e), 7).get(e) && l.each.call(["delete", "has", "get", "set"], function(a) {
          var b = g.prototype,
              c = b[a];
          k(b, a, function(b, e) {
            if (d(b) && !f(b)) {
              var g = i(this)[a](b, e);
              return "set" == a ? this : g;
            }
            return c.call(this, b, e);
          });
        });
      }, function(s, t, b) {
        var r = b(6),
            q = b(142),
            m = b(20),
            h = b(16),
            l = b(137),
            k = b(138),
            j = b(28),
            d = b(17),
            c = b(11)("weak"),
            g = Object.isExtensible || h,
            n = j(5),
            o = j(6),
            p = 0,
            e = function(a) {
              return a._l || (a._l = new i);
            },
            i = function() {
              this.a = [];
            },
            f = function(a, b) {
              return n(a.a, function(a) {
                return a[0] === b;
              });
            };
        i.prototype = {
          get: function(b) {
            var a = f(this, b);
            return a ? a[1] : void 0;
          },
          has: function(a) {
            return !!f(this, a);
          },
          set: function(a, b) {
            var c = f(this, a);
            c ? c[1] = b : this.a.push([a, b]);
          },
          "delete": function(b) {
            var a = o(this.a, function(a) {
              return a[0] === b;
            });
            return ~a && this.a.splice(a, 1), !!~a;
          }
        }, s.exports = {
          getConstructor: function(f, i, j, m) {
            var b = f(function(c, d) {
              l(c, b, i), c._i = p++, c._l = a, d != a && k(d, j, c[m], c);
            });
            return q(b.prototype, {
              "delete": function(a) {
                return h(a) ? g(a) ? d(a, c) && d(a[c], this._i) && delete a[c][this._i] : e(this)["delete"](a) : !1;
              },
              has: function has(a) {
                return h(a) ? g(a) ? d(a, c) && d(a[c], this._i) : e(this).has(a) : !1;
              }
            }), b;
          },
          def: function(b, a, f) {
            return g(m(a)) ? (d(a, c) || r(a, c, {}), a[c][b._i] = f) : e(b).set(a, f), b;
          },
          frozenStore: e,
          WEAK: c
        };
      }, function(d, e, b) {
        var c = b(148);
        b(145)("WeakSet", function(b) {
          return function WeakSet() {
            return b(this, arguments.length > 0 ? arguments[0] : a);
          };
        }, {add: function add(a) {
            return c.def(this, a, !0);
          }}, c, !1, !0);
      }, function(d, e, b) {
        var a = b(3),
            c = Function.apply;
        a(a.S, "Reflect", {apply: function apply(a, b, d) {
            return c.call(a, b, d);
          }});
      }, function(i, j, b) {
        var f = b(2),
            c = b(3),
            d = b(13),
            g = b(20),
            e = b(16),
            h = Function.bind || b(5).Function.prototype.bind;
        c(c.S + c.F * b(9)(function() {
          function F() {}
          return !(Reflect.construct(function() {}, [], F) instanceof F);
        }), "Reflect", {construct: function construct(c, b) {
            d(c);
            var j = arguments.length < 3 ? c : d(arguments[2]);
            if (c == j) {
              if (b != a)
                switch (g(b).length) {
                  case 0:
                    return new c;
                  case 1:
                    return new c(b[0]);
                  case 2:
                    return new c(b[0], b[1]);
                  case 3:
                    return new c(b[0], b[1], b[2]);
                  case 4:
                    return new c(b[0], b[1], b[2], b[3]);
                }
              var i = [null];
              return i.push.apply(i, b), new (h.apply(c, i));
            }
            var k = j.prototype,
                l = f.create(e(k) ? k : Object.prototype),
                m = Function.apply.call(c, l, b);
            return e(m) ? m : l;
          }});
      }, function(e, f, a) {
        var c = a(2),
            b = a(3),
            d = a(20);
        b(b.S + b.F * a(9)(function() {
          Reflect.defineProperty(c.setDesc({}, 1, {value: 1}), 1, {value: 2});
        }), "Reflect", {defineProperty: function defineProperty(a, b, e) {
            d(a);
            try {
              return c.setDesc(a, b, e), !0;
            } catch (f) {
              return !1;
            }
          }});
      }, function(e, f, a) {
        var b = a(3),
            c = a(2).getDesc,
            d = a(20);
        b(b.S, "Reflect", {deleteProperty: function deleteProperty(a, b) {
            var e = c(d(a), b);
            return e && !e.configurable ? !1 : delete a[b];
          }});
      }, function(f, g, b) {
        var c = b(3),
            e = b(20),
            d = function(a) {
              this._t = e(a), this._i = 0;
              var b,
                  c = this._k = [];
              for (b in a)
                c.push(b);
            };
        b(110)(d, "Object", function() {
          var c,
              b = this,
              d = b._k;
          do
            if (b._i >= d.length)
              return {
                value: a,
                done: !0
              };
 while (!((c = d[b._i++]) in b._t));
          return {
            value: c,
            done: !1
          };
        }), c(c.S, "Reflect", {enumerate: function enumerate(a) {
            return new d(a);
          }});
      }, function(h, i, b) {
        function get(b, h) {
          var d,
              j,
              i = arguments.length < 3 ? b : arguments[2];
          return g(b) === i ? b[h] : (d = c.getDesc(b, h)) ? e(d, "value") ? d.value : d.get !== a ? d.get.call(i) : a : f(j = c.getProto(b)) ? get(j, h, i) : void 0;
        }
        var c = b(2),
            e = b(17),
            d = b(3),
            f = b(16),
            g = b(20);
        d(d.S, "Reflect", {get: get});
      }, function(e, f, a) {
        var c = a(2),
            b = a(3),
            d = a(20);
        b(b.S, "Reflect", {getOwnPropertyDescriptor: function getOwnPropertyDescriptor(a, b) {
            return c.getDesc(d(a), b);
          }});
      }, function(e, f, a) {
        var b = a(3),
            c = a(2).getProto,
            d = a(20);
        b(b.S, "Reflect", {getPrototypeOf: function getPrototypeOf(a) {
            return c(d(a));
          }});
      }, function(c, d, b) {
        var a = b(3);
        a(a.S, "Reflect", {has: function has(a, b) {
            return b in a;
          }});
      }, function(e, f, a) {
        var b = a(3),
            d = a(20),
            c = Object.isExtensible;
        b(b.S, "Reflect", {isExtensible: function isExtensible(a) {
            return d(a), c ? c(a) : !0;
          }});
      }, function(c, d, a) {
        var b = a(3);
        b(b.S, "Reflect", {ownKeys: a(161)});
      }, function(d, f, a) {
        var b = a(2),
            e = a(20),
            c = a(4).Reflect;
        d.exports = c && c.ownKeys || function ownKeys(a) {
          var c = b.getNames(e(a)),
              d = b.getSymbols;
          return d ? c.concat(d(a)) : c;
        };
      }, function(e, f, a) {
        var b = a(3),
            d = a(20),
            c = Object.preventExtensions;
        b(b.S, "Reflect", {preventExtensions: function preventExtensions(a) {
            d(a);
            try {
              return c && c(a), !0;
            } catch (b) {
              return !1;
            }
          }});
      }, function(i, j, b) {
        function set(j, i, k) {
          var l,
              m,
              d = arguments.length < 4 ? j : arguments[3],
              b = c.getDesc(h(j), i);
          if (!b) {
            if (f(m = c.getProto(j)))
              return set(m, i, k, d);
            b = e(0);
          }
          return g(b, "value") ? b.writable !== !1 && f(d) ? (l = c.getDesc(d, i) || e(0), l.value = k, c.setDesc(d, i, l), !0) : !1 : b.set === a ? !1 : (b.set.call(d, k), !0);
        }
        var c = b(2),
            g = b(17),
            d = b(3),
            e = b(7),
            h = b(20),
            f = b(16);
        d(d.S, "Reflect", {set: set});
      }, function(d, e, b) {
        var c = b(3),
            a = b(45);
        a && c(c.S, "Reflect", {setPrototypeOf: function setPrototypeOf(b, c) {
            a.check(b, c);
            try {
              return a.set(b, c), !0;
            } catch (d) {
              return !1;
            }
          }});
      }, function(e, f, b) {
        var c = b(3),
            d = b(33)(!0);
        c(c.P, "Array", {includes: function includes(b) {
            return d(this, b, arguments.length > 1 ? arguments[1] : a);
          }}), b(118)("includes");
      }, function(d, e, a) {
        var b = a(3),
            c = a(98)(!0);
        b(b.P, "String", {at: function at(a) {
            return c(this, a);
          }});
      }, function(e, f, b) {
        var c = b(3),
            d = b(168);
        c(c.P, "String", {padLeft: function padLeft(b) {
            return d(this, b, arguments.length > 1 ? arguments[1] : a, !0);
          }});
      }, function(c, g, b) {
        var d = b(27),
            e = b(105),
            f = b(22);
        c.exports = function(l, m, i, n) {
          var c = String(f(l)),
              j = c.length,
              g = i === a ? " " : String(i),
              k = d(m);
          if (j >= k)
            return c;
          "" == g && (g = " ");
          var h = k - j,
              b = e.call(g, Math.ceil(h / g.length));
          return b.length > h && (b = b.slice(0, h)), n ? b + c : c + b;
        };
      }, function(e, f, b) {
        var c = b(3),
            d = b(168);
        c(c.P, "String", {padRight: function padRight(b) {
            return d(this, b, arguments.length > 1 ? arguments[1] : a, !1);
          }});
      }, function(b, c, a) {
        a(63)("trimLeft", function(a) {
          return function trimLeft() {
            return a(this, 1);
          };
        });
      }, function(b, c, a) {
        a(63)("trimRight", function(a) {
          return function trimRight() {
            return a(this, 2);
          };
        });
      }, function(d, e, a) {
        var b = a(3),
            c = a(173)(/[\\^$*+?.()|[\]{}]/g, "\\$&");
        b(b.S, "RegExp", {escape: function escape(a) {
            return c(a);
          }});
      }, function(a, b) {
        a.exports = function(b, a) {
          var c = a === Object(a) ? function(b) {
            return a[b];
          } : a;
          return function(a) {
            return String(a).replace(b, c);
          };
        };
      }, function(g, h, a) {
        var b = a(2),
            c = a(3),
            d = a(161),
            e = a(23),
            f = a(7);
        c(c.S, "Object", {getOwnPropertyDescriptors: function getOwnPropertyDescriptors(k) {
            for (var a,
                g,
                h = e(k),
                l = b.setDesc,
                m = b.getDesc,
                i = d(h),
                c = {},
                j = 0; i.length > j; )
              g = m(h, a = i[j++]), a in c ? l(c, a, f(0, g)) : c[a] = g;
            return c;
          }});
      }, function(d, e, a) {
        var b = a(3),
            c = a(176)(!1);
        b(b.S, "Object", {values: function values(a) {
            return c(a);
          }});
      }, function(c, f, a) {
        var b = a(2),
            d = a(23),
            e = b.isEnum;
        c.exports = function(a) {
          return function(j) {
            for (var c,
                f = d(j),
                g = b.getKeys(f),
                k = g.length,
                h = 0,
                i = []; k > h; )
              e.call(f, c = g[h++]) && i.push(a ? [c, f[c]] : f[c]);
            return i;
          };
        };
      }, function(d, e, a) {
        var b = a(3),
            c = a(176)(!0);
        b(b.S, "Object", {entries: function entries(a) {
            return c(a);
          }});
      }, function(c, d, a) {
        var b = a(3);
        b(b.P, "Map", {toJSON: a(179)("Map")});
      }, function(b, e, a) {
        var c = a(138),
            d = a(47);
        b.exports = function(a) {
          return function toJSON() {
            if (d(this) != a)
              throw TypeError(a + "#toJSON isn't generic");
            var b = [];
            return c(this, !1, b.push, b), b;
          };
        };
      }, function(c, d, a) {
        var b = a(3);
        b(b.P, "Set", {toJSON: a(179)("Set")});
      }, function(d, e, b) {
        var a = b(3),
            c = b(141);
        a(a.G + a.B, {
          setImmediate: c.set,
          clearImmediate: c.clear
        });
      }, function(l, k, a) {
        a(117);
        var g = a(4),
            j = a(6),
            c = a(109),
            b = a(31)("iterator"),
            h = g.NodeList,
            i = g.HTMLCollection,
            e = h && h.prototype,
            d = i && i.prototype,
            f = c.NodeList = c.HTMLCollection = c.Array;
        e && !e[b] && j(e, b, f), d && !d[b] && j(d, b, f);
      }, function(i, j, a) {
        var c = a(4),
            b = a(3),
            g = a(19),
            h = a(184),
            d = c.navigator,
            e = !!d && /MSIE .\./.test(d.userAgent),
            f = function(a) {
              return e ? function(b, c) {
                return a(g(h, [].slice.call(arguments, 2), "function" == typeof b ? b : Function(b)), c);
              } : a;
            };
        b(b.G + b.B + b.F * e, {
          setTimeout: f(c.setTimeout),
          setInterval: f(c.setInterval)
        });
      }, function(c, f, a) {
        var d = a(185),
            b = a(19),
            e = a(13);
        c.exports = function() {
          for (var h = e(this),
              a = arguments.length,
              c = Array(a),
              f = 0,
              i = d._,
              g = !1; a > f; )
            (c[f] = arguments[f++]) === i && (g = !0);
          return function() {
            var d,
                k = this,
                f = arguments,
                l = f.length,
                e = 0,
                j = 0;
            if (!g && !l)
              return b(h, c, k);
            if (d = c.slice(), g)
              for (; a > e; e++)
                d[e] === i && (d[e] = f[j++]);
            for (; l > j; )
              d.push(f[j++]);
            return b(h, d, k);
          };
        };
      }, function(a, c, b) {
        a.exports = b(4);
      }, function(i, j, b) {
        var g = b(2),
            e = b(3),
            h = b(12),
            f = b(5).Array || Array,
            c = {},
            d = function(d, b) {
              g.each.call(d.split(","), function(d) {
                b == a && d in f ? c[d] = f[d] : d in [] && (c[d] = h(Function.call, [][d], b));
              });
            };
        d("pop,reverse,shift,keys,values,entries", 1), d("indexOf,every,some,forEach,map,filter,find,findIndex,includes", 3), d("join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill"), e(e.S, "Array", c);
      }]), "undefined" != typeof module && module.exports ? module.exports = b : "function" == typeof define && define.amd ? define(function() {
        return b;
      }) : c.core = b;
    }(1, 1);
  })(require("github:jspm/nodelibs-process@0.1.2"));
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:core-js@1.2.6", ["npm:core-js@1.2.6/client/shim.min"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:core-js@1.2.6/client/shim.min");
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-pal@1.0.0-beta.1.0.2/aurelia-pal", ["exports"], function(exports) {
  'use strict';
  exports.__esModule = true;
  exports.AggregateError = AggregateError;
  exports.initializePAL = initializePAL;
  function AggregateError(message, innerError, skipIfAlreadyAggregate) {
    if (innerError) {
      if (innerError.innerError && skipIfAlreadyAggregate) {
        return innerError;
      }
      if (innerError.stack) {
        message += '\n------------------------------------------------\ninner error: ' + innerError.stack;
      }
    }
    var e = new Error(message);
    if (innerError) {
      e.innerError = innerError;
    }
    return e;
  }
  var FEATURE = {};
  exports.FEATURE = FEATURE;
  var PLATFORM = {
    noop: function noop() {},
    eachModule: function eachModule() {}
  };
  exports.PLATFORM = PLATFORM;
  PLATFORM.global = (function() {
    if (typeof self !== 'undefined') {
      return self;
    }
    if (typeof global !== 'undefined') {
      return global;
    }
    return new Function('return this')();
  })();
  var DOM = {};
  exports.DOM = DOM;
  function initializePAL(callback) {
    if (typeof Object.getPropertyDescriptor !== 'function') {
      Object.getPropertyDescriptor = function(subject, name) {
        var pd = Object.getOwnPropertyDescriptor(subject, name);
        var proto = Object.getPrototypeOf(subject);
        while (typeof pd === 'undefined' && proto !== null) {
          pd = Object.getOwnPropertyDescriptor(proto, name);
          proto = Object.getPrototypeOf(proto);
        }
        return pd;
      };
    }
    callback(PLATFORM, FEATURE, DOM);
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-pal@1.0.0-beta.1.0.2", ["npm:aurelia-pal@1.0.0-beta.1.0.2/aurelia-pal"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-pal-browser@1.0.0-beta.1.0.3/aurelia-pal-browser", ["exports", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  exports._ensureFunctionName = _ensureFunctionName;
  exports._ensureClassList = _ensureClassList;
  exports._ensurePerformance = _ensurePerformance;
  exports._ensureCustomEvent = _ensureCustomEvent;
  exports._ensureElementMatches = _ensureElementMatches;
  exports._ensureHTMLTemplateElement = _ensureHTMLTemplateElement;
  exports.initialize = initialize;
  function _ensureFunctionName() {
    function test() {}
    if (!test.name) {
      Object.defineProperty(Function.prototype, 'name', {get: function get() {
          var name = this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1];
          Object.defineProperty(this, 'name', {value: name});
          return name;
        }});
    }
  }
  function _ensureClassList() {
    if (!('classList' in document.createElement('_')) || document.createElementNS && !('classList' in document.createElementNS('http://www.w3.org/2000/svg', 'g'))) {
      (function() {
        var protoProp = 'prototype';
        var strTrim = String.prototype.trim;
        var arrIndexOf = Array.prototype.indexOf;
        var emptyArray = [];
        var DOMEx = function DOMEx(type, message) {
          this.name = type;
          this.code = DOMException[type];
          this.message = message;
        };
        var checkTokenAndGetIndex = function checkTokenAndGetIndex(classList, token) {
          if (token === '') {
            throw new DOMEx('SYNTAX_ERR', 'An invalid or illegal string was specified');
          }
          if (/\s/.test(token)) {
            throw new DOMEx('INVALID_CHARACTER_ERR', 'String contains an invalid character');
          }
          return arrIndexOf.call(classList, token);
        };
        var ClassList = function ClassList(elem) {
          var trimmedClasses = strTrim.call(elem.getAttribute('class') || '');
          var classes = trimmedClasses ? trimmedClasses.split(/\s+/) : emptyArray;
          for (var i = 0,
              ii = classes.length; i < ii; ++i) {
            this.push(classes[i]);
          }
          this._updateClassName = function() {
            elem.setAttribute('class', this.toString());
          };
        };
        var classListProto = ClassList[protoProp] = [];
        DOMEx[protoProp] = Error[protoProp];
        classListProto.item = function(i) {
          return this[i] || null;
        };
        classListProto.contains = function(token) {
          token += '';
          return checkTokenAndGetIndex(this, token) !== -1;
        };
        classListProto.add = function() {
          var tokens = arguments;
          var i = 0;
          var ii = tokens.length;
          var token = undefined;
          var updated = false;
          do {
            token = tokens[i] + '';
            if (checkTokenAndGetIndex(this, token) === -1) {
              this.push(token);
              updated = true;
            }
          } while (++i < ii);
          if (updated) {
            this._updateClassName();
          }
        };
        classListProto.remove = function() {
          var tokens = arguments;
          var i = 0;
          var ii = tokens.length;
          var token = undefined;
          var updated = false;
          var index = undefined;
          do {
            token = tokens[i] + '';
            index = checkTokenAndGetIndex(this, token);
            while (index !== -1) {
              this.splice(index, 1);
              updated = true;
              index = checkTokenAndGetIndex(this, token);
            }
          } while (++i < ii);
          if (updated) {
            this._updateClassName();
          }
        };
        classListProto.toggle = function(token, force) {
          token += '';
          var result = this.contains(token);
          var method = result ? force !== true && 'remove' : force !== false && 'add';
          if (method) {
            this[method](token);
          }
          if (force === true || force === false) {
            return force;
          }
          return !result;
        };
        classListProto.toString = function() {
          return this.join(' ');
        };
        Object.defineProperty(Element.prototype, 'classList', {
          get: function get() {
            return new ClassList(this);
          },
          enumerable: true,
          configurable: true
        });
      })();
    } else {
      var testElement = document.createElement('_');
      testElement.classList.add('c1', 'c2');
      if (!testElement.classList.contains('c2')) {
        var createMethod = function createMethod(method) {
          var original = DOMTokenList.prototype[method];
          DOMTokenList.prototype[method] = function(token) {
            for (var i = 0,
                ii = arguments.length; i < ii; ++i) {
              token = arguments[i];
              original.call(this, token);
            }
          };
        };
        createMethod('add');
        createMethod('remove');
      }
      testElement.classList.toggle('c3', false);
      if (testElement.classList.contains('c3')) {
        (function() {
          var _toggle = DOMTokenList.prototype.toggle;
          DOMTokenList.prototype.toggle = function(token, force) {
            if (1 in arguments && !this.contains(token) === !force) {
              return force;
            }
            return _toggle.call(this, token);
          };
        })();
      }
      testElement = null;
    }
  }
  function _ensurePerformance() {
    if ('performance' in window === false) {
      window.performance = {};
    }
    Date.now = Date.now || function() {
      return new Date().getTime();
    };
    if ('now' in window.performance === false) {
      (function() {
        var nowOffset = Date.now();
        if (performance.timing && performance.timing.navigationStart) {
          nowOffset = performance.timing.navigationStart;
        }
        window.performance.now = function now() {
          return Date.now() - nowOffset;
        };
      })();
    }
  }
  function _ensureCustomEvent() {
    if (!window.CustomEvent || typeof window.CustomEvent !== 'function') {
      var _CustomEvent = function _CustomEvent(event, params) {
        params = params || {
          bubbles: false,
          cancelable: false,
          detail: undefined
        };
        var evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
      };
      _CustomEvent.prototype = window.Event.prototype;
      window.CustomEvent = _CustomEvent;
    }
  }
  function _ensureElementMatches() {
    if (Element && !Element.prototype.matches) {
      var proto = Element.prototype;
      proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
    }
  }
  var _FEATURE = {};
  exports._FEATURE = _FEATURE;
  _FEATURE.shadowDOM = (function() {
    return !!HTMLElement.prototype.createShadowRoot;
  })();
  _FEATURE.scopedCSS = (function() {
    return 'scoped' in document.createElement('style');
  })();
  _FEATURE.htmlTemplateElement = (function() {
    return 'content' in document.createElement('template');
  })();
  function _ensureHTMLTemplateElement() {
    function isSVGTemplate(el) {
      return el.tagName === 'template' && el.namespaceURI === 'http://www.w3.org/2000/svg';
    }
    function fixSVGTemplateElement(el) {
      var template = el.ownerDocument.createElement('template');
      var attrs = el.attributes;
      var length = attrs.length;
      var attr = undefined;
      el.parentNode.insertBefore(template, el);
      while (length-- > 0) {
        attr = attrs[length];
        template.setAttribute(attr.name, attr.value);
        el.removeAttribute(attr.name);
      }
      el.parentNode.removeChild(el);
      return fixHTMLTemplateElement(template);
    }
    function fixHTMLTemplateElement(template) {
      var content = template.content = document.createDocumentFragment();
      var child = undefined;
      while (child = template.firstChild) {
        content.appendChild(child);
      }
      return template;
    }
    function fixHTMLTemplateElementRoot(template) {
      var content = fixHTMLTemplateElement(template).content;
      var childTemplates = content.querySelectorAll('template');
      for (var i = 0,
          ii = childTemplates.length; i < ii; ++i) {
        var child = childTemplates[i];
        if (isSVGTemplate(child)) {
          fixSVGTemplateElement(child);
        } else {
          fixHTMLTemplateElement(child);
        }
      }
      return template;
    }
    if (_FEATURE.htmlTemplateElement) {
      _FEATURE.ensureHTMLTemplateElement = function(template) {
        return template;
      };
    } else {
      _FEATURE.ensureHTMLTemplateElement = fixHTMLTemplateElementRoot;
    }
  }
  var shadowPoly = window.ShadowDOMPolyfill || null;
  var _DOM = {
    Element: Element,
    SVGElement: SVGElement,
    boundary: 'aurelia-dom-boundary',
    addEventListener: function addEventListener(eventName, callback, capture) {
      document.addEventListener(eventName, callback, capture);
    },
    removeEventListener: function removeEventListener(eventName, callback, capture) {
      document.removeEventListener(eventName, callback, capture);
    },
    adoptNode: function adoptNode(node) {
      return document.adoptNode(node, true);
    },
    createElement: function createElement(tagName) {
      return document.createElement(tagName);
    },
    createTextNode: function createTextNode(text) {
      return document.createTextNode(text);
    },
    createComment: function createComment(text) {
      return document.createComment(text);
    },
    createDocumentFragment: function createDocumentFragment() {
      return document.createDocumentFragment();
    },
    createMutationObserver: function createMutationObserver(callback) {
      return new (window.MutationObserver || window.WebKitMutationObserver)(callback);
    },
    createCustomEvent: function createCustomEvent(eventType, options) {
      return new window.CustomEvent(eventType, options);
    },
    dispatchEvent: function dispatchEvent(evt) {
      document.dispatchEvent(evt);
    },
    getComputedStyle: function getComputedStyle(element) {
      return window.getComputedStyle(element);
    },
    getElementById: function getElementById(id) {
      return document.getElementById(id);
    },
    querySelectorAll: function querySelectorAll(query) {
      return document.querySelectorAll(query);
    },
    nextElementSibling: function nextElementSibling(element) {
      if (element.nextElementSibling) {
        return element.nextElementSibling;
      }
      do {
        element = element.nextSibling;
      } while (element && element.nodeType !== 1);
      return element;
    },
    createTemplateFromMarkup: function createTemplateFromMarkup(markup) {
      var parser = document.createElement('div');
      parser.innerHTML = markup;
      var temp = parser.firstElementChild;
      if (!temp || temp.nodeName !== 'TEMPLATE') {
        throw new Error('Template markup must be wrapped in a <template> element e.g. <template> <!-- markup here --> </template>');
      }
      return _FEATURE.ensureHTMLTemplateElement(temp);
    },
    appendNode: function appendNode(newNode, parentNode) {
      (parentNode || document.body).appendChild(newNode);
    },
    replaceNode: function replaceNode(newNode, node, parentNode) {
      if (node.parentNode) {
        node.parentNode.replaceChild(newNode, node);
      } else if (shadowPoly !== null) {
        shadowPoly.unwrap(parentNode).replaceChild(shadowPoly.unwrap(newNode), shadowPoly.unwrap(node));
      } else {
        parentNode.replaceChild(newNode, node);
      }
    },
    removeNode: function removeNode(node, parentNode) {
      if (node.parentNode) {
        node.parentNode.removeChild(node);
      } else if (shadowPoly !== null) {
        shadowPoly.unwrap(parentNode).removeChild(shadowPoly.unwrap(node));
      } else {
        parentNode.removeChild(node);
      }
    },
    injectStyles: function injectStyles(styles, destination, prepend) {
      var node = document.createElement('style');
      node.innerHTML = styles;
      node.type = 'text/css';
      destination = destination || document.head;
      if (prepend && destination.childNodes.length > 0) {
        destination.insertBefore(node, destination.childNodes[0]);
      } else {
        destination.appendChild(node);
      }
      return node;
    }
  };
  exports._DOM = _DOM;
  var _PLATFORM = {
    location: window.location,
    history: window.history,
    addEventListener: function addEventListener(eventName, callback, capture) {
      this.global.addEventListener(eventName, callback, capture);
    },
    removeEventListener: function removeEventListener(eventName, callback, capture) {
      this.global.removeEventListener(eventName, callback, capture);
    },
    performance: window.performance,
    requestAnimationFrame: function requestAnimationFrame(callback) {
      return this.global.requestAnimationFrame(callback);
    }
  };
  exports._PLATFORM = _PLATFORM;
  var isInitialized = false;
  function initialize() {
    if (isInitialized) {
      return;
    }
    isInitialized = true;
    _ensureCustomEvent();
    _ensureFunctionName();
    _ensureHTMLTemplateElement();
    _ensureElementMatches();
    _ensureClassList();
    _ensurePerformance();
    _aureliaPal.initializePAL(function(platform, feature, dom) {
      Object.assign(platform, _PLATFORM);
      Object.assign(feature, _FEATURE);
      Object.assign(dom, _DOM);
      Object.defineProperty(dom, 'title', {
        get: function get() {
          return document.title;
        },
        set: function set(value) {
          document.title = value;
        }
      });
      Object.defineProperty(dom, 'activeElement', {get: function get() {
          return document.activeElement;
        }});
      Object.defineProperty(platform, 'XMLHttpRequest', {get: function get() {
          return platform.global.XMLHttpRequest;
        }});
    });
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-pal-browser@1.0.0-beta.1.0.3", ["npm:aurelia-pal-browser@1.0.0-beta.1.0.3/aurelia-pal-browser"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-bootstrapper@1.0.0-beta.1.0.2/aurelia-bootstrapper", ["exports", "npm:core-js@1.2.6", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-pal-browser@1.0.0-beta.1.0.3"], function(exports, _coreJs, _aureliaPal, _aureliaPalBrowser) {
  'use strict';
  exports.__esModule = true;
  exports.bootstrap = bootstrap;
  var bootstrapQueue = [];
  var sharedLoader = null;
  var Aurelia = null;
  function onBootstrap(callback) {
    return new Promise(function(resolve, reject) {
      if (sharedLoader) {
        resolve(callback(sharedLoader));
      } else {
        bootstrapQueue.push(function() {
          try {
            resolve(callback(sharedLoader));
          } catch (e) {
            reject(e);
          }
        });
      }
    });
  }
  function ready(global) {
    return new Promise(function(resolve, reject) {
      if (global.document.readyState === 'complete') {
        resolve(global.document);
      } else {
        global.document.addEventListener('DOMContentLoaded', completed, false);
        global.addEventListener('load', completed, false);
      }
      function completed() {
        global.document.removeEventListener('DOMContentLoaded', completed, false);
        global.removeEventListener('load', completed, false);
        resolve(global.document);
      }
    });
  }
  function createLoader() {
    if (_aureliaPal.PLATFORM.Loader) {
      return Promise.resolve(new _aureliaPal.PLATFORM.Loader());
    }
    if (window.require) {
      return new Promise(function(resolve, reject) {
        return require(['aurelia-loader-default'], function(m) {
          return resolve(new m.DefaultLoader());
        }, reject);
      });
    } else if (window.System) {
      return System.normalize('aurelia-bootstrapper').then(function(bootstrapperName) {
        return System.normalize('aurelia-loader-default', bootstrapperName);
      }).then(function(loaderName) {
        return System['import'](loaderName).then(function(m) {
          return new m.DefaultLoader();
        });
      });
    }
    return Promise.reject('No PLATFORM.Loader is defined and there is neither a System API (ES6) or a Require API (AMD) globally available to load your app.');
  }
  function preparePlatform(loader) {
    return loader.normalize('aurelia-bootstrapper').then(function(bootstrapperName) {
      return loader.normalize('aurelia-framework', bootstrapperName).then(function(frameworkName) {
        loader.map('aurelia-framework', frameworkName);
        return Promise.all([loader.normalize('aurelia-dependency-injection', frameworkName).then(function(diName) {
          return loader.map('aurelia-dependency-injection', diName);
        }), loader.normalize('aurelia-router', bootstrapperName).then(function(routerName) {
          return loader.map('aurelia-router', routerName);
        }), loader.normalize('aurelia-logging-console', bootstrapperName).then(function(loggingConsoleName) {
          return loader.map('aurelia-logging-console', loggingConsoleName);
        })]).then(function() {
          return loader.loadModule(frameworkName).then(function(m) {
            return Aurelia = m.Aurelia;
          });
        });
      });
    });
  }
  function handleApp(loader, appHost) {
    var configModuleId = appHost.getAttribute('aurelia-app');
    return configModuleId ? customConfig(loader, appHost, configModuleId) : defaultConfig(loader, appHost);
  }
  function customConfig(loader, appHost, configModuleId) {
    return loader.loadModule(configModuleId).then(function(m) {
      var aurelia = new Aurelia(loader);
      aurelia.host = appHost;
      return m.configure(aurelia);
    });
  }
  function defaultConfig(loader, appHost) {
    var aurelia = new Aurelia(loader);
    aurelia.host = appHost;
    if (window.location.protocol !== 'http' && window.location.protocol !== 'https') {
      aurelia.use.developmentLogging();
    }
    aurelia.use.standardConfiguration();
    return aurelia.start().then(function(a) {
      return a.setRoot();
    });
  }
  function run() {
    return ready(window).then(function(doc) {
      _aureliaPalBrowser.initialize();
      var appHost = doc.querySelectorAll('[aurelia-app]');
      return createLoader().then(function(loader) {
        return preparePlatform(loader).then(function() {
          for (var i = 0,
              ii = appHost.length; i < ii; ++i) {
            handleApp(loader, appHost[i])['catch'](console.error.bind(console));
          }
          sharedLoader = loader;
          for (var i = 0,
              ii = bootstrapQueue.length; i < ii; ++i) {
            bootstrapQueue[i]();
          }
          bootstrapQueue = null;
        });
      });
    });
  }
  function bootstrap(configure) {
    return onBootstrap(function(loader) {
      var aurelia = new Aurelia(loader);
      return configure(aurelia);
    });
  }
  run();
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-bootstrapper@1.0.0-beta.1.0.2", ["npm:aurelia-bootstrapper@1.0.0-beta.1.0.2/aurelia-bootstrapper"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-history@1.0.0-beta.1/aurelia-history", ["exports"], function(exports) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var History = (function() {
    function History() {
      _classCallCheck(this, History);
    }
    History.prototype.activate = function activate(options) {
      throw new Error('History must implement activate().');
    };
    History.prototype.deactivate = function deactivate() {
      throw new Error('History must implement deactivate().');
    };
    History.prototype.navigate = function navigate(fragment, options) {
      throw new Error('History must implement navigate().');
    };
    History.prototype.navigateBack = function navigateBack() {
      throw new Error('History must implement navigateBack().');
    };
    History.prototype.setTitle = function setTitle(title) {
      throw new Error('History must implement setTitle().');
    };
    return History;
  })();
  exports.History = History;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-history@1.0.0-beta.1", ["npm:aurelia-history@1.0.0-beta.1/aurelia-history"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-history-browser@1.0.0-beta.1.0.1/aurelia-history-browser", ["exports", "npm:core-js@1.2.6", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-history@1.0.0-beta.1"], function(exports, _coreJs, _aureliaPal, _aureliaHistory) {
  'use strict';
  exports.__esModule = true;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.configure = configure;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var LinkHandler = (function() {
    function LinkHandler() {
      _classCallCheck(this, LinkHandler);
    }
    LinkHandler.prototype.activate = function activate(history) {};
    LinkHandler.prototype.deactivate = function deactivate() {};
    return LinkHandler;
  })();
  exports.LinkHandler = LinkHandler;
  var DefaultLinkHandler = (function(_LinkHandler) {
    _inherits(DefaultLinkHandler, _LinkHandler);
    function DefaultLinkHandler() {
      var _this = this;
      _classCallCheck(this, DefaultLinkHandler);
      _LinkHandler.call(this);
      this.handler = function(e) {
        var _DefaultLinkHandler$getEventInfo = DefaultLinkHandler.getEventInfo(e);
        var shouldHandleEvent = _DefaultLinkHandler$getEventInfo.shouldHandleEvent;
        var href = _DefaultLinkHandler$getEventInfo.href;
        if (shouldHandleEvent) {
          e.preventDefault();
          _this.history.navigate(href);
        }
      };
    }
    DefaultLinkHandler.prototype.activate = function activate(history) {
      if (history._hasPushState) {
        this.history = history;
        _aureliaPal.DOM.addEventListener('click', this.handler, true);
      }
    };
    DefaultLinkHandler.prototype.deactivate = function deactivate() {
      _aureliaPal.DOM.removeEventListener('click', this.handler);
    };
    DefaultLinkHandler.getEventInfo = function getEventInfo(event) {
      var info = {
        shouldHandleEvent: false,
        href: null,
        anchor: null
      };
      var target = DefaultLinkHandler.findClosestAnchor(event.target);
      if (!target || !DefaultLinkHandler.targetIsThisWindow(target)) {
        return info;
      }
      if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) {
        return info;
      }
      var href = target.getAttribute('href');
      info.anchor = target;
      info.href = href;
      var leftButtonClicked = event.which === 1;
      var isRelative = href && !(href.charAt(0) === '#' || /^[a-z]+:/i.test(href));
      info.shouldHandleEvent = leftButtonClicked && isRelative;
      return info;
    };
    DefaultLinkHandler.findClosestAnchor = function findClosestAnchor(el) {
      while (el) {
        if (el.tagName === 'A') {
          return el;
        }
        el = el.parentNode;
      }
    };
    DefaultLinkHandler.targetIsThisWindow = function targetIsThisWindow(target) {
      var targetWindow = target.getAttribute('target');
      var win = _aureliaPal.PLATFORM.global;
      return !targetWindow || targetWindow === win.name || targetWindow === '_self' || targetWindow === 'top' && win === win.top;
    };
    return DefaultLinkHandler;
  })(LinkHandler);
  exports.DefaultLinkHandler = DefaultLinkHandler;
  function configure(config) {
    config.singleton(_aureliaHistory.History, BrowserHistory);
    config.transient(LinkHandler, DefaultLinkHandler);
  }
  var BrowserHistory = (function(_History) {
    _inherits(BrowserHistory, _History);
    _createClass(BrowserHistory, null, [{
      key: 'inject',
      value: [LinkHandler],
      enumerable: true
    }]);
    function BrowserHistory(linkHandler) {
      _classCallCheck(this, BrowserHistory);
      _History.call(this);
      this._isActive = false;
      this._checkUrlCallback = this._checkUrl.bind(this);
      this.location = _aureliaPal.PLATFORM.location;
      this.history = _aureliaPal.PLATFORM.history;
      this.linkHandler = linkHandler;
    }
    BrowserHistory.prototype.activate = function activate(options) {
      if (this._isActive) {
        throw new Error('History has already been activated.');
      }
      var wantsPushState = !!options.pushState;
      this._isActive = true;
      this.options = Object.assign({}, {root: '/'}, this.options, options);
      this.root = ('/' + this.options.root + '/').replace(rootStripper, '/');
      this._wantsHashChange = this.options.hashChange !== false;
      this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
      var eventName = undefined;
      if (this._hasPushState) {
        eventName = 'popstate';
      } else if (this._wantsHashChange) {
        eventName = 'hashchange';
      }
      _aureliaPal.PLATFORM.addEventListener(eventName, this._checkUrlCallback);
      if (this._wantsHashChange && wantsPushState) {
        var loc = this.location;
        var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;
        if (!this._hasPushState && !atRoot) {
          this.fragment = this._getFragment(null, true);
          this.location.replace(this.root + this.location.search + '#' + this.fragment);
          return true;
        } else if (this._hasPushState && atRoot && loc.hash) {
          this.fragment = this._getHash().replace(routeStripper, '');
          this.history.replaceState({}, _aureliaPal.DOM.title, this.root + this.fragment + loc.search);
        }
      }
      if (!this.fragment) {
        this.fragment = this._getFragment();
      }
      this.linkHandler.activate(this);
      if (!this.options.silent) {
        return this._loadUrl();
      }
    };
    BrowserHistory.prototype.deactivate = function deactivate() {
      _aureliaPal.PLATFORM.removeEventListener('popstate', this._checkUrlCallback);
      _aureliaPal.PLATFORM.removeEventListener('hashchange', this._checkUrlCallback);
      this._isActive = false;
      this.linkHandler.deactivate();
    };
    BrowserHistory.prototype.navigate = function navigate(fragment) {
      var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var _ref$trigger = _ref.trigger;
      var trigger = _ref$trigger === undefined ? true : _ref$trigger;
      var _ref$replace = _ref.replace;
      var replace = _ref$replace === undefined ? false : _ref$replace;
      if (fragment && absoluteUrl.test(fragment)) {
        this.location.href = fragment;
        return true;
      }
      if (!this._isActive) {
        return false;
      }
      fragment = this._getFragment(fragment || '');
      if (this.fragment === fragment && !replace) {
        return false;
      }
      this.fragment = fragment;
      var url = this.root + fragment;
      if (fragment === '' && url !== '/') {
        url = url.slice(0, -1);
      }
      if (this._hasPushState) {
        url = url.replace('//', '/');
        this.history[replace ? 'replaceState' : 'pushState']({}, _aureliaPal.DOM.title, url);
      } else if (this._wantsHashChange) {
        updateHash(this.location, fragment, replace);
      } else {
        return this.location.assign(url);
      }
      if (trigger) {
        return this._loadUrl(fragment);
      }
    };
    BrowserHistory.prototype.navigateBack = function navigateBack() {
      this.history.back();
    };
    BrowserHistory.prototype.setTitle = function setTitle(title) {
      _aureliaPal.DOM.title = title;
    };
    BrowserHistory.prototype._getHash = function _getHash() {
      return this.location.hash.substr(1);
    };
    BrowserHistory.prototype._getFragment = function _getFragment(fragment, forcePushState) {
      var root = undefined;
      if (!fragment) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname + this.location.search;
          root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) {
            fragment = fragment.substr(root.length);
          }
        } else {
          fragment = this._getHash();
        }
      }
      return '/' + fragment.replace(routeStripper, '');
    };
    BrowserHistory.prototype._checkUrl = function _checkUrl() {
      var current = this._getFragment();
      if (current !== this.fragment) {
        this._loadUrl();
      }
    };
    BrowserHistory.prototype._loadUrl = function _loadUrl(fragmentOverride) {
      var fragment = this.fragment = this._getFragment(fragmentOverride);
      return this.options.routeHandler ? this.options.routeHandler(fragment) : false;
    };
    return BrowserHistory;
  })(_aureliaHistory.History);
  exports.BrowserHistory = BrowserHistory;
  var routeStripper = /^#?\/*|\s+$/g;
  var rootStripper = /^\/+|\/+$/g;
  var trailingSlash = /\/$/;
  var absoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;
  function updateHash(location, fragment, replace) {
    if (replace) {
      var href = location.href.replace(/(javascript:|#).*$/, '');
      location.replace(href + '#' + fragment);
    } else {
      location.hash = '#' + fragment;
    }
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-history-browser@1.0.0-beta.1.0.1", ["npm:aurelia-history-browser@1.0.0-beta.1.0.1/aurelia-history-browser"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-path@1.0.0-beta.1/aurelia-path", ["exports"], function(exports) {
  'use strict';
  exports.__esModule = true;
  exports.relativeToFile = relativeToFile;
  exports.join = join;
  exports.buildQueryString = buildQueryString;
  exports.parseQueryString = parseQueryString;
  function trimDots(ary) {
    for (var i = 0; i < ary.length; ++i) {
      var part = ary[i];
      if (part === '.') {
        ary.splice(i, 1);
        i -= 1;
      } else if (part === '..') {
        if (i === 0 || i === 1 && ary[2] === '..' || ary[i - 1] === '..') {
          continue;
        } else if (i > 0) {
          ary.splice(i - 1, 2);
          i -= 2;
        }
      }
    }
  }
  function relativeToFile(name, file) {
    var fileParts = file && file.split('/');
    var nameParts = name.trim().split('/');
    if (nameParts[0].charAt(0) === '.' && fileParts) {
      var normalizedBaseParts = fileParts.slice(0, fileParts.length - 1);
      nameParts.unshift.apply(nameParts, normalizedBaseParts);
    }
    trimDots(nameParts);
    return nameParts.join('/');
  }
  function join(path1, path2) {
    if (!path1) {
      return path2;
    }
    if (!path2) {
      return path1;
    }
    var schemeMatch = path1.match(/^([^/]*?:)\//);
    var scheme = schemeMatch && schemeMatch.length > 0 ? schemeMatch[1] : '';
    path1 = path1.substr(scheme.length);
    var urlPrefix = undefined;
    if (path1.indexOf('///') === 0 && scheme === 'file:') {
      urlPrefix = '///';
    } else if (path1.indexOf('//') === 0) {
      urlPrefix = '//';
    } else if (path1.indexOf('/') === 0) {
      urlPrefix = '/';
    } else {
      urlPrefix = '';
    }
    var trailingSlash = path2.slice(-1) === '/' ? '/' : '';
    var url1 = path1.split('/');
    var url2 = path2.split('/');
    var url3 = [];
    for (var i = 0,
        ii = url1.length; i < ii; ++i) {
      if (url1[i] === '..') {
        url3.pop();
      } else if (url1[i] === '.' || url1[i] === '') {
        continue;
      } else {
        url3.push(url1[i]);
      }
    }
    for (var i = 0,
        ii = url2.length; i < ii; ++i) {
      if (url2[i] === '..') {
        url3.pop();
      } else if (url2[i] === '.' || url2[i] === '') {
        continue;
      } else {
        url3.push(url2[i]);
      }
    }
    return scheme + urlPrefix + url3.join('/') + trailingSlash;
  }
  function buildQueryString(params) {
    var pairs = [];
    var keys = Object.keys(params || {}).sort();
    var encode = encodeURIComponent;
    var encodeKey = function encodeKey(k) {
      return encode(k).replace('%24', '$');
    };
    for (var i = 0,
        len = keys.length; i < len; i++) {
      var key = keys[i];
      var value = params[key];
      if (value === null || value === undefined) {
        continue;
      }
      if (Array.isArray(value)) {
        var arrayKey = encodeKey(key) + '[]';
        for (var j = 0,
            l = value.length; j < l; j++) {
          pairs.push(arrayKey + '=' + encode(value[j]));
        }
      } else {
        pairs.push(encodeKey(key) + '=' + encode(value));
      }
    }
    if (pairs.length === 0) {
      return '';
    }
    return pairs.join('&');
  }
  function parseQueryString(queryString) {
    var queryParams = {};
    if (!queryString || typeof queryString !== 'string') {
      return queryParams;
    }
    var query = queryString;
    if (query.charAt(0) === '?') {
      query = query.substr(1);
    }
    var pairs = query.split('&');
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i].split('=');
      var key = decodeURIComponent(pair[0]);
      var keyLength = key.length;
      var isArray = false;
      var value = undefined;
      if (!key) {
        continue;
      } else if (pair.length === 1) {
        value = true;
      } else {
        if (keyLength > 2 && key.slice(keyLength - 2) === '[]') {
          isArray = true;
          key = key.slice(0, keyLength - 2);
          if (!queryParams[key]) {
            queryParams[key] = [];
          }
        }
        value = pair[1] ? decodeURIComponent(pair[1]) : '';
      }
      if (isArray) {
        queryParams[key].push(value);
      } else {
        queryParams[key] = value;
      }
    }
    return queryParams;
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-path@1.0.0-beta.1", ["npm:aurelia-path@1.0.0-beta.1/aurelia-path"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-metadata@1.0.0-beta.1/aurelia-metadata", ["exports", "npm:core-js@1.2.6", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _coreJs, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  var _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  exports.decorators = decorators;
  exports.deprecated = deprecated;
  exports.mixin = mixin;
  exports.protocol = protocol;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var theGlobal = _aureliaPal.PLATFORM.global;
  var emptyMetadata = Object.freeze({});
  var metadataContainerKey = '__metadata__';
  if (typeof theGlobal.Reflect === 'undefined') {
    theGlobal.Reflect = {};
  }
  if (typeof theGlobal.Reflect.getOwnMetadata === 'undefined') {
    Reflect.getOwnMetadata = function(metadataKey, target, targetKey) {
      return ((target[metadataContainerKey] || emptyMetadata)[targetKey] || emptyMetadata)[metadataKey];
    };
  }
  if (typeof theGlobal.Reflect.defineMetadata === 'undefined') {
    Reflect.defineMetadata = function(metadataKey, metadataValue, target, targetKey) {
      var metadataContainer = target.hasOwnProperty(metadataContainerKey) ? target[metadataContainerKey] : target[metadataContainerKey] = {};
      var targetContainer = metadataContainer[targetKey] || (metadataContainer[targetKey] = {});
      targetContainer[metadataKey] = metadataValue;
    };
  }
  if (typeof theGlobal.Reflect.metadata === 'undefined') {
    Reflect.metadata = function(metadataKey, metadataValue) {
      return function(target, targetKey) {
        Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
      };
    };
  }
  var metadata = {
    resource: 'aurelia:resource',
    paramTypes: 'design:paramtypes',
    properties: 'design:properties',
    get: function get(metadataKey, target, targetKey) {
      if (!target) {
        return undefined;
      }
      var result = metadata.getOwn(metadataKey, target, targetKey);
      return result === undefined ? metadata.get(metadataKey, Object.getPrototypeOf(target), targetKey) : result;
    },
    getOwn: function getOwn(metadataKey, target, targetKey) {
      if (!target) {
        return undefined;
      }
      return Reflect.getOwnMetadata(metadataKey, target, targetKey);
    },
    define: function define(metadataKey, metadataValue, target, targetKey) {
      Reflect.defineMetadata(metadataKey, metadataValue, target, targetKey);
    },
    getOrCreateOwn: function getOrCreateOwn(metadataKey, Type, target, targetKey) {
      var result = metadata.getOwn(metadataKey, target, targetKey);
      if (result === undefined) {
        result = new Type();
        Reflect.defineMetadata(metadataKey, result, target, targetKey);
      }
      return result;
    }
  };
  exports.metadata = metadata;
  var originStorage = new Map();
  var unknownOrigin = Object.freeze({
    moduleId: undefined,
    moduleMember: undefined
  });
  var Origin = (function() {
    function Origin(moduleId, moduleMember) {
      _classCallCheck(this, Origin);
      this.moduleId = moduleId;
      this.moduleMember = moduleMember;
    }
    Origin.get = function get(fn) {
      var origin = originStorage.get(fn);
      if (origin === undefined) {
        _aureliaPal.PLATFORM.eachModule(function(key, value) {
          for (var _name in value) {
            var exp = value[_name];
            if (exp === fn) {
              originStorage.set(fn, origin = new Origin(key, _name));
              return true;
            }
          }
          if (value === fn) {
            originStorage.set(fn, origin = new Origin(key, 'default'));
            return true;
          }
        });
      }
      return origin || unknownOrigin;
    };
    Origin.set = function set(fn, origin) {
      originStorage.set(fn, origin);
    };
    return Origin;
  })();
  exports.Origin = Origin;
  function decorators() {
    for (var _len = arguments.length,
        rest = Array(_len),
        _key = 0; _key < _len; _key++) {
      rest[_key] = arguments[_key];
    }
    var applicator = function applicator(target, key, descriptor) {
      var i = rest.length;
      if (key) {
        descriptor = descriptor || {
          value: target[key],
          writable: true,
          configurable: true,
          enumerable: true
        };
        while (i--) {
          descriptor = rest[i](target, key, descriptor) || descriptor;
        }
        Object.defineProperty(target, key, descriptor);
      } else {
        while (i--) {
          target = rest[i](target) || target;
        }
      }
      return target;
    };
    applicator.on = applicator;
    return applicator;
  }
  function deprecated(optionsOrTarget, maybeKey, maybeDescriptor) {
    function decorator(target, key, descriptor) {
      var methodSignature = target.constructor.name + '#' + key;
      var options = maybeKey ? {} : optionsOrTarget || {};
      var message = 'DEPRECATION - ' + methodSignature;
      if (typeof descriptor.value !== 'function') {
        throw new SyntaxError('Only methods can be marked as deprecated.');
      }
      if (options.message) {
        message += ' - ' + options.message;
      }
      return _extends({}, descriptor, {value: function deprecationWrapper() {
          if (options.error) {
            throw new Error(message);
          } else {
            console.warn(message);
          }
          return descriptor.value.apply(this, arguments);
        }});
    }
    return maybeKey ? decorator(optionsOrTarget, maybeKey, maybeDescriptor) : decorator;
  }
  function mixin(behavior) {
    var instanceKeys = Object.keys(behavior);
    function _mixin(possible) {
      var decorator = function decorator(target) {
        var resolvedTarget = typeof target === 'function' ? target.prototype : target;
        for (var _iterator = instanceKeys,
            _isArray = Array.isArray(_iterator),
            _i = 0,
            _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
          var _ref;
          if (_isArray) {
            if (_i >= _iterator.length)
              break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done)
              break;
            _ref = _i.value;
          }
          var property = _ref;
          Object.defineProperty(resolvedTarget, property, {
            value: behavior[property],
            writable: true
          });
        }
      };
      return possible ? decorator(possible) : decorator;
    }
    return _mixin;
  }
  function alwaysValid() {
    return true;
  }
  function noCompose() {}
  function ensureProtocolOptions(options) {
    if (options === undefined) {
      options = {};
    } else if (typeof options === 'function') {
      options = {validate: options};
    }
    if (!options.validate) {
      options.validate = alwaysValid;
    }
    if (!options.compose) {
      options.compose = noCompose;
    }
    return options;
  }
  function createProtocolValidator(validate) {
    return function(target) {
      var result = validate(target);
      return result === true;
    };
  }
  function createProtocolAsserter(name, validate) {
    return function(target) {
      var result = validate(target);
      if (result !== true) {
        throw new Error(result || name + ' was not correctly implemented.');
      }
    };
  }
  function protocol(name, options) {
    options = ensureProtocolOptions(options);
    var result = function result(target) {
      var resolvedTarget = typeof target === 'function' ? target.prototype : target;
      options.compose(resolvedTarget);
      result.assert(resolvedTarget);
      Object.defineProperty(resolvedTarget, 'protocol:' + name, {
        enumerable: false,
        configurable: false,
        writable: false,
        value: true
      });
    };
    result.validate = createProtocolValidator(options.validate);
    result.assert = createProtocolAsserter(name, options.validate);
    return result;
  }
  protocol.create = function(name, options) {
    options = ensureProtocolOptions(options);
    var hidden = 'protocol:' + name;
    var result = function result(target) {
      var decorator = protocol(name, options);
      return target ? decorator(target) : decorator;
    };
    result.decorates = function(obj) {
      return obj[hidden] === true;
    };
    result.validate = createProtocolValidator(options.validate);
    result.assert = createProtocolAsserter(name, options.validate);
    return result;
  };
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-metadata@1.0.0-beta.1", ["npm:aurelia-metadata@1.0.0-beta.1/aurelia-metadata"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-loader@1.0.0-beta.1.0.1/aurelia-loader", ["exports", "npm:aurelia-path@1.0.0-beta.1", "npm:aurelia-metadata@1.0.0-beta.1"], function(exports, _aureliaPath, _aureliaMetadata) {
  'use strict';
  exports.__esModule = true;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var TemplateDependency = function TemplateDependency(src, name) {
    _classCallCheck(this, TemplateDependency);
    this.src = src;
    this.name = name;
  };
  exports.TemplateDependency = TemplateDependency;
  var TemplateRegistryEntry = (function() {
    function TemplateRegistryEntry(address) {
      _classCallCheck(this, TemplateRegistryEntry);
      this.templateIsLoaded = false;
      this.factoryIsReady = false;
      this.resources = null;
      this.dependencies = null;
      this.address = address;
      this.onReady = null;
      this._template = null;
      this._factory = null;
    }
    TemplateRegistryEntry.prototype.addDependency = function addDependency(src, name) {
      var finalSrc = typeof src === 'string' ? _aureliaPath.relativeToFile(src, this.address) : _aureliaMetadata.Origin.get(src).moduleId;
      this.dependencies.push(new TemplateDependency(finalSrc, name));
    };
    _createClass(TemplateRegistryEntry, [{
      key: 'template',
      get: function get() {
        return this._template;
      },
      set: function set(value) {
        var address = this.address;
        var requires = undefined;
        var current = undefined;
        var src = undefined;
        var dependencies = undefined;
        this._template = value;
        this.templateIsLoaded = true;
        requires = value.content.querySelectorAll('require');
        dependencies = this.dependencies = new Array(requires.length);
        for (var i = 0,
            ii = requires.length; i < ii; ++i) {
          current = requires[i];
          src = current.getAttribute('from');
          if (!src) {
            throw new Error('<require> element in ' + address + ' has no "from" attribute.');
          }
          dependencies[i] = new TemplateDependency(_aureliaPath.relativeToFile(src, address), current.getAttribute('as'));
          if (current.parentNode) {
            current.parentNode.removeChild(current);
          }
        }
      }
    }, {
      key: 'factory',
      get: function get() {
        return this._factory;
      },
      set: function set(value) {
        this._factory = value;
        this.factoryIsReady = true;
      }
    }]);
    return TemplateRegistryEntry;
  })();
  exports.TemplateRegistryEntry = TemplateRegistryEntry;
  var Loader = (function() {
    function Loader() {
      _classCallCheck(this, Loader);
      this.templateRegistry = {};
    }
    Loader.prototype.map = function map(id, source) {
      throw new Error('Loaders must implement map(id, source).');
    };
    Loader.prototype.normalizeSync = function normalizeSync(moduleId, relativeTo) {
      throw new Error('Loaders must implement normalizeSync(moduleId, relativeTo).');
    };
    Loader.prototype.normalize = function normalize(moduleId, relativeTo) {
      throw new Error('Loaders must implement normalize(moduleId: string, relativeTo: string): Promise<string>.');
    };
    Loader.prototype.loadModule = function loadModule(id) {
      throw new Error('Loaders must implement loadModule(id).');
    };
    Loader.prototype.loadAllModules = function loadAllModules(ids) {
      throw new Error('Loader must implement loadAllModules(ids).');
    };
    Loader.prototype.loadTemplate = function loadTemplate(url) {
      throw new Error('Loader must implement loadTemplate(url).');
    };
    Loader.prototype.loadText = function loadText(url) {
      throw new Error('Loader must implement loadText(url).');
    };
    Loader.prototype.applyPluginToUrl = function applyPluginToUrl(url, pluginName) {
      throw new Error('Loader must implement applyPluginToUrl(url, pluginName).');
    };
    Loader.prototype.addPlugin = function addPlugin(pluginName, implementation) {
      throw new Error('Loader must implement addPlugin(pluginName, implementation).');
    };
    Loader.prototype.getOrCreateTemplateRegistryEntry = function getOrCreateTemplateRegistryEntry(address) {
      return this.templateRegistry[address] || (this.templateRegistry[address] = new TemplateRegistryEntry(address));
    };
    return Loader;
  })();
  exports.Loader = Loader;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-loader@1.0.0-beta.1.0.1", ["npm:aurelia-loader@1.0.0-beta.1.0.1/aurelia-loader"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-loader-default@1.0.0-beta.1.0.2/aurelia-loader-default", ["exports", "npm:aurelia-loader@1.0.0-beta.1.0.1", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-metadata@1.0.0-beta.1"], function(exports, _aureliaLoader, _aureliaPal, _aureliaMetadata) {
  'use strict';
  exports.__esModule = true;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var TextTemplateLoader = (function() {
    function TextTemplateLoader() {
      _classCallCheck(this, TextTemplateLoader);
    }
    TextTemplateLoader.prototype.loadTemplate = function loadTemplate(loader, entry) {
      return loader.loadText(entry.address).then(function(text) {
        entry.template = _aureliaPal.DOM.createTemplateFromMarkup(text);
      });
    };
    return TextTemplateLoader;
  })();
  exports.TextTemplateLoader = TextTemplateLoader;
  function ensureOriginOnExports(executed, name) {
    var target = executed;
    var key = undefined;
    var exportedValue = undefined;
    if (target.__useDefault) {
      target = target['default'];
    }
    _aureliaMetadata.Origin.set(target, new _aureliaMetadata.Origin(name, 'default'));
    for (key in target) {
      exportedValue = target[key];
      if (typeof exportedValue === 'function') {
        _aureliaMetadata.Origin.set(exportedValue, new _aureliaMetadata.Origin(name, key));
      }
    }
    return executed;
  }
  var DefaultLoader = (function(_Loader) {
    _inherits(DefaultLoader, _Loader);
    function DefaultLoader() {
      _classCallCheck(this, DefaultLoader);
      _Loader.call(this);
      this.textPluginName = 'text';
      this.moduleRegistry = {};
      this.useTemplateLoader(new TextTemplateLoader());
      var that = this;
      this.addPlugin('template-registry-entry', {'fetch': function fetch(address) {
          var entry = that.getOrCreateTemplateRegistryEntry(address);
          return entry.templateIsLoaded ? entry : that.templateLoader.loadTemplate(that, entry).then(function(x) {
            return entry;
          });
        }});
    }
    DefaultLoader.prototype.useTemplateLoader = function useTemplateLoader(templateLoader) {
      this.templateLoader = templateLoader;
    };
    DefaultLoader.prototype.loadAllModules = function loadAllModules(ids) {
      var loads = [];
      for (var i = 0,
          ii = ids.length; i < ii; ++i) {
        loads.push(this.loadModule(ids[i]));
      }
      return Promise.all(loads);
    };
    DefaultLoader.prototype.loadTemplate = function loadTemplate(url) {
      return this._import(this.applyPluginToUrl(url, 'template-registry-entry'));
    };
    DefaultLoader.prototype.loadText = function loadText(url) {
      return this._import(this.applyPluginToUrl(url, this.textPluginName));
    };
    return DefaultLoader;
  })(_aureliaLoader.Loader);
  exports.DefaultLoader = DefaultLoader;
  _aureliaPal.PLATFORM.Loader = DefaultLoader;
  if (!_aureliaPal.PLATFORM.global.System || !_aureliaPal.PLATFORM.global.System['import']) {
    if (_aureliaPal.PLATFORM.global.requirejs && requirejs.s && requirejs.s.contexts && requirejs.s.contexts._ && requirejs.s.contexts._.defined) {
      _aureliaPal.PLATFORM.eachModule = function(callback) {
        var defined = requirejs.s.contexts._.defined;
        for (var key in defined) {
          try {
            if (callback(key, defined[key]))
              return;
          } catch (e) {}
        }
      };
    } else {
      _aureliaPal.PLATFORM.eachModule = function(callback) {};
    }
    DefaultLoader.prototype._import = function(moduleId) {
      return new Promise(function(resolve, reject) {
        require([moduleId], resolve, reject);
      });
    };
    DefaultLoader.prototype.loadModule = function(id) {
      var _this = this;
      var existing = this.moduleRegistry[id];
      if (existing !== undefined) {
        return Promise.resolve(existing);
      }
      return new Promise(function(resolve, reject) {
        require([id], function(m) {
          _this.moduleRegistry[id] = m;
          resolve(ensureOriginOnExports(m, id));
        }, reject);
      });
    };
    DefaultLoader.prototype.map = function(id, source) {};
    DefaultLoader.prototype.normalize = function(moduleId, relativeTo) {
      return Promise.resolve(moduleId);
    };
    DefaultLoader.prototype.normalizeSync = function(moduleId, relativeTo) {
      return moduleId;
    };
    DefaultLoader.prototype.applyPluginToUrl = function(url, pluginName) {
      return pluginName + '!' + url;
    };
    DefaultLoader.prototype.addPlugin = function(pluginName, implementation) {
      define(pluginName, [], {'load': function load(name, req, onload) {
          var address = req.toUrl(name);
          var result = implementation.fetch(address);
          Promise.resolve(result).then(onload);
        }});
    };
  } else {
    _aureliaPal.PLATFORM.eachModule = function(callback) {
      var modules = System._loader.modules;
      for (var key in modules) {
        try {
          if (callback(key, modules[key].module))
            return;
        } catch (e) {}
      }
    };
    System.set('text', System.newModule({'translate': function translate(load) {
        return 'module.exports = "' + load.source.replace(/(["\\])/g, '\\$1').replace(/[\f]/g, '\\f').replace(/[\b]/g, '\\b').replace(/[\n]/g, '\\n').replace(/[\t]/g, '\\t').replace(/[\r]/g, '\\r').replace(/[\u2028]/g, '\\u2028').replace(/[\u2029]/g, '\\u2029') + '";';
      }}));
    DefaultLoader.prototype._import = function(moduleId) {
      return System['import'](moduleId);
    };
    DefaultLoader.prototype.loadModule = function(id) {
      var _this2 = this;
      var existing = this.moduleRegistry[id];
      if (existing !== undefined) {
        return Promise.resolve(existing);
      }
      return System['import'](id).then(function(m) {
        _this2.moduleRegistry[id] = m;
        return ensureOriginOnExports(m, id);
      });
    };
    DefaultLoader.prototype.map = function(id, source) {
      System.map[id] = source;
    };
    DefaultLoader.prototype.normalizeSync = function(moduleId, relativeTo) {
      return System.normalizeSync(moduleId, relativeTo);
    };
    DefaultLoader.prototype.normalize = function(moduleId, relativeTo) {
      return System.normalize(moduleId, relativeTo);
    };
    DefaultLoader.prototype.applyPluginToUrl = function(url, pluginName) {
      return url + '!' + pluginName;
    };
    DefaultLoader.prototype.addPlugin = function(pluginName, implementation) {
      System.set(pluginName, System.newModule({
        'fetch': function fetch(load, _fetch) {
          var result = implementation.fetch(load.address);
          return Promise.resolve(result).then(function(x) {
            load.metadata.result = x;
            return '';
          });
        },
        'instantiate': function instantiate(load) {
          return load.metadata.result;
        }
      }));
    };
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-loader-default@1.0.0-beta.1.0.2", ["npm:aurelia-loader-default@1.0.0-beta.1.0.2/aurelia-loader-default"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-logging@1.0.0-beta.1.1.1/aurelia-logging", ["exports"], function(exports) {
  'use strict';
  exports.__esModule = true;
  exports.getLogger = getLogger;
  exports.addAppender = addAppender;
  exports.setLevel = setLevel;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var logLevel = {
    none: 0,
    error: 1,
    warn: 2,
    info: 3,
    debug: 4
  };
  exports.logLevel = logLevel;
  var loggers = {};
  var currentLevel = logLevel.none;
  var appenders = [];
  var slice = Array.prototype.slice;
  var loggerConstructionKey = {};
  function log(logger, level, args) {
    var i = appenders.length;
    var current = undefined;
    args = slice.call(args);
    args.unshift(logger);
    while (i--) {
      current = appenders[i];
      current[level].apply(current, args);
    }
  }
  function debug() {
    if (currentLevel < 4) {
      return;
    }
    log(this, 'debug', arguments);
  }
  function info() {
    if (currentLevel < 3) {
      return;
    }
    log(this, 'info', arguments);
  }
  function warn() {
    if (currentLevel < 2) {
      return;
    }
    log(this, 'warn', arguments);
  }
  function error() {
    if (currentLevel < 1) {
      return;
    }
    log(this, 'error', arguments);
  }
  function connectLogger(logger) {
    logger.debug = debug;
    logger.info = info;
    logger.warn = warn;
    logger.error = error;
  }
  function createLogger(id) {
    var logger = new Logger(id, loggerConstructionKey);
    if (appenders.length) {
      connectLogger(logger);
    }
    return logger;
  }
  function getLogger(id) {
    return loggers[id] || (loggers[id] = createLogger(id));
  }
  function addAppender(appender) {
    appenders.push(appender);
    if (appenders.length === 1) {
      for (var key in loggers) {
        connectLogger(loggers[key]);
      }
    }
  }
  function setLevel(level) {
    currentLevel = level;
  }
  var Logger = (function() {
    function Logger(id, key) {
      _classCallCheck(this, Logger);
      if (key !== loggerConstructionKey) {
        throw new Error('You cannot instantiate "Logger". Use the "getLogger" API instead.');
      }
      this.id = id;
    }
    Logger.prototype.debug = function debug(message) {};
    Logger.prototype.info = function info(message) {};
    Logger.prototype.warn = function warn(message) {};
    Logger.prototype.error = function error(message) {};
    return Logger;
  })();
  exports.Logger = Logger;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-logging@1.0.0-beta.1.1.1", ["npm:aurelia-logging@1.0.0-beta.1.1.1/aurelia-logging"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-task-queue@1.0.0-beta.1.0.1/aurelia-task-queue", ["exports", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var hasSetImmediate = typeof setImmediate === 'function';
  function makeRequestFlushFromMutationObserver(flush) {
    var toggle = 1;
    var observer = _aureliaPal.DOM.createMutationObserver(flush);
    var node = _aureliaPal.DOM.createTextNode('');
    observer.observe(node, {characterData: true});
    return function requestFlush() {
      toggle = -toggle;
      node.data = toggle;
    };
  }
  function makeRequestFlushFromTimer(flush) {
    return function requestFlush() {
      var timeoutHandle = setTimeout(handleFlushTimer, 0);
      var intervalHandle = setInterval(handleFlushTimer, 50);
      function handleFlushTimer() {
        clearTimeout(timeoutHandle);
        clearInterval(intervalHandle);
        flush();
      }
    };
  }
  function onError(error, task) {
    if ('onError' in task) {
      task.onError(error);
    } else if (hasSetImmediate) {
      setImmediate(function() {
        throw error;
      });
    } else {
      setTimeout(function() {
        throw error;
      }, 0);
    }
  }
  var TaskQueue = (function() {
    function TaskQueue() {
      var _this = this;
      _classCallCheck(this, TaskQueue);
      this.microTaskQueue = [];
      this.microTaskQueueCapacity = 1024;
      this.taskQueue = [];
      this.requestFlushMicroTaskQueue = makeRequestFlushFromMutationObserver(function() {
        return _this.flushMicroTaskQueue();
      });
      this.requestFlushTaskQueue = makeRequestFlushFromTimer(function() {
        return _this.flushTaskQueue();
      });
    }
    TaskQueue.prototype.queueMicroTask = function queueMicroTask(task) {
      if (this.microTaskQueue.length < 1) {
        this.requestFlushMicroTaskQueue();
      }
      this.microTaskQueue.push(task);
    };
    TaskQueue.prototype.queueTask = function queueTask(task) {
      if (this.taskQueue.length < 1) {
        this.requestFlushTaskQueue();
      }
      this.taskQueue.push(task);
    };
    TaskQueue.prototype.flushTaskQueue = function flushTaskQueue() {
      var queue = this.taskQueue;
      var index = 0;
      var task = undefined;
      this.taskQueue = [];
      try {
        while (index < queue.length) {
          task = queue[index];
          task.call();
          index++;
        }
      } catch (error) {
        onError(error, task);
      }
    };
    TaskQueue.prototype.flushMicroTaskQueue = function flushMicroTaskQueue() {
      var queue = this.microTaskQueue;
      var capacity = this.microTaskQueueCapacity;
      var index = 0;
      var task = undefined;
      try {
        while (index < queue.length) {
          task = queue[index];
          task.call();
          index++;
          if (index > capacity) {
            for (var scan = 0,
                newLength = queue.length - index; scan < newLength; scan++) {
              queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
          }
        }
      } catch (error) {
        onError(error, task);
      }
      queue.length = 0;
    };
    return TaskQueue;
  })();
  exports.TaskQueue = TaskQueue;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-task-queue@1.0.0-beta.1.0.1", ["npm:aurelia-task-queue@1.0.0-beta.1.0.1/aurelia-task-queue"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-binding@1.0.0-beta.1.0.5/aurelia-binding", ["exports", "npm:core-js@1.2.6", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-task-queue@1.0.0-beta.1.0.1", "npm:aurelia-metadata@1.0.0-beta.1"], function(exports, _coreJs, _aureliaPal, _aureliaTaskQueue, _aureliaMetadata) {
  'use strict';
  exports.__esModule = true;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.camelCase = camelCase;
  exports.createOverrideContext = createOverrideContext;
  exports.getContextFor = getContextFor;
  exports.createScopeForTest = createScopeForTest;
  exports.connectable = connectable;
  exports.enqueueBindingConnect = enqueueBindingConnect;
  exports.subscriberCollection = subscriberCollection;
  exports.calcSplices = calcSplices;
  exports.mergeSplice = mergeSplice;
  exports.projectArraySplices = projectArraySplices;
  exports.getChangeRecords = getChangeRecords;
  exports.getArrayObserver = _getArrayObserver;
  exports.getMapObserver = _getMapObserver;
  exports.hasDeclaredDependencies = hasDeclaredDependencies;
  exports.declarePropertyDependencies = declarePropertyDependencies;
  exports.computedFrom = computedFrom;
  exports.valueConverter = valueConverter;
  exports.bindingBehavior = bindingBehavior;
  exports.getSetObserver = getSetObserver;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function camelCase(name) {
    return name.charAt(0).toLowerCase() + name.slice(1);
  }
  function createOverrideContext(bindingContext, parentOverrideContext) {
    return {
      bindingContext: bindingContext,
      parentOverrideContext: parentOverrideContext || null
    };
  }
  function getContextFor(name, scope, ancestor) {
    var oc = scope.overrideContext;
    if (ancestor) {
      while (ancestor && oc) {
        ancestor--;
        oc = oc.parentOverrideContext;
      }
      if (ancestor || !oc) {
        return undefined;
      }
      return name in oc ? oc : oc.bindingContext;
    }
    while (oc && !(name in oc) && !(oc.bindingContext && name in oc.bindingContext)) {
      oc = oc.parentOverrideContext;
    }
    if (oc) {
      return name in oc ? oc : oc.bindingContext;
    }
    return scope.bindingContext || scope.overrideContext;
  }
  function createScopeForTest(bindingContext, parentBindingContext) {
    if (parentBindingContext) {
      return {
        bindingContext: bindingContext,
        overrideContext: createOverrideContext(bindingContext, createOverrideContext(parentBindingContext))
      };
    }
    return {
      bindingContext: bindingContext,
      overrideContext: createOverrideContext(bindingContext)
    };
  }
  var sourceContext = 'Binding:source';
  exports.sourceContext = sourceContext;
  var slotNames = [];
  var versionSlotNames = [];
  for (var i = 0; i < 100; i++) {
    slotNames.push('_observer' + i);
    versionSlotNames.push('_observerVersion' + i);
  }
  function addObserver(observer) {
    var observerSlots = this._observerSlots === undefined ? 0 : this._observerSlots;
    var i = observerSlots;
    while (i-- && this[slotNames[i]] !== observer) {}
    if (i === -1) {
      i = 0;
      while (this[slotNames[i]]) {
        i++;
      }
      this[slotNames[i]] = observer;
      observer.subscribe(sourceContext, this);
      if (i === observerSlots) {
        this._observerSlots = i + 1;
      }
    }
    if (this._version === undefined) {
      this._version = 0;
    }
    this[versionSlotNames[i]] = this._version;
  }
  function observeProperty(obj, propertyName) {
    var observer = this.observerLocator.getObserver(obj, propertyName);
    addObserver.call(this, observer);
  }
  function observeArray(array) {
    var observer = this.observerLocator.getArrayObserver(array);
    addObserver.call(this, observer);
  }
  function unobserve(all) {
    var i = this._observerSlots;
    while (i--) {
      if (all || this[versionSlotNames[i]] !== this._version) {
        var observer = this[slotNames[i]];
        this[slotNames[i]] = null;
        if (observer) {
          observer.unsubscribe(sourceContext, this);
        }
      }
    }
  }
  function connectable() {
    return function(target) {
      target.prototype.observeProperty = observeProperty;
      target.prototype.observeArray = observeArray;
      target.prototype.unobserve = unobserve;
    };
  }
  var bindings = new Map();
  var minimumImmediate = 100;
  var frameBudget = 15;
  var isFlushRequested = false;
  var immediate = 0;
  function flush(animationFrameStart) {
    var i = 0;
    for (var _iterator = bindings,
        _isArray = Array.isArray(_iterator),
        _i = 0,
        _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
      var _ref;
      if (_isArray) {
        if (_i >= _iterator.length)
          break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done)
          break;
        _ref = _i.value;
      }
      var binding = _ref[0];
      bindings['delete'](binding);
      binding.connect(true);
      i++;
      if (i % 100 === 0 && _aureliaPal.PLATFORM.performance.now() - animationFrameStart > frameBudget) {
        break;
      }
    }
    if (bindings.size) {
      _aureliaPal.PLATFORM.requestAnimationFrame(flush);
    } else {
      isFlushRequested = false;
      immediate = 0;
    }
  }
  function enqueueBindingConnect(binding) {
    if (immediate < minimumImmediate) {
      immediate++;
      binding.connect(false);
    } else {
      bindings.set(binding);
    }
    if (!isFlushRequested) {
      isFlushRequested = true;
      _aureliaPal.PLATFORM.requestAnimationFrame(flush);
    }
  }
  function addSubscriber(context, callable) {
    if (this.hasSubscriber(context, callable)) {
      return false;
    }
    if (!this._context0) {
      this._context0 = context;
      this._callable0 = callable;
      return true;
    }
    if (!this._context1) {
      this._context1 = context;
      this._callable1 = callable;
      return true;
    }
    if (!this._context2) {
      this._context2 = context;
      this._callable2 = callable;
      return true;
    }
    if (!this._contextsRest) {
      this._contextsRest = [context];
      this._callablesRest = [callable];
      return true;
    }
    this._contextsRest.push(context);
    this._callablesRest.push(callable);
    return true;
  }
  function removeSubscriber(context, callable) {
    if (this._context0 === context && this._callable0 === callable) {
      this._context0 = null;
      this._callable0 = null;
      return true;
    }
    if (this._context1 === context && this._callable1 === callable) {
      this._context1 = null;
      this._callable1 = null;
      return true;
    }
    if (this._context2 === context && this._callable2 === callable) {
      this._context2 = null;
      this._callable2 = null;
      return true;
    }
    var rest = this._contextsRest;
    var index = undefined;
    if (!rest || !rest.length || (index = rest.indexOf(context)) === -1 || this._callablesRest[index] !== callable) {
      return false;
    }
    rest.splice(index, 1);
    this._callablesRest.splice(index, 1);
    return true;
  }
  var arrayPool1 = [];
  var arrayPool2 = [];
  var poolUtilization = [];
  function callSubscribers(newValue, oldValue) {
    var context0 = this._context0;
    var callable0 = this._callable0;
    var context1 = this._context1;
    var callable1 = this._callable1;
    var context2 = this._context2;
    var callable2 = this._callable2;
    var length = this._contextsRest ? this._contextsRest.length : 0;
    var contextsRest = undefined;
    var callablesRest = undefined;
    var poolIndex = undefined;
    var i = undefined;
    if (length) {
      poolIndex = poolUtilization.length;
      while (poolIndex-- && poolUtilization[poolIndex]) {}
      if (poolIndex < 0) {
        poolIndex = poolUtilization.length;
        contextsRest = [];
        callablesRest = [];
        poolUtilization.push(true);
        arrayPool1.push(contextsRest);
        arrayPool2.push(callablesRest);
      } else {
        poolUtilization[poolIndex] = true;
        contextsRest = arrayPool1[poolIndex];
        callablesRest = arrayPool2[poolIndex];
      }
      i = length;
      while (i--) {
        contextsRest[i] = this._contextsRest[i];
        callablesRest[i] = this._callablesRest[i];
      }
    }
    if (context0) {
      if (callable0) {
        callable0.call(context0, newValue, oldValue);
      } else {
        context0(newValue, oldValue);
      }
    }
    if (context1) {
      if (callable1) {
        callable1.call(context1, newValue, oldValue);
      } else {
        context1(newValue, oldValue);
      }
    }
    if (context2) {
      if (callable2) {
        callable2.call(context2, newValue, oldValue);
      } else {
        context2(newValue, oldValue);
      }
    }
    if (length) {
      for (i = 0; i < length; i++) {
        var callable = callablesRest[i];
        var context = contextsRest[i];
        if (callable) {
          callable.call(context, newValue, oldValue);
        } else {
          context(newValue, oldValue);
        }
        contextsRest[i] = null;
        callablesRest[i] = null;
      }
      poolUtilization[poolIndex] = false;
    }
  }
  function hasSubscribers() {
    return !!(this._context0 || this._context1 || this._context2 || this._contextsRest && this._contextsRest.length);
  }
  function hasSubscriber(context, callable) {
    var has = this._context0 === context && this._callable0 === callable || this._context1 === context && this._callable1 === callable || this._context2 === context && this._callable2 === callable;
    if (has) {
      return true;
    }
    var index = undefined;
    var contexts = this._contextsRest;
    if (!contexts || (index = contexts.length) === 0) {
      return false;
    }
    var callables = this._callablesRest;
    while (index--) {
      if (contexts[index] === context && callables[index] === callable) {
        return true;
      }
    }
    return false;
  }
  function subscriberCollection() {
    return function(target) {
      target.prototype.addSubscriber = addSubscriber;
      target.prototype.removeSubscriber = removeSubscriber;
      target.prototype.callSubscribers = callSubscribers;
      target.prototype.hasSubscribers = hasSubscribers;
      target.prototype.hasSubscriber = hasSubscriber;
    };
  }
  function isIndex(s) {
    return +s === s >>> 0;
  }
  function toNumber(s) {
    return +s;
  }
  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }
  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;
  function ArraySplice() {}
  ArraySplice.prototype = {
    calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);
      var i,
          j,
          north,
          west;
      for (i = 0; i < rowCount; ++i) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }
      for (j = 0; j < columnCount; ++j) {
        distances[0][j] = j;
      }
      for (i = 1; i < rowCount; ++i) {
        for (j = 1; j < columnCount; ++j) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            north = distances[i - 1][j] + 1;
            west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }
      return distances;
    },
    spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];
        var min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;
        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }
      edits.reverse();
      return edits;
    },
    calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;
      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = this.sharedPrefix(current, old, minLength);
      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;
      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];
      if (currentStart == currentEnd) {
        var splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);
        return [splice];
      } else if (oldStart == oldEnd)
        return [newSplice(currentStart, [], currentEnd - currentStart)];
      var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
      var splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; ++i) {
        switch (ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }
            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);
            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);
            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }
      if (splice) {
        splices.push(splice);
      }
      return splices;
    },
    sharedPrefix: function sharedPrefix(current, old, searchLength) {
      for (var i = 0; i < searchLength; ++i)
        if (!this.equals(current[i], old[i]))
          return i;
      return searchLength;
    },
    sharedSuffix: function sharedSuffix(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2]))
        count++;
      return count;
    },
    calculateSplices: function calculateSplices(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
    },
    equals: function equals(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };
  var arraySplice = new ArraySplice();
  function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
    return arraySplice.calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd);
  }
  function intersect(start1, end1, start2, end2) {
    if (end1 < start2 || end2 < start1)
      return -1;
    if (end1 == start2 || end2 == start1)
      return 0;
    if (start1 < start2) {
      if (end1 < end2)
        return end1 - start2;
      else
        return end2 - start2;
    } else {
      if (end2 < end1)
        return end2 - start1;
      else
        return end1 - start1;
    }
  }
  function mergeSplice(splices, index, removed, addedCount) {
    var splice = newSplice(index, removed, addedCount);
    var inserted = false;
    var insertionOffset = 0;
    for (var i = 0; i < splices.length; i++) {
      var current = splices[i];
      current.index += insertionOffset;
      if (inserted)
        continue;
      var intersectCount = intersect(splice.index, splice.index + splice.removed.length, current.index, current.index + current.addedCount);
      if (intersectCount >= 0) {
        splices.splice(i, 1);
        i--;
        insertionOffset -= current.addedCount - current.removed.length;
        splice.addedCount += current.addedCount - intersectCount;
        var deleteCount = splice.removed.length + current.removed.length - intersectCount;
        if (!splice.addedCount && !deleteCount) {
          inserted = true;
        } else {
          var removed = current.removed;
          if (splice.index < current.index) {
            var prepend = splice.removed.slice(0, current.index - splice.index);
            Array.prototype.push.apply(prepend, removed);
            removed = prepend;
          }
          if (splice.index + splice.removed.length > current.index + current.addedCount) {
            var append = splice.removed.slice(current.index + current.addedCount - splice.index);
            Array.prototype.push.apply(removed, append);
          }
          splice.removed = removed;
          if (current.index < splice.index) {
            splice.index = current.index;
          }
        }
      } else if (splice.index < current.index) {
        inserted = true;
        splices.splice(i, 0, splice);
        i++;
        var offset = splice.addedCount - splice.removed.length;
        current.index += offset;
        insertionOffset += offset;
      }
    }
    if (!inserted)
      splices.push(splice);
  }
  function createInitialSplices(array, changeRecords) {
    var splices = [];
    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      switch (record.type) {
        case 'splice':
          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
          break;
        case 'add':
        case 'update':
        case 'delete':
          if (!isIndex(record.name))
            continue;
          var index = toNumber(record.name);
          if (index < 0)
            continue;
          mergeSplice(splices, index, [record.oldValue], record.type === 'delete' ? 0 : 1);
          break;
        default:
          console.error('Unexpected record type: ' + JSON.stringify(record));
          break;
      }
    }
    return splices;
  }
  function projectArraySplices(array, changeRecords) {
    var splices = [];
    createInitialSplices(array, changeRecords).forEach(function(splice) {
      if (splice.addedCount == 1 && splice.removed.length == 1) {
        if (splice.removed[0] !== array[splice.index])
          splices.push(splice);
        return;
      }
      ;
      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount, splice.removed, 0, splice.removed.length));
    });
    return splices;
  }
  function newRecord(type, object, key, oldValue) {
    return {
      type: type,
      object: object,
      key: key,
      oldValue: oldValue
    };
  }
  function getChangeRecords(map) {
    var entries = [];
    for (var _iterator2 = map.keys(),
        _isArray2 = Array.isArray(_iterator2),
        _i2 = 0,
        _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
      var _ref2;
      if (_isArray2) {
        if (_i2 >= _iterator2.length)
          break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done)
          break;
        _ref2 = _i2.value;
      }
      var key = _ref2;
      entries.push(newRecord('added', map, key));
    }
    return entries;
  }
  var ModifyCollectionObserver = (function() {
    function ModifyCollectionObserver(taskQueue, collection) {
      _classCallCheck(this, _ModifyCollectionObserver);
      this.taskQueue = taskQueue;
      this.queued = false;
      this.changeRecords = null;
      this.oldCollection = null;
      this.collection = collection;
      this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
    }
    ModifyCollectionObserver.prototype.subscribe = function subscribe(context, callable) {
      this.addSubscriber(context, callable);
    };
    ModifyCollectionObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };
    ModifyCollectionObserver.prototype.addChangeRecord = function addChangeRecord(changeRecord) {
      if (!this.hasSubscribers() && !this.lengthObserver) {
        return;
      }
      if (changeRecord.type === 'splice') {
        var index = changeRecord.index;
        var arrayLength = changeRecord.object.length;
        if (index > arrayLength) {
          index = arrayLength - changeRecord.addedCount;
        } else if (index < 0) {
          index = arrayLength + changeRecord.removed.length + index - changeRecord.addedCount;
        }
        if (index < 0) {
          index = 0;
        }
        changeRecord.index = index;
      }
      if (this.changeRecords === null) {
        this.changeRecords = [changeRecord];
      } else {
        this.changeRecords.push(changeRecord);
      }
      if (!this.queued) {
        this.queued = true;
        this.taskQueue.queueMicroTask(this);
      }
    };
    ModifyCollectionObserver.prototype.flushChangeRecords = function flushChangeRecords() {
      if (this.changeRecords && this.changeRecords.length || this.oldCollection) {
        this.call();
      }
    };
    ModifyCollectionObserver.prototype.reset = function reset(oldCollection) {
      this.oldCollection = oldCollection;
      if (this.hasSubscribers() && !this.queued) {
        this.queued = true;
        this.taskQueue.queueMicroTask(this);
      }
    };
    ModifyCollectionObserver.prototype.getLengthObserver = function getLengthObserver() {
      return this.lengthObserver || (this.lengthObserver = new CollectionLengthObserver(this.collection));
    };
    ModifyCollectionObserver.prototype.call = function call() {
      var changeRecords = this.changeRecords;
      var oldCollection = this.oldCollection;
      var records = undefined;
      this.queued = false;
      this.changeRecords = [];
      this.oldCollection = null;
      if (this.hasSubscribers()) {
        if (oldCollection) {
          if (this.collection instanceof Map || this.collection instanceof Set) {
            records = getChangeRecords(oldCollection);
          } else {
            records = calcSplices(this.collection, 0, this.collection.length, oldCollection, 0, oldCollection.length);
          }
        } else {
          if (this.collection instanceof Map || this.collection instanceof Set) {
            records = changeRecords;
          } else {
            records = projectArraySplices(this.collection, changeRecords);
          }
        }
        this.callSubscribers(records);
      }
      if (this.lengthObserver) {
        this.lengthObserver.call(this.collection[this.lengthPropertyName]);
      }
    };
    var _ModifyCollectionObserver = ModifyCollectionObserver;
    ModifyCollectionObserver = subscriberCollection()(ModifyCollectionObserver) || ModifyCollectionObserver;
    return ModifyCollectionObserver;
  })();
  exports.ModifyCollectionObserver = ModifyCollectionObserver;
  var CollectionLengthObserver = (function() {
    function CollectionLengthObserver(collection) {
      _classCallCheck(this, _CollectionLengthObserver);
      this.collection = collection;
      this.lengthPropertyName = collection instanceof Map || collection instanceof Set ? 'size' : 'length';
      this.currentValue = collection[this.lengthPropertyName];
    }
    CollectionLengthObserver.prototype.getValue = function getValue() {
      return this.collection[this.lengthPropertyName];
    };
    CollectionLengthObserver.prototype.setValue = function setValue(newValue) {
      this.collection[this.lengthPropertyName] = newValue;
    };
    CollectionLengthObserver.prototype.subscribe = function subscribe(context, callable) {
      this.addSubscriber(context, callable);
    };
    CollectionLengthObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };
    CollectionLengthObserver.prototype.call = function call(newValue) {
      var oldValue = this.currentValue;
      this.callSubscribers(newValue, oldValue);
      this.currentValue = newValue;
    };
    var _CollectionLengthObserver = CollectionLengthObserver;
    CollectionLengthObserver = subscriberCollection()(CollectionLengthObserver) || CollectionLengthObserver;
    return CollectionLengthObserver;
  })();
  exports.CollectionLengthObserver = CollectionLengthObserver;
  var pop = Array.prototype.pop;
  var push = Array.prototype.push;
  var reverse = Array.prototype.reverse;
  var shift = Array.prototype.shift;
  var sort = Array.prototype.sort;
  var splice = Array.prototype.splice;
  var unshift = Array.prototype.unshift;
  Array.prototype.pop = function() {
    var methodCallResult = pop.apply(this, arguments);
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.addChangeRecord({
        type: 'delete',
        object: this,
        name: this.length,
        oldValue: methodCallResult
      });
    }
    return methodCallResult;
  };
  Array.prototype.push = function() {
    var methodCallResult = push.apply(this, arguments);
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.addChangeRecord({
        type: 'splice',
        object: this,
        index: this.length - arguments.length,
        removed: [],
        addedCount: arguments.length
      });
    }
    return methodCallResult;
  };
  Array.prototype.reverse = function() {
    var oldArray = undefined;
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.flushChangeRecords();
      oldArray = this.slice();
    }
    var methodCallResult = reverse.apply(this, arguments);
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.reset(oldArray);
    }
    return methodCallResult;
  };
  Array.prototype.shift = function() {
    var methodCallResult = shift.apply(this, arguments);
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.addChangeRecord({
        type: 'delete',
        object: this,
        name: 0,
        oldValue: methodCallResult
      });
    }
    return methodCallResult;
  };
  Array.prototype.sort = function() {
    var oldArray = undefined;
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.flushChangeRecords();
      oldArray = this.slice();
    }
    var methodCallResult = sort.apply(this, arguments);
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.reset(oldArray);
    }
    return methodCallResult;
  };
  Array.prototype.splice = function() {
    var methodCallResult = splice.apply(this, arguments);
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.addChangeRecord({
        type: 'splice',
        object: this,
        index: arguments[0],
        removed: methodCallResult,
        addedCount: arguments.length > 2 ? arguments.length - 2 : 0
      });
    }
    return methodCallResult;
  };
  Array.prototype.unshift = function() {
    var methodCallResult = unshift.apply(this, arguments);
    if (this.__arrayObserver !== undefined) {
      this.__arrayObserver.addChangeRecord({
        type: 'splice',
        object: this,
        index: 0,
        removed: [],
        addedCount: arguments.length
      });
    }
    return methodCallResult;
  };
  function _getArrayObserver(taskQueue, array) {
    return ModifyArrayObserver.create(taskQueue, array);
  }
  var ModifyArrayObserver = (function(_ModifyCollectionObserver2) {
    _inherits(ModifyArrayObserver, _ModifyCollectionObserver2);
    function ModifyArrayObserver(taskQueue, array) {
      _classCallCheck(this, ModifyArrayObserver);
      _ModifyCollectionObserver2.call(this, taskQueue, array);
    }
    ModifyArrayObserver.create = function create(taskQueue, array) {
      var observer = new ModifyArrayObserver(taskQueue, array);
      Object.defineProperty(array, '__arrayObserver', {
        value: observer,
        enumerable: false,
        configurable: false
      });
      return observer;
    };
    return ModifyArrayObserver;
  })(ModifyCollectionObserver);
  var Expression = (function() {
    function Expression() {
      _classCallCheck(this, Expression);
      this.isChain = false;
      this.isAssignable = false;
    }
    Expression.prototype.evaluate = function evaluate(scope, lookupFunctions, args) {
      throw new Error('Binding expression "' + this + '" cannot be evaluated.');
    };
    Expression.prototype.assign = function assign(scope, value, lookupFunctions) {
      throw new Error('Binding expression "' + this + '" cannot be assigned to.');
    };
    Expression.prototype.toString = function toString() {
      return Unparser.unparse(this);
    };
    return Expression;
  })();
  exports.Expression = Expression;
  var Chain = (function(_Expression) {
    _inherits(Chain, _Expression);
    function Chain(expressions) {
      _classCallCheck(this, Chain);
      _Expression.call(this);
      this.expressions = expressions;
      this.isChain = true;
    }
    Chain.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var result,
          expressions = this.expressions,
          length = expressions.length,
          i,
          last;
      for (i = 0; i < length; ++i) {
        last = expressions[i].evaluate(scope, lookupFunctions);
        if (last !== null) {
          result = last;
        }
      }
      return result;
    };
    Chain.prototype.accept = function accept(visitor) {
      visitor.visitChain(this);
    };
    return Chain;
  })(Expression);
  exports.Chain = Chain;
  var BindingBehavior = (function(_Expression2) {
    _inherits(BindingBehavior, _Expression2);
    function BindingBehavior(expression, name, args) {
      _classCallCheck(this, BindingBehavior);
      _Expression2.call(this);
      this.expression = expression;
      this.name = name;
      this.args = args;
    }
    BindingBehavior.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.expression.evaluate(scope, lookupFunctions);
    };
    BindingBehavior.prototype.assign = function assign(scope, value, lookupFunctions) {
      return this.expression.assign(scope, value, lookupFunctions);
    };
    BindingBehavior.prototype.accept = function accept(visitor) {
      visitor.visitBindingBehavior(this);
    };
    BindingBehavior.prototype.connect = function connect(binding, scope) {
      this.expression.connect(binding, scope);
    };
    BindingBehavior.prototype.bind = function bind(binding, scope, lookupFunctions) {
      if (this.expression.expression && this.expression.bind) {
        this.expression.bind(binding, scope, lookupFunctions);
      }
      var behavior = lookupFunctions.bindingBehaviors(this.name);
      if (!behavior) {
        throw new Error('No BindingBehavior named "' + this.name + '" was found!');
      }
      var behaviorKey = 'behavior-' + this.name;
      if (binding[behaviorKey]) {
        throw new Error('A binding behavior named "' + this.name + '" has already been applied to "' + this.expression + '"');
      }
      binding[behaviorKey] = behavior;
      behavior.bind.apply(behavior, [binding, scope].concat(evalList(scope, this.args, binding.lookupFunctions)));
    };
    BindingBehavior.prototype.unbind = function unbind(binding, scope) {
      var behaviorKey = 'behavior-' + this.name;
      binding[behaviorKey].unbind(binding, scope);
      binding[behaviorKey] = null;
      if (this.expression.expression && this.expression.unbind) {
        this.expression.unbind(binding, scope);
      }
    };
    return BindingBehavior;
  })(Expression);
  exports.BindingBehavior = BindingBehavior;
  var ValueConverter = (function(_Expression3) {
    _inherits(ValueConverter, _Expression3);
    function ValueConverter(expression, name, args, allArgs) {
      _classCallCheck(this, ValueConverter);
      _Expression3.call(this);
      this.expression = expression;
      this.name = name;
      this.args = args;
      this.allArgs = allArgs;
    }
    ValueConverter.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var converter = lookupFunctions.valueConverters(this.name);
      if (!converter) {
        throw new Error('No ValueConverter named "' + this.name + '" was found!');
      }
      if ('toView' in converter) {
        return converter.toView.apply(converter, evalList(scope, this.allArgs, lookupFunctions));
      }
      return this.allArgs[0].evaluate(scope, lookupFunctions);
    };
    ValueConverter.prototype.assign = function assign(scope, value, lookupFunctions) {
      var converter = lookupFunctions.valueConverters(this.name);
      if (!converter) {
        throw new Error('No ValueConverter named "' + this.name + '" was found!');
      }
      if ('fromView' in converter) {
        value = converter.fromView.apply(converter, [value].concat(evalList(scope, this.args, lookupFunctions)));
      }
      return this.allArgs[0].assign(scope, value, lookupFunctions);
    };
    ValueConverter.prototype.accept = function accept(visitor) {
      visitor.visitValueConverter(this);
    };
    ValueConverter.prototype.connect = function connect(binding, scope) {
      var expressions = this.allArgs;
      var i = expressions.length;
      while (i--) {
        expressions[i].connect(binding, scope);
      }
    };
    return ValueConverter;
  })(Expression);
  exports.ValueConverter = ValueConverter;
  var Assign = (function(_Expression4) {
    _inherits(Assign, _Expression4);
    function Assign(target, value) {
      _classCallCheck(this, Assign);
      _Expression4.call(this);
      this.target = target;
      this.value = value;
    }
    Assign.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.target.assign(scope, this.value.evaluate(scope, lookupFunctions));
    };
    Assign.prototype.accept = function accept(vistor) {
      vistor.visitAssign(this);
    };
    Assign.prototype.connect = function connect(binding, scope) {};
    return Assign;
  })(Expression);
  exports.Assign = Assign;
  var Conditional = (function(_Expression5) {
    _inherits(Conditional, _Expression5);
    function Conditional(condition, yes, no) {
      _classCallCheck(this, Conditional);
      _Expression5.call(this);
      this.condition = condition;
      this.yes = yes;
      this.no = no;
    }
    Conditional.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return !!this.condition.evaluate(scope) ? this.yes.evaluate(scope) : this.no.evaluate(scope);
    };
    Conditional.prototype.accept = function accept(visitor) {
      visitor.visitConditional(this);
    };
    Conditional.prototype.connect = function connect(binding, scope) {
      this.condition.connect(binding, scope);
      if (this.condition.evaluate(scope)) {
        this.yes.connect(binding, scope);
      } else {
        this.no.connect(binding, scope);
      }
    };
    return Conditional;
  })(Expression);
  exports.Conditional = Conditional;
  var AccessThis = (function(_Expression6) {
    _inherits(AccessThis, _Expression6);
    function AccessThis(ancestor) {
      _classCallCheck(this, AccessThis);
      _Expression6.call(this);
      this.ancestor = ancestor;
    }
    AccessThis.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var oc = scope.overrideContext;
      var i = this.ancestor;
      while (i-- && oc) {
        oc = oc.parentOverrideContext;
      }
      return i < 1 && oc ? oc.bindingContext : undefined;
    };
    AccessThis.prototype.accept = function accept(visitor) {
      visitor.visitAccessThis(this);
    };
    AccessThis.prototype.connect = function connect(binding, scope) {};
    return AccessThis;
  })(Expression);
  exports.AccessThis = AccessThis;
  var AccessScope = (function(_Expression7) {
    _inherits(AccessScope, _Expression7);
    function AccessScope(name, ancestor) {
      _classCallCheck(this, AccessScope);
      _Expression7.call(this);
      this.name = name;
      this.ancestor = ancestor;
      this.isAssignable = true;
    }
    AccessScope.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var context = getContextFor(this.name, scope, this.ancestor);
      return context[this.name];
    };
    AccessScope.prototype.assign = function assign(scope, value) {
      var context = getContextFor(this.name, scope, this.ancestor);
      return context[this.name] = value;
    };
    AccessScope.prototype.accept = function accept(visitor) {
      visitor.visitAccessScope(this);
    };
    AccessScope.prototype.connect = function connect(binding, scope) {
      var context = getContextFor(this.name, scope, this.ancestor);
      binding.observeProperty(context, this.name);
    };
    return AccessScope;
  })(Expression);
  exports.AccessScope = AccessScope;
  var AccessMember = (function(_Expression8) {
    _inherits(AccessMember, _Expression8);
    function AccessMember(object, name) {
      _classCallCheck(this, AccessMember);
      _Expression8.call(this);
      this.object = object;
      this.name = name;
      this.isAssignable = true;
    }
    AccessMember.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var instance = this.object.evaluate(scope, lookupFunctions);
      return instance === null || instance === undefined ? instance : instance[this.name];
    };
    AccessMember.prototype.assign = function assign(scope, value) {
      var instance = this.object.evaluate(scope);
      if (instance === null || instance === undefined) {
        instance = {};
        this.object.assign(scope, instance);
      }
      return instance[this.name] = value;
    };
    AccessMember.prototype.accept = function accept(visitor) {
      visitor.visitAccessMember(this);
    };
    AccessMember.prototype.connect = function connect(binding, scope) {
      this.object.connect(binding, scope);
      var obj = this.object.evaluate(scope);
      if (obj) {
        binding.observeProperty(obj, this.name);
      }
    };
    return AccessMember;
  })(Expression);
  exports.AccessMember = AccessMember;
  var AccessKeyed = (function(_Expression9) {
    _inherits(AccessKeyed, _Expression9);
    function AccessKeyed(object, key) {
      _classCallCheck(this, AccessKeyed);
      _Expression9.call(this);
      this.object = object;
      this.key = key;
      this.isAssignable = true;
    }
    AccessKeyed.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var instance = this.object.evaluate(scope, lookupFunctions);
      var lookup = this.key.evaluate(scope, lookupFunctions);
      return getKeyed(instance, lookup);
    };
    AccessKeyed.prototype.assign = function assign(scope, value) {
      var instance = this.object.evaluate(scope);
      var lookup = this.key.evaluate(scope);
      return setKeyed(instance, lookup, value);
    };
    AccessKeyed.prototype.accept = function accept(visitor) {
      visitor.visitAccessKeyed(this);
    };
    AccessKeyed.prototype.connect = function connect(binding, scope) {
      this.object.connect(binding, scope);
      var obj = this.object.evaluate(scope);
      if (obj instanceof Object) {
        this.key.connect(binding, scope);
        var key = this.key.evaluate(scope);
        if (key !== null && key !== undefined) {
          binding.observeProperty(obj, key);
        }
      }
    };
    return AccessKeyed;
  })(Expression);
  exports.AccessKeyed = AccessKeyed;
  var CallScope = (function(_Expression10) {
    _inherits(CallScope, _Expression10);
    function CallScope(name, args, ancestor) {
      _classCallCheck(this, CallScope);
      _Expression10.call(this);
      this.name = name;
      this.args = args;
      this.ancestor = ancestor;
    }
    CallScope.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
      var args = evalList(scope, this.args, lookupFunctions);
      var context = getContextFor(this.name, scope, this.ancestor);
      var func = getFunction(context, this.name, mustEvaluate);
      if (func) {
        return func.apply(context, args);
      }
      return undefined;
    };
    CallScope.prototype.accept = function accept(visitor) {
      visitor.visitCallScope(this);
    };
    CallScope.prototype.connect = function connect(binding, scope) {
      var args = this.args;
      var i = args.length;
      while (i--) {
        args[i].connect(binding, scope);
      }
    };
    return CallScope;
  })(Expression);
  exports.CallScope = CallScope;
  var CallMember = (function(_Expression11) {
    _inherits(CallMember, _Expression11);
    function CallMember(object, name, args) {
      _classCallCheck(this, CallMember);
      _Expression11.call(this);
      this.object = object;
      this.name = name;
      this.args = args;
    }
    CallMember.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
      var instance = this.object.evaluate(scope, lookupFunctions);
      var args = evalList(scope, this.args, lookupFunctions);
      var func = getFunction(instance, this.name, mustEvaluate);
      if (func) {
        return func.apply(instance, args);
      }
      return undefined;
    };
    CallMember.prototype.accept = function accept(visitor) {
      visitor.visitCallMember(this);
    };
    CallMember.prototype.connect = function connect(binding, scope) {
      this.object.connect(binding, scope);
      var obj = this.object.evaluate(scope);
      if (getFunction(obj, this.name, false)) {
        var args = this.args;
        var i = args.length;
        while (i--) {
          args[i].connect(binding, scope);
        }
      }
    };
    return CallMember;
  })(Expression);
  exports.CallMember = CallMember;
  var CallFunction = (function(_Expression12) {
    _inherits(CallFunction, _Expression12);
    function CallFunction(func, args) {
      _classCallCheck(this, CallFunction);
      _Expression12.call(this);
      this.func = func;
      this.args = args;
    }
    CallFunction.prototype.evaluate = function evaluate(scope, lookupFunctions, mustEvaluate) {
      var func = this.func.evaluate(scope, lookupFunctions);
      if (typeof func === 'function') {
        return func.apply(null, evalList(scope, this.args, lookupFunctions));
      }
      if (!mustEvaluate && (func === null || func === undefined)) {
        return undefined;
      }
      throw new Error(this.func + ' is not a function');
    };
    CallFunction.prototype.accept = function accept(visitor) {
      visitor.visitCallFunction(this);
    };
    CallFunction.prototype.connect = function connect(binding, scope) {
      this.func.connect(binding, scope);
      var func = this.func.evaluate(scope);
      if (typeof func === 'function') {
        var args = this.args;
        var i = args.length;
        while (i--) {
          args[i].connect(binding, scope);
        }
      }
    };
    return CallFunction;
  })(Expression);
  exports.CallFunction = CallFunction;
  var Binary = (function(_Expression13) {
    _inherits(Binary, _Expression13);
    function Binary(operation, left, right) {
      _classCallCheck(this, Binary);
      _Expression13.call(this);
      this.operation = operation;
      this.left = left;
      this.right = right;
    }
    Binary.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var left = this.left.evaluate(scope);
      switch (this.operation) {
        case '&&':
          return left && this.right.evaluate(scope);
        case '||':
          return left || this.right.evaluate(scope);
      }
      var right = this.right.evaluate(scope);
      switch (this.operation) {
        case '==':
          return left == right;
        case '===':
          return left === right;
        case '!=':
          return left != right;
        case '!==':
          return left !== right;
      }
      if (left === null || right === null) {
        switch (this.operation) {
          case '+':
            if (left != null)
              return left;
            if (right != null)
              return right;
            return 0;
          case '-':
            if (left != null)
              return left;
            if (right != null)
              return 0 - right;
            return 0;
        }
        return null;
      }
      switch (this.operation) {
        case '+':
          return autoConvertAdd(left, right);
        case '-':
          return left - right;
        case '*':
          return left * right;
        case '/':
          return left / right;
        case '%':
          return left % right;
        case '<':
          return left < right;
        case '>':
          return left > right;
        case '<=':
          return left <= right;
        case '>=':
          return left >= right;
        case '^':
          return left ^ right;
      }
      throw new Error('Internal error [' + this.operation + '] not handled');
    };
    Binary.prototype.accept = function accept(visitor) {
      visitor.visitBinary(this);
    };
    Binary.prototype.connect = function connect(binding, scope) {
      this.left.connect(binding, scope);
      var left = this.left.evaluate(scope);
      if (this.operation === '&&' && !left || this.operation === '||' && left) {
        return;
      }
      this.right.connect(binding, scope);
    };
    return Binary;
  })(Expression);
  exports.Binary = Binary;
  var PrefixNot = (function(_Expression14) {
    _inherits(PrefixNot, _Expression14);
    function PrefixNot(operation, expression) {
      _classCallCheck(this, PrefixNot);
      _Expression14.call(this);
      this.operation = operation;
      this.expression = expression;
    }
    PrefixNot.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return !this.expression.evaluate(scope);
    };
    PrefixNot.prototype.accept = function accept(visitor) {
      visitor.visitPrefix(this);
    };
    PrefixNot.prototype.connect = function connect(binding, scope) {
      this.expression.connect(binding, scope);
    };
    return PrefixNot;
  })(Expression);
  exports.PrefixNot = PrefixNot;
  var LiteralPrimitive = (function(_Expression15) {
    _inherits(LiteralPrimitive, _Expression15);
    function LiteralPrimitive(value) {
      _classCallCheck(this, LiteralPrimitive);
      _Expression15.call(this);
      this.value = value;
    }
    LiteralPrimitive.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.value;
    };
    LiteralPrimitive.prototype.accept = function accept(visitor) {
      visitor.visitLiteralPrimitive(this);
    };
    LiteralPrimitive.prototype.connect = function connect(binding, scope) {};
    return LiteralPrimitive;
  })(Expression);
  exports.LiteralPrimitive = LiteralPrimitive;
  var LiteralString = (function(_Expression16) {
    _inherits(LiteralString, _Expression16);
    function LiteralString(value) {
      _classCallCheck(this, LiteralString);
      _Expression16.call(this);
      this.value = value;
    }
    LiteralString.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      return this.value;
    };
    LiteralString.prototype.accept = function accept(visitor) {
      visitor.visitLiteralString(this);
    };
    LiteralString.prototype.connect = function connect(binding, scope) {};
    return LiteralString;
  })(Expression);
  exports.LiteralString = LiteralString;
  var LiteralArray = (function(_Expression17) {
    _inherits(LiteralArray, _Expression17);
    function LiteralArray(elements) {
      _classCallCheck(this, LiteralArray);
      _Expression17.call(this);
      this.elements = elements;
    }
    LiteralArray.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var elements = this.elements,
          length = elements.length,
          result = [],
          i;
      for (i = 0; i < length; ++i) {
        result[i] = elements[i].evaluate(scope, lookupFunctions);
      }
      return result;
    };
    LiteralArray.prototype.accept = function accept(visitor) {
      visitor.visitLiteralArray(this);
    };
    LiteralArray.prototype.connect = function connect(binding, scope) {
      var length = this.elements.length;
      for (var i = 0; i < length; i++) {
        this.elements[i].connect(binding, scope);
      }
    };
    return LiteralArray;
  })(Expression);
  exports.LiteralArray = LiteralArray;
  var LiteralObject = (function(_Expression18) {
    _inherits(LiteralObject, _Expression18);
    function LiteralObject(keys, values) {
      _classCallCheck(this, LiteralObject);
      _Expression18.call(this);
      this.keys = keys;
      this.values = values;
    }
    LiteralObject.prototype.evaluate = function evaluate(scope, lookupFunctions) {
      var instance = {},
          keys = this.keys,
          values = this.values,
          length = keys.length,
          i;
      for (i = 0; i < length; ++i) {
        instance[keys[i]] = values[i].evaluate(scope, lookupFunctions);
      }
      return instance;
    };
    LiteralObject.prototype.accept = function accept(visitor) {
      visitor.visitLiteralObject(this);
    };
    LiteralObject.prototype.connect = function connect(binding, scope) {
      var length = this.keys.length;
      for (var i = 0; i < length; i++) {
        this.values[i].connect(binding, scope);
      }
    };
    return LiteralObject;
  })(Expression);
  exports.LiteralObject = LiteralObject;
  var Unparser = (function() {
    function Unparser(buffer) {
      _classCallCheck(this, Unparser);
      this.buffer = buffer;
    }
    Unparser.unparse = function unparse(expression) {
      var buffer = [],
          visitor = new Unparser(buffer);
      expression.accept(visitor);
      return buffer.join('');
    };
    Unparser.prototype.write = function write(text) {
      this.buffer.push(text);
    };
    Unparser.prototype.writeArgs = function writeArgs(args) {
      var i,
          length;
      this.write('(');
      for (i = 0, length = args.length; i < length; ++i) {
        if (i !== 0) {
          this.write(',');
        }
        args[i].accept(this);
      }
      this.write(')');
    };
    Unparser.prototype.visitChain = function visitChain(chain) {
      var expressions = chain.expressions,
          length = expressions.length,
          i;
      for (i = 0; i < length; ++i) {
        if (i !== 0) {
          this.write(';');
        }
        expressions[i].accept(this);
      }
    };
    Unparser.prototype.visitBindingBehavior = function visitBindingBehavior(behavior) {
      var args = behavior.args,
          length = args.length,
          i;
      this.write('(');
      behavior.expression.accept(this);
      this.write('&' + behavior.name);
      for (i = 0; i < length; ++i) {
        this.write(' :');
        args[i].accept(this);
      }
      this.write(')');
    };
    Unparser.prototype.visitValueConverter = function visitValueConverter(converter) {
      var args = converter.args,
          length = args.length,
          i;
      this.write('(');
      converter.expression.accept(this);
      this.write('|' + converter.name);
      for (i = 0; i < length; ++i) {
        this.write(' :');
        args[i].accept(this);
      }
      this.write(')');
    };
    Unparser.prototype.visitAssign = function visitAssign(assign) {
      assign.target.accept(this);
      this.write('=');
      assign.value.accept(this);
    };
    Unparser.prototype.visitConditional = function visitConditional(conditional) {
      conditional.condition.accept(this);
      this.write('?');
      conditional.yes.accept(this);
      this.write(':');
      conditional.no.accept(this);
    };
    Unparser.prototype.visitAccessThis = function visitAccessThis(access) {
      if (access.ancestor === 0) {
        this.write('$this');
        return;
      }
      this.write('$parent');
      var i = access.ancestor - 1;
      while (i--) {
        this.write('.$parent');
      }
    };
    Unparser.prototype.visitAccessScope = function visitAccessScope(access) {
      var i = access.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(access.name);
    };
    Unparser.prototype.visitAccessMember = function visitAccessMember(access) {
      access.object.accept(this);
      this.write('.' + access.name);
    };
    Unparser.prototype.visitAccessKeyed = function visitAccessKeyed(access) {
      access.object.accept(this);
      this.write('[');
      access.key.accept(this);
      this.write(']');
    };
    Unparser.prototype.visitCallScope = function visitCallScope(call) {
      var i = call.ancestor;
      while (i--) {
        this.write('$parent.');
      }
      this.write(call.name);
      this.writeArgs(call.args);
    };
    Unparser.prototype.visitCallFunction = function visitCallFunction(call) {
      call.func.accept(this);
      this.writeArgs(call.args);
    };
    Unparser.prototype.visitCallMember = function visitCallMember(call) {
      call.object.accept(this);
      this.write('.' + call.name);
      this.writeArgs(call.args);
    };
    Unparser.prototype.visitPrefix = function visitPrefix(prefix) {
      this.write('(' + prefix.operation);
      prefix.expression.accept(this);
      this.write(')');
    };
    Unparser.prototype.visitBinary = function visitBinary(binary) {
      this.write('(');
      binary.left.accept(this);
      this.write(binary.operation);
      binary.right.accept(this);
      this.write(')');
    };
    Unparser.prototype.visitLiteralPrimitive = function visitLiteralPrimitive(literal) {
      this.write('' + literal.value);
    };
    Unparser.prototype.visitLiteralArray = function visitLiteralArray(literal) {
      var elements = literal.elements,
          length = elements.length,
          i;
      this.write('[');
      for (i = 0; i < length; ++i) {
        if (i !== 0) {
          this.write(',');
        }
        elements[i].accept(this);
      }
      this.write(']');
    };
    Unparser.prototype.visitLiteralObject = function visitLiteralObject(literal) {
      var keys = literal.keys,
          values = literal.values,
          length = keys.length,
          i;
      this.write('{');
      for (i = 0; i < length; ++i) {
        if (i !== 0) {
          this.write(',');
        }
        this.write('\'' + keys[i] + '\':');
        values[i].accept(this);
      }
      this.write('}');
    };
    Unparser.prototype.visitLiteralString = function visitLiteralString(literal) {
      var escaped = literal.value.replace(/'/g, "\'");
      this.write('\'' + escaped + '\'');
    };
    return Unparser;
  })();
  exports.Unparser = Unparser;
  var evalListCache = [[], [0], [0, 0], [0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0, 0]];
  function evalList(scope, list, lookupFunctions) {
    var length = list.length,
        cacheLength,
        i;
    for (cacheLength = evalListCache.length; cacheLength <= length; ++cacheLength) {
      evalListCache.push([]);
    }
    var result = evalListCache[length];
    for (i = 0; i < length; ++i) {
      result[i] = list[i].evaluate(scope, lookupFunctions);
    }
    return result;
  }
  function autoConvertAdd(a, b) {
    if (a != null && b != null) {
      if (typeof a == 'string' && typeof b != 'string') {
        return a + b.toString();
      }
      if (typeof a != 'string' && typeof b == 'string') {
        return a.toString() + b;
      }
      return a + b;
    }
    if (a != null) {
      return a;
    }
    if (b != null) {
      return b;
    }
    return 0;
  }
  function getFunction(obj, name, mustExist) {
    var func = obj === null || obj === undefined ? null : obj[name];
    if (typeof func === 'function') {
      return func;
    }
    if (!mustExist && (func === null || func === undefined)) {
      return null;
    }
    throw new Error(name + ' is not a function');
  }
  function getKeyed(obj, key) {
    if (Array.isArray(obj)) {
      return obj[parseInt(key)];
    } else if (obj) {
      return obj[key];
    } else if (obj === null || obj === undefined) {
      return undefined;
    } else {
      return obj[key];
    }
  }
  function setKeyed(obj, key, value) {
    if (Array.isArray(obj)) {
      var index = parseInt(key);
      if (obj.length <= index) {
        obj.length = index + 1;
      }
      obj[index] = value;
    } else {
      obj[key] = value;
    }
    return value;
  }
  var bindingMode = {
    oneTime: 0,
    oneWay: 1,
    twoWay: 2
  };
  exports.bindingMode = bindingMode;
  var Token = (function() {
    function Token(index, text) {
      _classCallCheck(this, Token);
      this.index = index;
      this.text = text;
    }
    Token.prototype.withOp = function withOp(op) {
      this.opKey = op;
      return this;
    };
    Token.prototype.withGetterSetter = function withGetterSetter(key) {
      this.key = key;
      return this;
    };
    Token.prototype.withValue = function withValue(value) {
      this.value = value;
      return this;
    };
    Token.prototype.toString = function toString() {
      return 'Token(' + this.text + ')';
    };
    return Token;
  })();
  exports.Token = Token;
  var Lexer = (function() {
    function Lexer() {
      _classCallCheck(this, Lexer);
    }
    Lexer.prototype.lex = function lex(text) {
      var scanner = new Scanner(text);
      var tokens = [];
      var token = scanner.scanToken();
      while (token) {
        tokens.push(token);
        token = scanner.scanToken();
      }
      return tokens;
    };
    return Lexer;
  })();
  exports.Lexer = Lexer;
  var Scanner = (function() {
    function Scanner(input) {
      _classCallCheck(this, Scanner);
      this.input = input;
      this.length = input.length;
      this.peek = 0;
      this.index = -1;
      this.advance();
    }
    Scanner.prototype.scanToken = function scanToken() {
      while (this.peek <= $SPACE) {
        if (++this.index >= this.length) {
          this.peek = $EOF;
          return null;
        } else {
          this.peek = this.input.charCodeAt(this.index);
        }
      }
      if (isIdentifierStart(this.peek)) {
        return this.scanIdentifier();
      }
      if (isDigit(this.peek)) {
        return this.scanNumber(this.index);
      }
      var start = this.index;
      switch (this.peek) {
        case $PERIOD:
          this.advance();
          return isDigit(this.peek) ? this.scanNumber(start) : new Token(start, '.');
        case $LPAREN:
        case $RPAREN:
        case $LBRACE:
        case $RBRACE:
        case $LBRACKET:
        case $RBRACKET:
        case $COMMA:
        case $COLON:
        case $SEMICOLON:
          return this.scanCharacter(start, String.fromCharCode(this.peek));
        case $SQ:
        case $DQ:
          return this.scanString();
        case $PLUS:
        case $MINUS:
        case $STAR:
        case $SLASH:
        case $PERCENT:
        case $CARET:
        case $QUESTION:
          return this.scanOperator(start, String.fromCharCode(this.peek));
        case $LT:
        case $GT:
        case $BANG:
        case $EQ:
          return this.scanComplexOperator(start, $EQ, String.fromCharCode(this.peek), '=');
        case $AMPERSAND:
          return this.scanComplexOperator(start, $AMPERSAND, '&', '&');
        case $BAR:
          return this.scanComplexOperator(start, $BAR, '|', '|');
        case $NBSP:
          while (isWhitespace(this.peek)) {
            this.advance();
          }
          return this.scanToken();
      }
      var character = String.fromCharCode(this.peek);
      this.error('Unexpected character [' + character + ']');
      return null;
    };
    Scanner.prototype.scanCharacter = function scanCharacter(start, text) {
      assert(this.peek === text.charCodeAt(0));
      this.advance();
      return new Token(start, text);
    };
    Scanner.prototype.scanOperator = function scanOperator(start, text) {
      assert(this.peek === text.charCodeAt(0));
      assert(OPERATORS.indexOf(text) !== -1);
      this.advance();
      return new Token(start, text).withOp(text);
    };
    Scanner.prototype.scanComplexOperator = function scanComplexOperator(start, code, one, two) {
      assert(this.peek === one.charCodeAt(0));
      this.advance();
      var text = one;
      if (this.peek === code) {
        this.advance();
        text += two;
      }
      if (this.peek === code) {
        this.advance();
        text += two;
      }
      assert(OPERATORS.indexOf(text) != -1);
      return new Token(start, text).withOp(text);
    };
    Scanner.prototype.scanIdentifier = function scanIdentifier() {
      assert(isIdentifierStart(this.peek));
      var start = this.index;
      this.advance();
      while (isIdentifierPart(this.peek)) {
        this.advance();
      }
      var text = this.input.substring(start, this.index);
      var result = new Token(start, text);
      if (OPERATORS.indexOf(text) !== -1) {
        result.withOp(text);
      } else {
        result.withGetterSetter(text);
      }
      return result;
    };
    Scanner.prototype.scanNumber = function scanNumber(start) {
      assert(isDigit(this.peek));
      var simple = this.index === start;
      this.advance();
      while (true) {
        if (isDigit(this.peek)) {} else if (this.peek === $PERIOD) {
          simple = false;
        } else if (isExponentStart(this.peek)) {
          this.advance();
          if (isExponentSign(this.peek)) {
            this.advance();
          }
          if (!isDigit(this.peek)) {
            this.error('Invalid exponent', -1);
          }
          simple = false;
        } else {
          break;
        }
        this.advance();
      }
      var text = this.input.substring(start, this.index);
      var value = simple ? parseInt(text) : parseFloat(text);
      return new Token(start, text).withValue(value);
    };
    Scanner.prototype.scanString = function scanString() {
      assert(this.peek === $SQ || this.peek === $DQ);
      var start = this.index;
      var quote = this.peek;
      this.advance();
      var buffer = undefined;
      var marker = this.index;
      while (this.peek !== quote) {
        if (this.peek === $BACKSLASH) {
          if (!buffer) {
            buffer = [];
          }
          buffer.push(this.input.substring(marker, this.index));
          this.advance();
          var _unescaped = undefined;
          if (this.peek === $u) {
            var hex = this.input.substring(this.index + 1, this.index + 5);
            if (!/[A-Z0-9]{4}/.test(hex)) {
              this.error('Invalid unicode escape [\\u' + hex + ']');
            }
            _unescaped = parseInt(hex, 16);
            for (var i = 0; i < 5; ++i) {
              this.advance();
            }
          } else {
            _unescaped = unescape(this.peek);
            this.advance();
          }
          buffer.push(String.fromCharCode(_unescaped));
          marker = this.index;
        } else if (this.peek === $EOF) {
          this.error('Unterminated quote');
        } else {
          this.advance();
        }
      }
      var last = this.input.substring(marker, this.index);
      this.advance();
      var text = this.input.substring(start, this.index);
      var unescaped = last;
      if (buffer != null) {
        buffer.push(last);
        unescaped = buffer.join('');
      }
      return new Token(start, text).withValue(unescaped);
    };
    Scanner.prototype.advance = function advance() {
      if (++this.index >= this.length) {
        this.peek = $EOF;
      } else {
        this.peek = this.input.charCodeAt(this.index);
      }
    };
    Scanner.prototype.error = function error(message) {
      var offset = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
      var position = this.index + offset;
      throw new Error('Lexer Error: ' + message + ' at column ' + position + ' in expression [' + this.input + ']');
    };
    return Scanner;
  })();
  exports.Scanner = Scanner;
  var OPERATORS = ['undefined', 'null', 'true', 'false', '+', '-', '*', '/', '%', '^', '=', '==', '===', '!=', '!==', '<', '>', '<=', '>=', '&&', '||', '&', '|', '!', '?'];
  var $EOF = 0;
  var $TAB = 9;
  var $LF = 10;
  var $VTAB = 11;
  var $FF = 12;
  var $CR = 13;
  var $SPACE = 32;
  var $BANG = 33;
  var $DQ = 34;
  var $$ = 36;
  var $PERCENT = 37;
  var $AMPERSAND = 38;
  var $SQ = 39;
  var $LPAREN = 40;
  var $RPAREN = 41;
  var $STAR = 42;
  var $PLUS = 43;
  var $COMMA = 44;
  var $MINUS = 45;
  var $PERIOD = 46;
  var $SLASH = 47;
  var $COLON = 58;
  var $SEMICOLON = 59;
  var $LT = 60;
  var $EQ = 61;
  var $GT = 62;
  var $QUESTION = 63;
  var $0 = 48;
  var $9 = 57;
  var $A = 65;
  var $E = 69;
  var $Z = 90;
  var $LBRACKET = 91;
  var $BACKSLASH = 92;
  var $RBRACKET = 93;
  var $CARET = 94;
  var $_ = 95;
  var $a = 97;
  var $e = 101;
  var $f = 102;
  var $n = 110;
  var $r = 114;
  var $t = 116;
  var $u = 117;
  var $v = 118;
  var $z = 122;
  var $LBRACE = 123;
  var $BAR = 124;
  var $RBRACE = 125;
  var $NBSP = 160;
  function isWhitespace(code) {
    return code >= $TAB && code <= $SPACE || code === $NBSP;
  }
  function isIdentifierStart(code) {
    return $a <= code && code <= $z || $A <= code && code <= $Z || code === $_ || code === $$;
  }
  function isIdentifierPart(code) {
    return $a <= code && code <= $z || $A <= code && code <= $Z || $0 <= code && code <= $9 || code === $_ || code === $$;
  }
  function isDigit(code) {
    return $0 <= code && code <= $9;
  }
  function isExponentStart(code) {
    return code === $e || code === $E;
  }
  function isExponentSign(code) {
    return code === $MINUS || code === $PLUS;
  }
  function unescape(code) {
    switch (code) {
      case $n:
        return $LF;
      case $f:
        return $FF;
      case $r:
        return $CR;
      case $t:
        return $TAB;
      case $v:
        return $VTAB;
      default:
        return code;
    }
  }
  function assert(condition, message) {
    if (!condition) {
      throw message || "Assertion failed";
    }
  }
  var EOF = new Token(-1, null);
  var Parser = (function() {
    function Parser() {
      _classCallCheck(this, Parser);
      this.cache = {};
      this.lexer = new Lexer();
    }
    Parser.prototype.parse = function parse(input) {
      input = input || '';
      return this.cache[input] || (this.cache[input] = new ParserImplementation(this.lexer, input).parseChain());
    };
    return Parser;
  })();
  exports.Parser = Parser;
  var ParserImplementation = (function() {
    function ParserImplementation(lexer, input) {
      _classCallCheck(this, ParserImplementation);
      this.index = 0;
      this.input = input;
      this.tokens = lexer.lex(input);
    }
    ParserImplementation.prototype.parseChain = function parseChain() {
      var isChain = false;
      var expressions = [];
      while (this.optional(';')) {
        isChain = true;
      }
      while (this.index < this.tokens.length) {
        if (this.peek.text === ')' || this.peek.text === '}' || this.peek.text === ']') {
          this.error('Unconsumed token ' + this.peek.text);
        }
        var expr = this.parseBindingBehavior();
        expressions.push(expr);
        while (this.optional(';')) {
          isChain = true;
        }
        if (isChain) {
          this.error('Multiple expressions are not allowed.');
        }
      }
      return expressions.length === 1 ? expressions[0] : new Chain(expressions);
    };
    ParserImplementation.prototype.parseBindingBehavior = function parseBindingBehavior() {
      var result = this.parseValueConverter();
      while (this.optional('&')) {
        var _name = this.peek.text;
        var args = [];
        this.advance();
        while (this.optional(':')) {
          args.push(this.parseExpression());
        }
        result = new BindingBehavior(result, _name, args);
      }
      return result;
    };
    ParserImplementation.prototype.parseValueConverter = function parseValueConverter() {
      var result = this.parseExpression();
      while (this.optional('|')) {
        var _name2 = this.peek.text;
        var args = [];
        this.advance();
        while (this.optional(':')) {
          args.push(this.parseExpression());
        }
        result = new ValueConverter(result, _name2, args, [result].concat(args));
      }
      return result;
    };
    ParserImplementation.prototype.parseExpression = function parseExpression() {
      var start = this.peek.index;
      var result = this.parseConditional();
      while (this.peek.text === '=') {
        if (!result.isAssignable) {
          var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
          var expression = this.input.substring(start, end);
          this.error('Expression ' + expression + ' is not assignable');
        }
        this.expect('=');
        result = new Assign(result, this.parseConditional());
      }
      return result;
    };
    ParserImplementation.prototype.parseConditional = function parseConditional() {
      var start = this.peek.index;
      var result = this.parseLogicalOr();
      if (this.optional('?')) {
        var yes = this.parseExpression();
        if (!this.optional(':')) {
          var end = this.index < this.tokens.length ? this.peek.index : this.input.length;
          var expression = this.input.substring(start, end);
          this.error('Conditional expression ' + expression + ' requires all 3 expressions');
        }
        var no = this.parseExpression();
        result = new Conditional(result, yes, no);
      }
      return result;
    };
    ParserImplementation.prototype.parseLogicalOr = function parseLogicalOr() {
      var result = this.parseLogicalAnd();
      while (this.optional('||')) {
        result = new Binary('||', result, this.parseLogicalAnd());
      }
      return result;
    };
    ParserImplementation.prototype.parseLogicalAnd = function parseLogicalAnd() {
      var result = this.parseEquality();
      while (this.optional('&&')) {
        result = new Binary('&&', result, this.parseEquality());
      }
      return result;
    };
    ParserImplementation.prototype.parseEquality = function parseEquality() {
      var result = this.parseRelational();
      while (true) {
        if (this.optional('==')) {
          result = new Binary('==', result, this.parseRelational());
        } else if (this.optional('!=')) {
          result = new Binary('!=', result, this.parseRelational());
        } else if (this.optional('===')) {
          result = new Binary('===', result, this.parseRelational());
        } else if (this.optional('!==')) {
          result = new Binary('!==', result, this.parseRelational());
        } else {
          return result;
        }
      }
    };
    ParserImplementation.prototype.parseRelational = function parseRelational() {
      var result = this.parseAdditive();
      while (true) {
        if (this.optional('<')) {
          result = new Binary('<', result, this.parseAdditive());
        } else if (this.optional('>')) {
          result = new Binary('>', result, this.parseAdditive());
        } else if (this.optional('<=')) {
          result = new Binary('<=', result, this.parseAdditive());
        } else if (this.optional('>=')) {
          result = new Binary('>=', result, this.parseAdditive());
        } else {
          return result;
        }
      }
    };
    ParserImplementation.prototype.parseAdditive = function parseAdditive() {
      var result = this.parseMultiplicative();
      while (true) {
        if (this.optional('+')) {
          result = new Binary('+', result, this.parseMultiplicative());
        } else if (this.optional('-')) {
          result = new Binary('-', result, this.parseMultiplicative());
        } else {
          return result;
        }
      }
    };
    ParserImplementation.prototype.parseMultiplicative = function parseMultiplicative() {
      var result = this.parsePrefix();
      while (true) {
        if (this.optional('*')) {
          result = new Binary('*', result, this.parsePrefix());
        } else if (this.optional('%')) {
          result = new Binary('%', result, this.parsePrefix());
        } else if (this.optional('/')) {
          result = new Binary('/', result, this.parsePrefix());
        } else {
          return result;
        }
      }
    };
    ParserImplementation.prototype.parsePrefix = function parsePrefix() {
      if (this.optional('+')) {
        return this.parsePrefix();
      } else if (this.optional('-')) {
        return new Binary('-', new LiteralPrimitive(0), this.parsePrefix());
      } else if (this.optional('!')) {
        return new PrefixNot('!', this.parsePrefix());
      } else {
        return this.parseAccessOrCallMember();
      }
    };
    ParserImplementation.prototype.parseAccessOrCallMember = function parseAccessOrCallMember() {
      var result = this.parsePrimary();
      while (true) {
        if (this.optional('.')) {
          var _name3 = this.peek.text;
          this.advance();
          if (this.optional('(')) {
            var args = this.parseExpressionList(')');
            this.expect(')');
            if (result instanceof AccessThis) {
              result = new CallScope(_name3, args, result.ancestor);
            } else {
              result = new CallMember(result, _name3, args);
            }
          } else {
            if (result instanceof AccessThis) {
              result = new AccessScope(_name3, result.ancestor);
            } else {
              result = new AccessMember(result, _name3);
            }
          }
        } else if (this.optional('[')) {
          var key = this.parseExpression();
          this.expect(']');
          result = new AccessKeyed(result, key);
        } else if (this.optional('(')) {
          var args = this.parseExpressionList(')');
          this.expect(')');
          result = new CallFunction(result, args);
        } else {
          return result;
        }
      }
    };
    ParserImplementation.prototype.parsePrimary = function parsePrimary() {
      if (this.optional('(')) {
        var result = this.parseExpression();
        this.expect(')');
        return result;
      } else if (this.optional('null')) {
        return new LiteralPrimitive(null);
      } else if (this.optional('undefined')) {
        return new LiteralPrimitive(undefined);
      } else if (this.optional('true')) {
        return new LiteralPrimitive(true);
      } else if (this.optional('false')) {
        return new LiteralPrimitive(false);
      } else if (this.optional('[')) {
        var _elements = this.parseExpressionList(']');
        this.expect(']');
        return new LiteralArray(_elements);
      } else if (this.peek.text == '{') {
        return this.parseObject();
      } else if (this.peek.key != null) {
        return this.parseAccessOrCallScope();
      } else if (this.peek.value != null) {
        var value = this.peek.value;
        this.advance();
        return value instanceof String || typeof value === 'string' ? new LiteralString(value) : new LiteralPrimitive(value);
      } else if (this.index >= this.tokens.length) {
        throw new Error('Unexpected end of expression: ' + this.input);
      } else {
        this.error('Unexpected token ' + this.peek.text);
      }
    };
    ParserImplementation.prototype.parseAccessOrCallScope = function parseAccessOrCallScope() {
      var name = this.peek.key;
      this.advance();
      if (name === '$this') {
        return new AccessThis(0);
      }
      var ancestor = 0;
      while (name === '$parent') {
        ancestor++;
        if (this.optional('.')) {
          name = this.peek.key;
          this.advance();
        } else if (this.peek === EOF || this.peek.text === '(' || this.peek.text === '[' || this.peek.text === '}') {
          return new AccessThis(ancestor);
        } else {
          this.error('Unexpected token ' + this.peek.text);
        }
      }
      if (this.optional('(')) {
        var args = this.parseExpressionList(')');
        this.expect(')');
        return new CallScope(name, args, ancestor);
      }
      return new AccessScope(name, ancestor);
    };
    ParserImplementation.prototype.parseObject = function parseObject() {
      var keys = [];
      var values = [];
      this.expect('{');
      if (this.peek.text !== '}') {
        do {
          var value = this.peek.value;
          keys.push(typeof value === 'string' ? value : this.peek.text);
          this.advance();
          this.expect(':');
          values.push(this.parseExpression());
        } while (this.optional(','));
      }
      this.expect('}');
      return new LiteralObject(keys, values);
    };
    ParserImplementation.prototype.parseExpressionList = function parseExpressionList(terminator) {
      var result = [];
      if (this.peek.text != terminator) {
        do {
          result.push(this.parseExpression());
        } while (this.optional(','));
      }
      return result;
    };
    ParserImplementation.prototype.optional = function optional(text) {
      if (this.peek.text === text) {
        this.advance();
        return true;
      }
      return false;
    };
    ParserImplementation.prototype.expect = function expect(text) {
      if (this.peek.text === text) {
        this.advance();
      } else {
        this.error('Missing expected ' + text);
      }
    };
    ParserImplementation.prototype.advance = function advance() {
      this.index++;
    };
    ParserImplementation.prototype.error = function error(message) {
      var location = this.index < this.tokens.length ? 'at column ' + (this.tokens[this.index].index + 1) + ' in' : 'at the end of the expression';
      throw new Error('Parser Error: ' + message + ' ' + location + ' [' + this.input + ']');
    };
    _createClass(ParserImplementation, [{
      key: 'peek',
      get: function get() {
        return this.index < this.tokens.length ? this.tokens[this.index] : EOF;
      }
    }]);
    return ParserImplementation;
  })();
  exports.ParserImplementation = ParserImplementation;
  var mapProto = Map.prototype;
  function _getMapObserver(taskQueue, map) {
    return ModifyMapObserver.create(taskQueue, map);
  }
  var ModifyMapObserver = (function(_ModifyCollectionObserver3) {
    _inherits(ModifyMapObserver, _ModifyCollectionObserver3);
    function ModifyMapObserver(taskQueue, map) {
      _classCallCheck(this, ModifyMapObserver);
      _ModifyCollectionObserver3.call(this, taskQueue, map);
    }
    ModifyMapObserver.create = function create(taskQueue, map) {
      var observer = new ModifyMapObserver(taskQueue, map);
      map['set'] = function() {
        var oldValue = map.get(arguments[0]);
        var type = typeof oldValue !== 'undefined' ? 'update' : 'add';
        var methodCallResult = mapProto['set'].apply(map, arguments);
        observer.addChangeRecord({
          type: type,
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
        return methodCallResult;
      };
      map['delete'] = function() {
        var oldValue = map.get(arguments[0]);
        var methodCallResult = mapProto['delete'].apply(map, arguments);
        observer.addChangeRecord({
          type: 'delete',
          object: map,
          key: arguments[0],
          oldValue: oldValue
        });
        return methodCallResult;
      };
      map['clear'] = function() {
        var methodCallResult = mapProto['clear'].apply(map, arguments);
        observer.addChangeRecord({
          type: 'clear',
          object: map
        });
        return methodCallResult;
      };
      return observer;
    };
    return ModifyMapObserver;
  })(ModifyCollectionObserver);
  function findOriginalEventTarget(event) {
    return event.path && event.path[0] || event.deepPath && event.deepPath[0] || event.target;
  }
  function handleDelegatedEvent(event) {
    var target = findOriginalEventTarget(event);
    var callback = undefined;
    while (target && !callback) {
      if (target.delegatedCallbacks) {
        callback = target.delegatedCallbacks[event.type];
      }
      if (!callback) {
        target = target.parentNode;
      }
    }
    if (callback) {
      callback(event);
    }
  }
  var DelegateHandlerEntry = (function() {
    function DelegateHandlerEntry(eventName) {
      _classCallCheck(this, DelegateHandlerEntry);
      this.eventName = eventName;
      this.count = 0;
    }
    DelegateHandlerEntry.prototype.increment = function increment() {
      this.count++;
      if (this.count === 1) {
        _aureliaPal.DOM.addEventListener(this.eventName, handleDelegatedEvent, false);
      }
    };
    DelegateHandlerEntry.prototype.decrement = function decrement() {
      this.count--;
      if (this.count === 0) {
        _aureliaPal.DOM.removeEventListener(this.eventName, handleDelegatedEvent);
      }
    };
    return DelegateHandlerEntry;
  })();
  var DefaultEventStrategy = (function() {
    function DefaultEventStrategy() {
      _classCallCheck(this, DefaultEventStrategy);
      this.delegatedHandlers = [];
    }
    DefaultEventStrategy.prototype.subscribe = function subscribe(target, targetEvent, callback, delegate) {
      var _this = this;
      if (delegate) {
        var _ret = (function() {
          var delegatedHandlers = _this.delegatedHandlers;
          var handlerEntry = delegatedHandlers[targetEvent] || (delegatedHandlers[targetEvent] = new DelegateHandlerEntry(targetEvent));
          var delegatedCallbacks = target.delegatedCallbacks || (target.delegatedCallbacks = {});
          handlerEntry.increment();
          delegatedCallbacks[targetEvent] = callback;
          return {v: function() {
              handlerEntry.decrement();
              delegatedCallbacks[targetEvent] = null;
            }};
        })();
        if (typeof _ret === 'object')
          return _ret.v;
      } else {
        target.addEventListener(targetEvent, callback, false);
        return function() {
          target.removeEventListener(targetEvent, callback);
        };
      }
    };
    return DefaultEventStrategy;
  })();
  var EventManager = (function() {
    function EventManager() {
      _classCallCheck(this, EventManager);
      this.elementHandlerLookup = {};
      this.eventStrategyLookup = {};
      this.registerElementConfig({
        tagName: 'input',
        properties: {
          value: ['change', 'input'],
          checked: ['change', 'input'],
          files: ['change', 'input']
        }
      });
      this.registerElementConfig({
        tagName: 'textarea',
        properties: {value: ['change', 'input']}
      });
      this.registerElementConfig({
        tagName: 'select',
        properties: {value: ['change']}
      });
      this.registerElementConfig({
        tagName: 'content editable',
        properties: {value: ['change', 'input', 'blur', 'keyup', 'paste']}
      });
      this.registerElementConfig({
        tagName: 'scrollable element',
        properties: {
          scrollTop: ['scroll'],
          scrollLeft: ['scroll']
        }
      });
      this.defaultEventStrategy = new DefaultEventStrategy();
    }
    EventManager.prototype.registerElementConfig = function registerElementConfig(config) {
      var tagName = config.tagName.toLowerCase();
      var properties = config.properties;
      var propertyName = undefined;
      this.elementHandlerLookup[tagName] = {};
      for (propertyName in properties) {
        if (properties.hasOwnProperty(propertyName)) {
          this.registerElementPropertyConfig(tagName, propertyName, properties[propertyName]);
        }
      }
    };
    EventManager.prototype.registerElementPropertyConfig = function registerElementPropertyConfig(tagName, propertyName, events) {
      this.elementHandlerLookup[tagName][propertyName] = this.createElementHandler(events);
    };
    EventManager.prototype.createElementHandler = function createElementHandler(events) {
      return {subscribe: function subscribe(target, callback) {
          events.forEach(function(changeEvent) {
            target.addEventListener(changeEvent, callback, false);
          });
          return function() {
            events.forEach(function(changeEvent) {
              target.removeEventListener(changeEvent, callback);
            });
          };
        }};
    };
    EventManager.prototype.registerElementHandler = function registerElementHandler(tagName, handler) {
      this.elementHandlerLookup[tagName.toLowerCase()] = handler;
    };
    EventManager.prototype.registerEventStrategy = function registerEventStrategy(eventName, strategy) {
      this.eventStrategyLookup[eventName] = strategy;
    };
    EventManager.prototype.getElementHandler = function getElementHandler(target, propertyName) {
      var tagName = undefined;
      var lookup = this.elementHandlerLookup;
      if (target.tagName) {
        tagName = target.tagName.toLowerCase();
        if (lookup[tagName] && lookup[tagName][propertyName]) {
          return lookup[tagName][propertyName];
        }
        if (propertyName === 'textContent' || propertyName === 'innerHTML') {
          return lookup['content editable']['value'];
        }
        if (propertyName === 'scrollTop' || propertyName === 'scrollLeft') {
          return lookup['scrollable element'][propertyName];
        }
      }
      return null;
    };
    EventManager.prototype.addEventListener = function addEventListener(target, targetEvent, callback, delegate) {
      return (this.eventStrategyLookup[targetEvent] || this.defaultEventStrategy).subscribe(target, targetEvent, callback, delegate);
    };
    return EventManager;
  })();
  exports.EventManager = EventManager;
  var DirtyChecker = (function() {
    function DirtyChecker() {
      _classCallCheck(this, DirtyChecker);
      this.tracked = [];
      this.checkDelay = 120;
    }
    DirtyChecker.prototype.addProperty = function addProperty(property) {
      var tracked = this.tracked;
      tracked.push(property);
      if (tracked.length === 1) {
        this.scheduleDirtyCheck();
      }
    };
    DirtyChecker.prototype.removeProperty = function removeProperty(property) {
      var tracked = this.tracked;
      tracked.splice(tracked.indexOf(property), 1);
    };
    DirtyChecker.prototype.scheduleDirtyCheck = function scheduleDirtyCheck() {
      var _this2 = this;
      setTimeout(function() {
        return _this2.check();
      }, this.checkDelay);
    };
    DirtyChecker.prototype.check = function check() {
      var tracked = this.tracked,
          i = tracked.length;
      while (i--) {
        var current = tracked[i];
        if (current.isDirty()) {
          current.call();
        }
      }
      if (tracked.length) {
        this.scheduleDirtyCheck();
      }
    };
    return DirtyChecker;
  })();
  exports.DirtyChecker = DirtyChecker;
  var DirtyCheckProperty = (function() {
    function DirtyCheckProperty(dirtyChecker, obj, propertyName) {
      _classCallCheck(this, _DirtyCheckProperty);
      this.dirtyChecker = dirtyChecker;
      this.obj = obj;
      this.propertyName = propertyName;
    }
    DirtyCheckProperty.prototype.getValue = function getValue() {
      return this.obj[this.propertyName];
    };
    DirtyCheckProperty.prototype.setValue = function setValue(newValue) {
      this.obj[this.propertyName] = newValue;
    };
    DirtyCheckProperty.prototype.call = function call() {
      var oldValue = this.oldValue;
      var newValue = this.getValue();
      this.callSubscribers(newValue, oldValue);
      this.oldValue = newValue;
    };
    DirtyCheckProperty.prototype.isDirty = function isDirty() {
      return this.oldValue !== this.obj[this.propertyName];
    };
    DirtyCheckProperty.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.oldValue = this.getValue();
        this.dirtyChecker.addProperty(this);
      }
      this.addSubscriber(context, callable);
    };
    DirtyCheckProperty.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.dirtyChecker.removeProperty(this);
      }
    };
    var _DirtyCheckProperty = DirtyCheckProperty;
    DirtyCheckProperty = subscriberCollection()(DirtyCheckProperty) || DirtyCheckProperty;
    return DirtyCheckProperty;
  })();
  exports.DirtyCheckProperty = DirtyCheckProperty;
  var propertyAccessor = {
    getValue: function getValue(obj, propertyName) {
      return obj[propertyName];
    },
    setValue: function setValue(value, obj, propertyName) {
      return obj[propertyName] = value;
    }
  };
  exports.propertyAccessor = propertyAccessor;
  var PrimitiveObserver = (function() {
    function PrimitiveObserver(primitive, propertyName) {
      _classCallCheck(this, PrimitiveObserver);
      this.doNotCache = true;
      this.primitive = primitive;
      this.propertyName = propertyName;
    }
    PrimitiveObserver.prototype.getValue = function getValue() {
      return this.primitive[this.propertyName];
    };
    PrimitiveObserver.prototype.setValue = function setValue() {
      var type = typeof this.primitive;
      throw new Error('The ' + this.propertyName + ' property of a ' + type + ' (' + this.primitive + ') cannot be assigned.');
    };
    PrimitiveObserver.prototype.subscribe = function subscribe() {};
    PrimitiveObserver.prototype.unsubscribe = function unsubscribe() {};
    return PrimitiveObserver;
  })();
  exports.PrimitiveObserver = PrimitiveObserver;
  var SetterObserver = (function() {
    function SetterObserver(taskQueue, obj, propertyName) {
      _classCallCheck(this, _SetterObserver);
      this.taskQueue = taskQueue;
      this.obj = obj;
      this.propertyName = propertyName;
      this.queued = false;
      this.observing = false;
    }
    SetterObserver.prototype.getValue = function getValue() {
      return this.obj[this.propertyName];
    };
    SetterObserver.prototype.setValue = function setValue(newValue) {
      this.obj[this.propertyName] = newValue;
    };
    SetterObserver.prototype.getterValue = function getterValue() {
      return this.currentValue;
    };
    SetterObserver.prototype.setterValue = function setterValue(newValue) {
      var oldValue = this.currentValue;
      if (oldValue !== newValue) {
        if (!this.queued) {
          this.oldValue = oldValue;
          this.queued = true;
          this.taskQueue.queueMicroTask(this);
        }
        this.currentValue = newValue;
      }
    };
    SetterObserver.prototype.call = function call() {
      var oldValue = this.oldValue;
      var newValue = this.currentValue;
      this.queued = false;
      this.callSubscribers(newValue, oldValue);
    };
    SetterObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.observing) {
        this.convertProperty();
      }
      this.addSubscriber(context, callable);
    };
    SetterObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };
    SetterObserver.prototype.convertProperty = function convertProperty() {
      this.observing = true;
      this.currentValue = this.obj[this.propertyName];
      this.setValue = this.setterValue;
      this.getValue = this.getterValue;
      try {
        Object.defineProperty(this.obj, this.propertyName, {
          configurable: true,
          enumerable: true,
          get: this.getValue.bind(this),
          set: this.setValue.bind(this)
        });
      } catch (_) {}
    };
    var _SetterObserver = SetterObserver;
    SetterObserver = subscriberCollection()(SetterObserver) || SetterObserver;
    return SetterObserver;
  })();
  exports.SetterObserver = SetterObserver;
  var XLinkAttributeObserver = (function() {
    function XLinkAttributeObserver(element, propertyName, attributeName) {
      _classCallCheck(this, XLinkAttributeObserver);
      this.element = element;
      this.propertyName = propertyName;
      this.attributeName = attributeName;
    }
    XLinkAttributeObserver.prototype.getValue = function getValue() {
      return this.element.getAttributeNS('http://www.w3.org/1999/xlink', this.attributeName);
    };
    XLinkAttributeObserver.prototype.setValue = function setValue(newValue) {
      return this.element.setAttributeNS('http://www.w3.org/1999/xlink', this.attributeName, newValue);
    };
    XLinkAttributeObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
    };
    return XLinkAttributeObserver;
  })();
  exports.XLinkAttributeObserver = XLinkAttributeObserver;
  var dataAttributeAccessor = {
    getValue: function getValue(obj, propertyName) {
      return obj.getAttribute(propertyName);
    },
    setValue: function setValue(value, obj, propertyName) {
      return obj.setAttribute(propertyName, value);
    }
  };
  exports.dataAttributeAccessor = dataAttributeAccessor;
  var DataAttributeObserver = (function() {
    function DataAttributeObserver(element, propertyName) {
      _classCallCheck(this, DataAttributeObserver);
      this.element = element;
      this.propertyName = propertyName;
    }
    DataAttributeObserver.prototype.getValue = function getValue() {
      return this.element.getAttribute(this.propertyName);
    };
    DataAttributeObserver.prototype.setValue = function setValue(newValue) {
      return this.element.setAttribute(this.propertyName, newValue);
    };
    DataAttributeObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
    };
    return DataAttributeObserver;
  })();
  exports.DataAttributeObserver = DataAttributeObserver;
  var StyleObserver = (function() {
    function StyleObserver(element, propertyName) {
      _classCallCheck(this, StyleObserver);
      this.element = element;
      this.propertyName = propertyName;
    }
    StyleObserver.prototype.getValue = function getValue() {
      return this.element.style.cssText;
    };
    StyleObserver.prototype.setValue = function setValue(newValue) {
      if (newValue instanceof Object) {
        newValue = this.flattenCss(newValue);
      }
      this.element.style.cssText = newValue;
    };
    StyleObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "' + this.propertyName + '" property is not supported.');
    };
    StyleObserver.prototype.flattenCss = function flattenCss(object) {
      var s = '';
      for (var propertyName in object) {
        if (object.hasOwnProperty(propertyName)) {
          s += propertyName + ': ' + object[propertyName] + '; ';
        }
      }
      return s;
    };
    return StyleObserver;
  })();
  exports.StyleObserver = StyleObserver;
  var ValueAttributeObserver = (function() {
    function ValueAttributeObserver(element, propertyName, handler) {
      _classCallCheck(this, _ValueAttributeObserver);
      this.element = element;
      this.propertyName = propertyName;
      this.handler = handler;
      if (propertyName === 'files') {
        this.setValue = function() {};
      }
    }
    ValueAttributeObserver.prototype.getValue = function getValue() {
      return this.element[this.propertyName];
    };
    ValueAttributeObserver.prototype.setValue = function setValue(newValue) {
      newValue = newValue === undefined || newValue === null ? '' : newValue;
      if (this.element[this.propertyName] !== newValue) {
        this.element[this.propertyName] = newValue;
        this.notify();
      }
    };
    ValueAttributeObserver.prototype.notify = function notify() {
      var oldValue = this.oldValue;
      var newValue = this.getValue();
      this.callSubscribers(newValue, oldValue);
      this.oldValue = newValue;
    };
    ValueAttributeObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.oldValue = this.getValue();
        this.disposeHandler = this.handler.subscribe(this.element, this.notify.bind(this));
      }
      this.addSubscriber(context, callable);
    };
    ValueAttributeObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.disposeHandler();
        this.disposeHandler = null;
      }
    };
    var _ValueAttributeObserver = ValueAttributeObserver;
    ValueAttributeObserver = subscriberCollection()(ValueAttributeObserver) || ValueAttributeObserver;
    return ValueAttributeObserver;
  })();
  exports.ValueAttributeObserver = ValueAttributeObserver;
  var selectArrayContext = 'SelectValueObserver:array';
  var SelectValueObserver = (function() {
    function SelectValueObserver(element, handler, observerLocator) {
      _classCallCheck(this, _SelectValueObserver);
      this.element = element;
      this.handler = handler;
      this.observerLocator = observerLocator;
    }
    SelectValueObserver.prototype.getValue = function getValue() {
      return this.value;
    };
    SelectValueObserver.prototype.setValue = function setValue(newValue) {
      if (newValue !== null && newValue !== undefined && this.element.multiple && !Array.isArray(newValue)) {
        throw new Error('Only null or Array instances can be bound to a multi-select.');
      }
      if (this.value === newValue) {
        return;
      }
      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(selectArrayContext, this);
        this.arrayObserver = null;
      }
      if (Array.isArray(newValue)) {
        this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
        this.arrayObserver.subscribe(selectArrayContext, this);
      }
      this.value = newValue;
      this.synchronizeOptions();
      if (!this.initialSync) {
        this.initialSync = true;
        this.observerLocator.taskQueue.queueMicroTask(this);
      }
    };
    SelectValueObserver.prototype.call = function call(context, splices) {
      this.synchronizeOptions();
    };
    SelectValueObserver.prototype.synchronizeOptions = function synchronizeOptions() {
      var value = this.value,
          clear = undefined,
          isArray = undefined;
      if (value === null || value === undefined) {
        clear = true;
      } else if (Array.isArray(value)) {
        isArray = true;
      }
      var options = this.element.options;
      var i = options.length;
      var matcher = this.element.matcher || function(a, b) {
        return a === b;
      };
      var _loop = function() {
        var option = options.item(i);
        if (clear) {
          option.selected = false;
          return 'continue';
        }
        var optionValue = option.hasOwnProperty('model') ? option.model : option.value;
        if (isArray) {
          option.selected = !!value.find(function(item) {
            return !!matcher(optionValue, item);
          });
          return 'continue';
        }
        option.selected = !!matcher(optionValue, value);
      };
      while (i--) {
        var _ret2 = _loop();
        if (_ret2 === 'continue')
          continue;
      }
    };
    SelectValueObserver.prototype.synchronizeValue = function synchronizeValue() {
      var _this3 = this;
      var options = this.element.options,
          count = 0,
          value = [];
      for (var i = 0,
          ii = options.length; i < ii; i++) {
        var option = options.item(i);
        if (!option.selected) {
          continue;
        }
        value.push(option.hasOwnProperty('model') ? option.model : option.value);
        count++;
      }
      if (this.element.multiple) {
        if (Array.isArray(this.value)) {
          var _ret3 = (function() {
            var matcher = _this3.element.matcher || function(a, b) {
              return a === b;
            };
            var i = 0;
            var _loop2 = function() {
              var a = _this3.value[i];
              if (value.findIndex(function(b) {
                return matcher(a, b);
              }) === -1) {
                _this3.value.splice(i, 1);
              } else {
                i++;
              }
            };
            while (i < _this3.value.length) {
              _loop2();
            }
            i = 0;
            var _loop3 = function() {
              var a = value[i];
              if (_this3.value.findIndex(function(b) {
                return matcher(a, b);
              }) === -1) {
                _this3.value.push(a);
              }
              i++;
            };
            while (i < value.length) {
              _loop3();
            }
            return {v: undefined};
          })();
          if (typeof _ret3 === 'object')
            return _ret3.v;
        }
      } else {
        if (count === 0) {
          value = null;
        } else {
          value = value[0];
        }
      }
      if (value !== this.value) {
        this.oldValue = this.value;
        this.value = value;
        this.notify();
      }
    };
    SelectValueObserver.prototype.notify = function notify() {
      var oldValue = this.oldValue;
      var newValue = this.value;
      this.callSubscribers(newValue, oldValue);
    };
    SelectValueObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.disposeHandler = this.handler.subscribe(this.element, this.synchronizeValue.bind(this, false));
      }
      this.addSubscriber(context, callable);
    };
    SelectValueObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.disposeHandler();
        this.disposeHandler = null;
      }
    };
    SelectValueObserver.prototype.bind = function bind() {
      var _this4 = this;
      this.domObserver = _aureliaPal.DOM.createMutationObserver(function() {
        _this4.synchronizeOptions();
        _this4.synchronizeValue();
      });
      this.domObserver.observe(this.element, {
        childList: true,
        subtree: true
      });
    };
    SelectValueObserver.prototype.unbind = function unbind() {
      this.domObserver.disconnect();
      this.domObserver = null;
      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(selectArrayContext, this);
        this.arrayObserver = null;
      }
    };
    var _SelectValueObserver = SelectValueObserver;
    SelectValueObserver = subscriberCollection()(SelectValueObserver) || SelectValueObserver;
    return SelectValueObserver;
  })();
  exports.SelectValueObserver = SelectValueObserver;
  var checkedArrayContext = 'CheckedObserver:array';
  var CheckedObserver = (function() {
    function CheckedObserver(element, handler, observerLocator) {
      _classCallCheck(this, _CheckedObserver);
      this.element = element;
      this.handler = handler;
      this.observerLocator = observerLocator;
    }
    CheckedObserver.prototype.getValue = function getValue() {
      return this.value;
    };
    CheckedObserver.prototype.setValue = function setValue(newValue) {
      if (this.value === newValue) {
        return;
      }
      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(checkedArrayContext, this);
        this.arrayObserver = null;
      }
      if (this.element.type === 'checkbox' && Array.isArray(newValue)) {
        this.arrayObserver = this.observerLocator.getArrayObserver(newValue);
        this.arrayObserver.subscribe(checkedArrayContext, this);
      }
      this.value = newValue;
      this.synchronizeElement();
      if (!this.initialSync) {
        this.initialSync = true;
        this.observerLocator.taskQueue.queueMicroTask(this);
      }
    };
    CheckedObserver.prototype.call = function call(context, splices) {
      this.synchronizeElement();
    };
    CheckedObserver.prototype.synchronizeElement = function synchronizeElement() {
      var value = this.value,
          element = this.element,
          elementValue = element.hasOwnProperty('model') ? element.model : element.value,
          isRadio = element.type === 'radio',
          matcher = element.matcher || function(a, b) {
            return a === b;
          };
      element.checked = isRadio && !!matcher(value, elementValue) || !isRadio && value === true || !isRadio && Array.isArray(value) && !!value.find(function(item) {
        return !!matcher(item, elementValue);
      });
    };
    CheckedObserver.prototype.synchronizeValue = function synchronizeValue() {
      var value = this.value,
          element = this.element,
          elementValue = element.hasOwnProperty('model') ? element.model : element.value,
          index = undefined,
          matcher = element.matcher || function(a, b) {
            return a === b;
          };
      if (element.type === 'checkbox') {
        if (Array.isArray(value)) {
          index = value.findIndex(function(item) {
            return !!matcher(item, elementValue);
          });
          if (element.checked && index === -1) {
            value.push(elementValue);
          } else if (!element.checked && index !== -1) {
            value.splice(index, 1);
          }
          return;
        } else {
          value = element.checked;
        }
      } else if (element.checked) {
        value = elementValue;
      } else {
        return;
      }
      this.oldValue = this.value;
      this.value = value;
      this.notify();
    };
    CheckedObserver.prototype.notify = function notify() {
      var oldValue = this.oldValue;
      var newValue = this.value;
      this.callSubscribers(newValue, oldValue);
    };
    CheckedObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.disposeHandler = this.handler.subscribe(this.element, this.synchronizeValue.bind(this, false));
      }
      this.addSubscriber(context, callable);
    };
    CheckedObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.disposeHandler();
        this.disposeHandler = null;
      }
    };
    CheckedObserver.prototype.unbind = function unbind() {
      if (this.arrayObserver) {
        this.arrayObserver.unsubscribe(checkedArrayContext, this);
        this.arrayObserver = null;
      }
    };
    var _CheckedObserver = CheckedObserver;
    CheckedObserver = subscriberCollection()(CheckedObserver) || CheckedObserver;
    return CheckedObserver;
  })();
  exports.CheckedObserver = CheckedObserver;
  var ClassObserver = (function() {
    function ClassObserver(element) {
      _classCallCheck(this, ClassObserver);
      this.element = element;
      this.doNotCache = true;
      this.value = '';
      this.version = 0;
    }
    ClassObserver.prototype.getValue = function getValue() {
      return this.value;
    };
    ClassObserver.prototype.setValue = function setValue(newValue) {
      var nameIndex = this.nameIndex || {},
          version = this.version,
          names,
          name;
      if (newValue !== null && newValue !== undefined && newValue.length) {
        names = newValue.split(/\s+/);
        for (var i = 0,
            _length = names.length; i < _length; i++) {
          name = names[i];
          if (name === '') {
            continue;
          }
          nameIndex[name] = version;
          this.element.classList.add(name);
        }
      }
      this.value = newValue;
      this.nameIndex = nameIndex;
      this.version += 1;
      if (version === 0) {
        return;
      }
      version -= 1;
      for (name in nameIndex) {
        if (!nameIndex.hasOwnProperty(name) || nameIndex[name] !== version) {
          continue;
        }
        this.element.classList.remove(name);
      }
    };
    ClassObserver.prototype.subscribe = function subscribe() {
      throw new Error('Observation of a "' + this.element.nodeName + '" element\'s "class" property is not supported.');
    };
    return ClassObserver;
  })();
  exports.ClassObserver = ClassObserver;
  var computedContext = 'ComputedPropertyObserver';
  var ComputedPropertyObserver = (function() {
    function ComputedPropertyObserver(obj, propertyName, descriptor, observerLocator) {
      _classCallCheck(this, _ComputedPropertyObserver);
      this.obj = obj;
      this.propertyName = propertyName;
      this.descriptor = descriptor;
      this.observerLocator = observerLocator;
    }
    ComputedPropertyObserver.prototype.getValue = function getValue() {
      return this.obj[this.propertyName];
    };
    ComputedPropertyObserver.prototype.setValue = function setValue(newValue) {
      this.obj[this.propertyName] = newValue;
    };
    ComputedPropertyObserver.prototype.call = function call(context) {
      var newValue = this.getValue();
      if (this.oldValue === newValue)
        return;
      this.callSubscribers(newValue, this.oldValue);
      this.oldValue = newValue;
      return;
    };
    ComputedPropertyObserver.prototype.subscribe = function subscribe(context, callable) {
      if (!this.hasSubscribers()) {
        this.oldValue = this.getValue();
        var dependencies = this.descriptor.get.dependencies;
        this.observers = [];
        for (var i = 0,
            ii = dependencies.length; i < ii; i++) {
          var observer = this.observerLocator.getObserver(this.obj, dependencies[i]);
          this.observers.push(observer);
          observer.subscribe(computedContext, this);
        }
      }
      this.addSubscriber(context, callable);
    };
    ComputedPropertyObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      if (this.removeSubscriber(context, callable) && !this.hasSubscribers()) {
        this.oldValue = undefined;
        var i = this.observers.length;
        while (i--) {
          this.observers[i].unsubscribe(computedContext, this);
        }
        this.observers = null;
      }
    };
    var _ComputedPropertyObserver = ComputedPropertyObserver;
    ComputedPropertyObserver = subscriberCollection()(ComputedPropertyObserver) || ComputedPropertyObserver;
    return ComputedPropertyObserver;
  })();
  exports.ComputedPropertyObserver = ComputedPropertyObserver;
  function hasDeclaredDependencies(descriptor) {
    return descriptor && descriptor.get && descriptor.get.dependencies && descriptor.get.dependencies.length > 0;
  }
  function declarePropertyDependencies(ctor, propertyName, dependencies) {
    var descriptor = Object.getOwnPropertyDescriptor(ctor.prototype, propertyName);
    descriptor.get.dependencies = dependencies;
  }
  function computedFrom() {
    for (var _len = arguments.length,
        rest = Array(_len),
        _key = 0; _key < _len; _key++) {
      rest[_key] = arguments[_key];
    }
    return function(target, key, descriptor) {
      descriptor.get.dependencies = rest;
      return descriptor;
    };
  }
  var elements = {
    a: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'target', 'transform', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyph: ['class', 'dx', 'dy', 'externalResourcesRequired', 'format', 'glyphRef', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    altGlyphDef: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    altGlyphItem: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    animate: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateColor: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateMotion: ['accumulate', 'additive', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keyPoints', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'origin', 'path', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'rotate', 'systemLanguage', 'to', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    animateTransform: ['accumulate', 'additive', 'attributeName', 'attributeType', 'begin', 'by', 'calcMode', 'dur', 'end', 'externalResourcesRequired', 'fill', 'from', 'id', 'keySplines', 'keyTimes', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'type', 'values', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    circle: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'r', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    clipPath: ['class', 'clipPathUnits', 'externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    'color-profile': ['id', 'local', 'name', 'rendering-intent', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    cursor: ['externalResourcesRequired', 'id', 'requiredExtensions', 'requiredFeatures', 'systemLanguage', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    defs: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    desc: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    ellipse: ['class', 'cx', 'cy', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    feBlend: ['class', 'height', 'id', 'in', 'in2', 'mode', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feColorMatrix: ['class', 'height', 'id', 'in', 'result', 'style', 'type', 'values', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComponentTransfer: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feComposite: ['class', 'height', 'id', 'in', 'in2', 'k1', 'k2', 'k3', 'k4', 'operator', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feConvolveMatrix: ['bias', 'class', 'divisor', 'edgeMode', 'height', 'id', 'in', 'kernelMatrix', 'kernelUnitLength', 'order', 'preserveAlpha', 'result', 'style', 'targetX', 'targetY', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDiffuseLighting: ['class', 'diffuseConstant', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feDisplacementMap: ['class', 'height', 'id', 'in', 'in2', 'result', 'scale', 'style', 'width', 'x', 'xChannelSelector', 'xml:base', 'xml:lang', 'xml:space', 'y', 'yChannelSelector'],
    feDistantLight: ['azimuth', 'elevation', 'id', 'xml:base', 'xml:lang', 'xml:space'],
    feFlood: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feFuncA: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncB: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncG: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feFuncR: ['amplitude', 'exponent', 'id', 'intercept', 'offset', 'slope', 'tableValues', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    feGaussianBlur: ['class', 'height', 'id', 'in', 'result', 'stdDeviation', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feImage: ['class', 'externalResourcesRequired', 'height', 'id', 'preserveAspectRatio', 'result', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMerge: ['class', 'height', 'id', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feMergeNode: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    feMorphology: ['class', 'height', 'id', 'in', 'operator', 'radius', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feOffset: ['class', 'dx', 'dy', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    fePointLight: ['id', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feSpecularLighting: ['class', 'height', 'id', 'in', 'kernelUnitLength', 'result', 'specularConstant', 'specularExponent', 'style', 'surfaceScale', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feSpotLight: ['id', 'limitingConeAngle', 'pointsAtX', 'pointsAtY', 'pointsAtZ', 'specularExponent', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'z'],
    feTile: ['class', 'height', 'id', 'in', 'result', 'style', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    feTurbulence: ['baseFrequency', 'class', 'height', 'id', 'numOctaves', 'result', 'seed', 'stitchTiles', 'style', 'type', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    filter: ['class', 'externalResourcesRequired', 'filterRes', 'filterUnits', 'height', 'id', 'primitiveUnits', 'style', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    font: ['class', 'externalResourcesRequired', 'horiz-adv-x', 'horiz-origin-x', 'horiz-origin-y', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face': ['accent-height', 'alphabetic', 'ascent', 'bbox', 'cap-height', 'descent', 'font-family', 'font-size', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'hanging', 'id', 'ideographic', 'mathematical', 'overline-position', 'overline-thickness', 'panose-1', 'slope', 'stemh', 'stemv', 'strikethrough-position', 'strikethrough-thickness', 'underline-position', 'underline-thickness', 'unicode-range', 'units-per-em', 'v-alphabetic', 'v-hanging', 'v-ideographic', 'v-mathematical', 'widths', 'x-height', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-format': ['id', 'string', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-name': ['id', 'name', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-src': ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'font-face-uri': ['id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    foreignObject: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    g: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    glyph: ['arabic-form', 'class', 'd', 'glyph-name', 'horiz-adv-x', 'id', 'lang', 'orientation', 'style', 'unicode', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    glyphRef: ['class', 'dx', 'dy', 'format', 'glyphRef', 'id', 'style', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    hkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space'],
    image: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    line: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'x1', 'x2', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    linearGradient: ['class', 'externalResourcesRequired', 'gradientTransform', 'gradientUnits', 'id', 'spreadMethod', 'style', 'x1', 'x2', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y1', 'y2'],
    marker: ['class', 'externalResourcesRequired', 'id', 'markerHeight', 'markerUnits', 'markerWidth', 'orient', 'preserveAspectRatio', 'refX', 'refY', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    mask: ['class', 'externalResourcesRequired', 'height', 'id', 'maskContentUnits', 'maskUnits', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    metadata: ['id', 'xml:base', 'xml:lang', 'xml:space'],
    'missing-glyph': ['class', 'd', 'horiz-adv-x', 'id', 'style', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'xml:base', 'xml:lang', 'xml:space'],
    mpath: ['externalResourcesRequired', 'id', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    path: ['class', 'd', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'pathLength', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    pattern: ['class', 'externalResourcesRequired', 'height', 'id', 'patternContentUnits', 'patternTransform', 'patternUnits', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'viewBox', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    polygon: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    polyline: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'points', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    radialGradient: ['class', 'cx', 'cy', 'externalResourcesRequired', 'fx', 'fy', 'gradientTransform', 'gradientUnits', 'id', 'r', 'spreadMethod', 'style', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    rect: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rx', 'ry', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    script: ['externalResourcesRequired', 'id', 'type', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    set: ['attributeName', 'attributeType', 'begin', 'dur', 'end', 'externalResourcesRequired', 'fill', 'id', 'max', 'min', 'onbegin', 'onend', 'onload', 'onrepeat', 'repeatCount', 'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart', 'systemLanguage', 'to', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    stop: ['class', 'id', 'offset', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    style: ['id', 'media', 'title', 'type', 'xml:base', 'xml:lang', 'xml:space'],
    svg: ['baseProfile', 'class', 'contentScriptType', 'contentStyleType', 'externalResourcesRequired', 'height', 'id', 'onabort', 'onactivate', 'onclick', 'onerror', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onresize', 'onscroll', 'onunload', 'onzoom', 'preserveAspectRatio', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'version', 'viewBox', 'width', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y', 'zoomAndPan'],
    'switch': ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'xml:base', 'xml:lang', 'xml:space'],
    symbol: ['class', 'externalResourcesRequired', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'preserveAspectRatio', 'style', 'viewBox', 'xml:base', 'xml:lang', 'xml:space'],
    text: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'transform', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    textPath: ['class', 'externalResourcesRequired', 'id', 'lengthAdjust', 'method', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'spacing', 'startOffset', 'style', 'systemLanguage', 'textLength', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space'],
    title: ['class', 'id', 'style', 'xml:base', 'xml:lang', 'xml:space'],
    tref: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    tspan: ['class', 'dx', 'dy', 'externalResourcesRequired', 'id', 'lengthAdjust', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'rotate', 'style', 'systemLanguage', 'textLength', 'x', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    use: ['class', 'externalResourcesRequired', 'height', 'id', 'onactivate', 'onclick', 'onfocusin', 'onfocusout', 'onload', 'onmousedown', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'requiredExtensions', 'requiredFeatures', 'style', 'systemLanguage', 'transform', 'width', 'x', 'xlink:actuate', 'xlink:arcrole', 'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type', 'xml:base', 'xml:lang', 'xml:space', 'y'],
    view: ['externalResourcesRequired', 'id', 'preserveAspectRatio', 'viewBox', 'viewTarget', 'xml:base', 'xml:lang', 'xml:space', 'zoomAndPan'],
    vkern: ['g1', 'g2', 'id', 'k', 'u1', 'u2', 'xml:base', 'xml:lang', 'xml:space']
  };
  exports.elements = elements;
  var presentationElements = {
    'a': true,
    'altGlyph': true,
    'animate': true,
    'animateColor': true,
    'circle': true,
    'clipPath': true,
    'defs': true,
    'ellipse': true,
    'feBlend': true,
    'feColorMatrix': true,
    'feComponentTransfer': true,
    'feComposite': true,
    'feConvolveMatrix': true,
    'feDiffuseLighting': true,
    'feDisplacementMap': true,
    'feFlood': true,
    'feGaussianBlur': true,
    'feImage': true,
    'feMerge': true,
    'feMorphology': true,
    'feOffset': true,
    'feSpecularLighting': true,
    'feTile': true,
    'feTurbulence': true,
    'filter': true,
    'font': true,
    'foreignObject': true,
    'g': true,
    'glyph': true,
    'glyphRef': true,
    'image': true,
    'line': true,
    'linearGradient': true,
    'marker': true,
    'mask': true,
    'missing-glyph': true,
    'path': true,
    'pattern': true,
    'polygon': true,
    'polyline': true,
    'radialGradient': true,
    'rect': true,
    'stop': true,
    'svg': true,
    'switch': true,
    'symbol': true,
    'text': true,
    'textPath': true,
    'tref': true,
    'tspan': true,
    'use': true
  };
  exports.presentationElements = presentationElements;
  var presentationAttributes = {
    'alignment-baseline': true,
    'baseline-shift': true,
    'clip-path': true,
    'clip-rule': true,
    'clip': true,
    'color-interpolation-filters': true,
    'color-interpolation': true,
    'color-profile': true,
    'color-rendering': true,
    'color': true,
    'cursor': true,
    'direction': true,
    'display': true,
    'dominant-baseline': true,
    'enable-background': true,
    'fill-opacity': true,
    'fill-rule': true,
    'fill': true,
    'filter': true,
    'flood-color': true,
    'flood-opacity': true,
    'font-family': true,
    'font-size-adjust': true,
    'font-size': true,
    'font-stretch': true,
    'font-style': true,
    'font-variant': true,
    'font-weight': true,
    'glyph-orientation-horizontal': true,
    'glyph-orientation-vertical': true,
    'image-rendering': true,
    'kerning': true,
    'letter-spacing': true,
    'lighting-color': true,
    'marker-end': true,
    'marker-mid': true,
    'marker-start': true,
    'mask': true,
    'opacity': true,
    'overflow': true,
    'pointer-events': true,
    'shape-rendering': true,
    'stop-color': true,
    'stop-opacity': true,
    'stroke-dasharray': true,
    'stroke-dashoffset': true,
    'stroke-linecap': true,
    'stroke-linejoin': true,
    'stroke-miterlimit': true,
    'stroke-opacity': true,
    'stroke-width': true,
    'stroke': true,
    'text-anchor': true,
    'text-decoration': true,
    'text-rendering': true,
    'unicode-bidi': true,
    'visibility': true,
    'word-spacing': true,
    'writing-mode': true
  };
  exports.presentationAttributes = presentationAttributes;
  function createElement(html) {
    var div = _aureliaPal.DOM.createElement('div');
    div.innerHTML = html;
    return div.firstChild;
  }
  var SVGAnalyzer = (function() {
    function SVGAnalyzer() {
      _classCallCheck(this, SVGAnalyzer);
      if (createElement('<svg><altGlyph /></svg>').firstElementChild.nodeName === 'altglyph' && elements.altGlyph) {
        elements.altglyph = elements.altGlyph;
        delete elements.altGlyph;
        elements.altglyphdef = elements.altGlyphDef;
        delete elements.altGlyphDef;
        elements.altglyphitem = elements.altGlyphItem;
        delete elements.altGlyphItem;
        elements.glyphref = elements.glyphRef;
        delete elements.glyphRef;
      }
    }
    SVGAnalyzer.prototype.isStandardSvgAttribute = function isStandardSvgAttribute(nodeName, attributeName) {
      return presentationElements[nodeName] && presentationAttributes[attributeName] || elements[nodeName] && elements[nodeName].indexOf(attributeName) !== -1;
    };
    return SVGAnalyzer;
  })();
  exports.SVGAnalyzer = SVGAnalyzer;
  var ObserverLocator = (function() {
    _createClass(ObserverLocator, null, [{
      key: 'inject',
      value: [_aureliaTaskQueue.TaskQueue, EventManager, DirtyChecker, SVGAnalyzer],
      enumerable: true
    }]);
    function ObserverLocator(taskQueue, eventManager, dirtyChecker, svgAnalyzer) {
      _classCallCheck(this, ObserverLocator);
      this.taskQueue = taskQueue;
      this.eventManager = eventManager;
      this.dirtyChecker = dirtyChecker;
      this.svgAnalyzer = svgAnalyzer;
      this.adapters = [];
    }
    ObserverLocator.prototype.getObserver = function getObserver(obj, propertyName) {
      var observersLookup = obj.__observers__;
      var observer = undefined;
      if (observersLookup && propertyName in observersLookup) {
        return observersLookup[propertyName];
      }
      observer = this.createPropertyObserver(obj, propertyName);
      if (!observer.doNotCache) {
        if (observersLookup === undefined) {
          observersLookup = this.getOrCreateObserversLookup(obj);
        }
        observersLookup[propertyName] = observer;
      }
      return observer;
    };
    ObserverLocator.prototype.getOrCreateObserversLookup = function getOrCreateObserversLookup(obj) {
      return obj.__observers__ || this.createObserversLookup(obj);
    };
    ObserverLocator.prototype.createObserversLookup = function createObserversLookup(obj) {
      var value = {};
      try {
        Object.defineProperty(obj, "__observers__", {
          enumerable: false,
          configurable: false,
          writable: false,
          value: value
        });
      } catch (_) {}
      return value;
    };
    ObserverLocator.prototype.addAdapter = function addAdapter(adapter) {
      this.adapters.push(adapter);
    };
    ObserverLocator.prototype.getAdapterObserver = function getAdapterObserver(obj, propertyName, descriptor) {
      for (var i = 0,
          ii = this.adapters.length; i < ii; i++) {
        var adapter = this.adapters[i];
        var observer = adapter.getObserver(obj, propertyName, descriptor);
        if (observer) {
          return observer;
        }
      }
      return null;
    };
    ObserverLocator.prototype.createPropertyObserver = function createPropertyObserver(obj, propertyName) {
      var observerLookup = undefined;
      var descriptor = undefined;
      var handler = undefined;
      var xlinkResult = undefined;
      if (!(obj instanceof Object)) {
        return new PrimitiveObserver(obj, propertyName);
      }
      if (obj instanceof _aureliaPal.DOM.Element) {
        if (propertyName === 'class') {
          return new ClassObserver(obj);
        }
        if (propertyName === 'style' || propertyName === 'css') {
          return new StyleObserver(obj, propertyName);
        }
        handler = this.eventManager.getElementHandler(obj, propertyName);
        if (propertyName === 'value' && obj.tagName.toLowerCase() === 'select') {
          return new SelectValueObserver(obj, handler, this);
        }
        if (propertyName === 'checked' && obj.tagName.toLowerCase() === 'input') {
          return new CheckedObserver(obj, handler, this);
        }
        if (handler) {
          return new ValueAttributeObserver(obj, propertyName, handler);
        }
        xlinkResult = /^xlink:(.+)$/.exec(propertyName);
        if (xlinkResult) {
          return new XLinkAttributeObserver(obj, propertyName, xlinkResult[1]);
        }
        if (/^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
          return new DataAttributeObserver(obj, propertyName);
        }
      }
      descriptor = Object.getPropertyDescriptor(obj, propertyName);
      if (hasDeclaredDependencies(descriptor)) {
        return new ComputedPropertyObserver(obj, propertyName, descriptor, this);
      }
      var existingGetterOrSetter = undefined;
      if (descriptor && (existingGetterOrSetter = descriptor.get || descriptor.set)) {
        if (existingGetterOrSetter.getObserver) {
          return existingGetterOrSetter.getObserver(obj);
        }
        var adapterObserver = this.getAdapterObserver(obj, propertyName, descriptor);
        if (adapterObserver) {
          return adapterObserver;
        }
        return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
      }
      if (obj instanceof Array) {
        if (propertyName === 'length') {
          return this.getArrayObserver(obj).getLengthObserver();
        } else {
          return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
        }
      } else if (obj instanceof Map) {
        if (propertyName === 'size') {
          return this.getMapObserver(obj).getLengthObserver();
        } else {
          return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
        }
      } else if (obj instanceof Set) {
        if (propertyName === 'size') {
          return this.getSetObserver(obj).getLengthObserver();
        } else {
          return new DirtyCheckProperty(this.dirtyChecker, obj, propertyName);
        }
      }
      return new SetterObserver(this.taskQueue, obj, propertyName);
    };
    ObserverLocator.prototype.getAccessor = function getAccessor(obj, propertyName) {
      if (obj instanceof _aureliaPal.DOM.Element) {
        if (propertyName === 'class' || propertyName === 'style' || propertyName === 'css' || propertyName === 'value' && (obj.tagName.toLowerCase() === 'input' || obj.tagName.toLowerCase() === 'select') || propertyName === 'checked' && obj.tagName.toLowerCase() === 'input' || /^xlink:.+$/.exec(propertyName)) {
          return this.getObserver(obj, propertyName);
        }
        if (/^\w+:|^data-|^aria-/.test(propertyName) || obj instanceof _aureliaPal.DOM.SVGElement && this.svgAnalyzer.isStandardSvgAttribute(obj.nodeName, propertyName)) {
          return dataAttributeAccessor;
        }
      }
      return propertyAccessor;
    };
    ObserverLocator.prototype.getArrayObserver = function getArrayObserver(array) {
      if ('__array_observer__' in array) {
        return array.__array_observer__;
      }
      return array.__array_observer__ = _getArrayObserver(this.taskQueue, array);
    };
    ObserverLocator.prototype.getMapObserver = function getMapObserver(map) {
      if ('__map_observer__' in map) {
        return map.__map_observer__;
      }
      return map.__map_observer__ = _getMapObserver(this.taskQueue, map);
    };
    ObserverLocator.prototype.getSetObserver = (function(_getSetObserver) {
      function getSetObserver(_x) {
        return _getSetObserver.apply(this, arguments);
      }
      getSetObserver.toString = function() {
        return _getSetObserver.toString();
      };
      return getSetObserver;
    })(function(set) {
      if ('__set_observer__' in set) {
        return set.__set_observer__;
      }
      return set.__set_observer__ = getSetObserver(this.taskQueue, set);
    });
    return ObserverLocator;
  })();
  exports.ObserverLocator = ObserverLocator;
  var ObjectObservationAdapter = (function() {
    function ObjectObservationAdapter() {
      _classCallCheck(this, ObjectObservationAdapter);
    }
    ObjectObservationAdapter.prototype.getObserver = function getObserver(object, propertyName, descriptor) {
      throw new Error('BindingAdapters must implement getObserver(object, propertyName).');
    };
    return ObjectObservationAdapter;
  })();
  exports.ObjectObservationAdapter = ObjectObservationAdapter;
  var BindingExpression = (function() {
    function BindingExpression(observerLocator, targetProperty, sourceExpression, mode, lookupFunctions, attribute) {
      _classCallCheck(this, BindingExpression);
      this.observerLocator = observerLocator;
      this.targetProperty = targetProperty;
      this.sourceExpression = sourceExpression;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
      this.attribute = attribute;
      this.discrete = false;
    }
    BindingExpression.prototype.createBinding = function createBinding(target) {
      return new Binding(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.mode, this.lookupFunctions);
    };
    return BindingExpression;
  })();
  exports.BindingExpression = BindingExpression;
  var targetContext = 'Binding:target';
  var Binding = (function() {
    function Binding(observerLocator, sourceExpression, target, targetProperty, mode, lookupFunctions) {
      _classCallCheck(this, _Binding);
      this.observerLocator = observerLocator;
      this.sourceExpression = sourceExpression;
      this.target = target;
      this.targetProperty = targetProperty;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
    }
    Binding.prototype.updateTarget = function updateTarget(value) {
      this.targetObserver.setValue(value, this.target, this.targetProperty);
    };
    Binding.prototype.updateSource = function updateSource(value) {
      this.sourceExpression.assign(this.source, value, this.lookupFunctions);
    };
    Binding.prototype.call = function call(context, newValue, oldValue) {
      if (!this.isBound) {
        return;
      }
      if (context === sourceContext) {
        oldValue = this.targetObserver.getValue(this.target, this.targetProperty);
        newValue = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        if (newValue !== oldValue) {
          this.updateTarget(newValue);
        }
        if (this.mode !== bindingMode.oneTime) {
          this._version++;
          this.sourceExpression.connect(this, this.source);
          this.unobserve(false);
        }
        return;
      }
      if (context === targetContext) {
        if (newValue !== this.sourceExpression.evaluate(this.source, this.lookupFunctions)) {
          this.updateSource(newValue);
        }
        return;
      }
      throw new Error('Unexpected call context ' + context);
    };
    Binding.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;
      var sourceExpression = this.sourceExpression;
      if (sourceExpression.bind) {
        sourceExpression.bind(this, source, this.lookupFunctions);
      }
      var mode = this.mode;
      if (!this.targetObserver) {
        var method = mode === bindingMode.twoWay ? 'getObserver' : 'getAccessor';
        this.targetObserver = this.observerLocator[method](this.target, this.targetProperty);
      }
      if ('bind' in this.targetObserver) {
        this.targetObserver.bind();
      }
      var value = sourceExpression.evaluate(source, this.lookupFunctions);
      this.updateTarget(value);
      if (mode === bindingMode.oneWay) {
        enqueueBindingConnect(this);
      } else if (mode === bindingMode.twoWay) {
        sourceExpression.connect(this, source);
        this.targetObserver.subscribe(targetContext, this);
      }
    };
    Binding.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      if (this.sourceExpression.unbind) {
        this.sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      if ('unbind' in this.targetObserver) {
        this.targetObserver.unbind();
      }
      if (this.targetObserver.unsubscribe) {
        this.targetObserver.unsubscribe(targetContext, this);
      }
      this.unobserve(true);
    };
    Binding.prototype.connect = function connect(evaluate) {
      if (!this.isBound) {
        return;
      }
      if (evaluate) {
        var value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        this.updateTarget(value);
      }
      this.sourceExpression.connect(this, this.source);
    };
    var _Binding = Binding;
    Binding = connectable()(Binding) || Binding;
    return Binding;
  })();
  exports.Binding = Binding;
  var CallExpression = (function() {
    function CallExpression(observerLocator, targetProperty, sourceExpression, lookupFunctions) {
      _classCallCheck(this, CallExpression);
      this.observerLocator = observerLocator;
      this.targetProperty = targetProperty;
      this.sourceExpression = sourceExpression;
      this.lookupFunctions = lookupFunctions;
    }
    CallExpression.prototype.createBinding = function createBinding(target) {
      return new Call(this.observerLocator, this.sourceExpression, target, this.targetProperty, this.lookupFunctions);
    };
    return CallExpression;
  })();
  exports.CallExpression = CallExpression;
  var Call = (function() {
    function Call(observerLocator, sourceExpression, target, targetProperty, lookupFunctions) {
      _classCallCheck(this, Call);
      this.sourceExpression = sourceExpression;
      this.target = target;
      this.targetProperty = observerLocator.getObserver(target, targetProperty);
      this.lookupFunctions = lookupFunctions;
    }
    Call.prototype.callSource = function callSource($event) {
      var overrideContext = this.source.overrideContext;
      Object.assign(overrideContext, $event);
      overrideContext.$event = $event;
      var mustEvaluate = true;
      var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
      delete overrideContext.$event;
      for (var prop in $event) {
        delete overrideContext[prop];
      }
      return result;
    };
    Call.prototype.bind = function bind(source) {
      var _this5 = this;
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;
      var sourceExpression = this.sourceExpression;
      if (sourceExpression.bind) {
        sourceExpression.bind(this, source, this.lookupFunctions);
      }
      this.targetProperty.setValue(function($event) {
        return _this5.callSource($event);
      });
    };
    Call.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      if (this.sourceExpression.unbind) {
        this.sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      this.targetProperty.setValue(null);
    };
    return Call;
  })();
  exports.Call = Call;
  var ValueConverterResource = (function() {
    function ValueConverterResource(name) {
      _classCallCheck(this, ValueConverterResource);
      this.name = name;
    }
    ValueConverterResource.convention = function convention(name) {
      if (name.endsWith('ValueConverter')) {
        return new ValueConverterResource(camelCase(name.substring(0, name.length - 14)));
      }
    };
    ValueConverterResource.prototype.initialize = function initialize(container, target) {
      this.instance = container.get(target);
    };
    ValueConverterResource.prototype.register = function register(registry, name) {
      registry.registerValueConverter(name || this.name, this.instance);
    };
    ValueConverterResource.prototype.load = function load(container, target) {};
    return ValueConverterResource;
  })();
  exports.ValueConverterResource = ValueConverterResource;
  function valueConverter(nameOrTarget) {
    if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
      return function(target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(nameOrTarget), target);
      };
    }
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ValueConverterResource(), nameOrTarget);
  }
  var BindingBehaviorResource = (function() {
    function BindingBehaviorResource(name) {
      _classCallCheck(this, BindingBehaviorResource);
      this.name = name;
    }
    BindingBehaviorResource.convention = function convention(name) {
      if (name.endsWith('BindingBehavior')) {
        return new BindingBehaviorResource(camelCase(name.substring(0, name.length - 15)));
      }
    };
    BindingBehaviorResource.prototype.initialize = function initialize(container, target) {
      this.instance = container.get(target);
    };
    BindingBehaviorResource.prototype.register = function register(registry, name) {
      registry.registerBindingBehavior(name || this.name, this.instance);
    };
    BindingBehaviorResource.prototype.load = function load(container, target) {};
    return BindingBehaviorResource;
  })();
  exports.BindingBehaviorResource = BindingBehaviorResource;
  function bindingBehavior(nameOrTarget) {
    if (nameOrTarget === undefined || typeof nameOrTarget === 'string') {
      return function(target) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(nameOrTarget), target);
      };
    }
    _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new BindingBehaviorResource(), nameOrTarget);
  }
  var ListenerExpression = (function() {
    function ListenerExpression(eventManager, targetEvent, sourceExpression, delegate, preventDefault, lookupFunctions) {
      _classCallCheck(this, ListenerExpression);
      this.eventManager = eventManager;
      this.targetEvent = targetEvent;
      this.sourceExpression = sourceExpression;
      this.delegate = delegate;
      this.discrete = true;
      this.preventDefault = preventDefault;
      this.lookupFunctions = lookupFunctions;
    }
    ListenerExpression.prototype.createBinding = function createBinding(target) {
      return new Listener(this.eventManager, this.targetEvent, this.delegate, this.sourceExpression, target, this.preventDefault, this.lookupFunctions);
    };
    return ListenerExpression;
  })();
  exports.ListenerExpression = ListenerExpression;
  var Listener = (function() {
    function Listener(eventManager, targetEvent, delegate, sourceExpression, target, preventDefault, lookupFunctions) {
      _classCallCheck(this, Listener);
      this.eventManager = eventManager;
      this.targetEvent = targetEvent;
      this.delegate = delegate;
      this.sourceExpression = sourceExpression;
      this.target = target;
      this.preventDefault = preventDefault;
      this.lookupFunctions = lookupFunctions;
    }
    Listener.prototype.callSource = function callSource(event) {
      var overrideContext = this.source.overrideContext;
      overrideContext.$event = event;
      var mustEvaluate = true;
      var result = this.sourceExpression.evaluate(this.source, this.lookupFunctions, mustEvaluate);
      delete overrideContext.$event;
      if (result !== true && this.preventDefault) {
        event.preventDefault();
      }
      return result;
    };
    Listener.prototype.bind = function bind(source) {
      var _this6 = this;
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;
      var sourceExpression = this.sourceExpression;
      if (sourceExpression.bind) {
        sourceExpression.bind(this, source, this.lookupFunctions);
      }
      this._disposeListener = this.eventManager.addEventListener(this.target, this.targetEvent, function(event) {
        return _this6.callSource(event);
      }, this.delegate);
    };
    Listener.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      if (this.sourceExpression.unbind) {
        this.sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      this._disposeListener();
      this._disposeListener = null;
    };
    return Listener;
  })();
  exports.Listener = Listener;
  function getAU(element) {
    var au = element.au;
    if (au === undefined) {
      throw new Error('No Aurelia APIs are defined for the referenced element.');
    }
    return au;
  }
  var NameExpression = (function() {
    function NameExpression(property, apiName) {
      _classCallCheck(this, NameExpression);
      this.property = property;
      this.apiName = apiName;
      this.discrete = true;
    }
    NameExpression.prototype.createBinding = function createBinding(target) {
      return new NameBinder(this.property, NameExpression.locateAPI(target, this.apiName));
    };
    NameExpression.locateAPI = function locateAPI(element, apiName) {
      switch (apiName) {
        case 'element':
          return element;
        case 'controller':
          return getAU(element).controller;
        case 'view-model':
          return getAU(element).controller.viewModel;
        case 'view':
          return getAU(element).controller.view;
        default:
          var target = getAU(element)[apiName];
          if (target === undefined) {
            throw new Error('Attempted to reference "' + apiName + '", but it was not found amongst the target\'s API.');
          }
          return target.viewModel;
      }
    };
    return NameExpression;
  })();
  exports.NameExpression = NameExpression;
  var NameBinder = (function() {
    function NameBinder(property, target) {
      _classCallCheck(this, NameBinder);
      this.property = property;
      this.target = target;
      this.source = null;
      this.context = null;
    }
    NameBinder.prototype.bind = function bind(source) {
      if (this.source !== null) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.source = source || null;
      this.context = source.bindingContext || source.overrideContext || null;
      if (this.context !== null) {
        this.context[this.property] = this.target;
      }
    };
    NameBinder.prototype.unbind = function unbind() {
      if (this.source !== null) {
        this.source = null;
      }
      if (this.context !== null) {
        this.context[this.property] = null;
      }
    };
    return NameBinder;
  })();
  var lookupFunctions = {
    bindingBehaviors: function bindingBehaviors(name) {
      return null;
    },
    valueConverters: function valueConverters(name) {
      return null;
    }
  };
  var BindingEngine = (function() {
    _createClass(BindingEngine, null, [{
      key: 'inject',
      value: [ObserverLocator, Parser],
      enumerable: true
    }]);
    function BindingEngine(observerLocator, parser) {
      _classCallCheck(this, BindingEngine);
      this.observerLocator = observerLocator;
      this.parser = parser;
    }
    BindingEngine.prototype.createBindingExpression = function createBindingExpression(targetProperty, sourceExpression) {
      var mode = arguments.length <= 2 || arguments[2] === undefined ? bindingMode.oneWay : arguments[2];
      var lookupFunctions = arguments.length <= 3 || arguments[3] === undefined ? lookupFunctions : arguments[3];
      return (function() {
        return new BindingExpression(this.observerLocator, targetProperty, this.parser.parse(sourceExpression), mode, lookupFunctions);
      }).apply(this, arguments);
    };
    BindingEngine.prototype.propertyObserver = function propertyObserver(obj, propertyName) {
      var _this7 = this;
      return {subscribe: function subscribe(callback) {
          var observer = _this7.observerLocator.getObserver(obj, propertyName);
          observer.subscribe(callback);
          return {dispose: function dispose() {
              return observer.unsubscribe(callback);
            }};
        }};
    };
    BindingEngine.prototype.collectionObserver = function collectionObserver(collection) {
      var _this8 = this;
      return {subscribe: function subscribe(callback) {
          var observer = undefined;
          if (collection instanceof Array) {
            observer = _this8.observerLocator.getArrayObserver(collection);
          } else if (collection instanceof Map) {
            observer = _this8.observerLocator.getMapObserver(collection);
          } else if (collection instanceof Set) {
            observer = _this8.observerLocator.getSetObserver(collection);
          } else {
            throw new Error('collection must be an instance of Array, Map or Set.');
          }
          observer.subscribe(callback);
          return {dispose: function dispose() {
              return observer.unsubscribe(callback);
            }};
        }};
    };
    BindingEngine.prototype.expressionObserver = function expressionObserver(bindingContext, expression) {
      var scope = {
        bindingContext: bindingContext,
        overrideContext: createOverrideContext(bindingContext)
      };
      return new ExpressionObserver(scope, this.parser.parse(expression), this.observerLocator);
    };
    BindingEngine.prototype.parseExpression = function parseExpression(expression) {
      return this.parser.parse(expression);
    };
    BindingEngine.prototype.registerAdapter = function registerAdapter(adapter) {
      this.observerLocator.addAdapter(adapter);
    };
    return BindingEngine;
  })();
  exports.BindingEngine = BindingEngine;
  var ExpressionObserver = (function() {
    function ExpressionObserver(scope, expression, observerLocator) {
      _classCallCheck(this, _ExpressionObserver);
      this.scope = scope;
      this.expression = expression;
      this.observerLocator = observerLocator;
    }
    ExpressionObserver.prototype.subscribe = function subscribe(callback) {
      var _this9 = this;
      if (!this.hasSubscribers()) {
        this.oldValue = this.expression.evaluate(this.scope, lookupFunctions);
        this.expression.connect(this, this.scope);
      }
      this.addSubscriber(callback);
      return {dispose: function dispose() {
          if (_this9.removeSubscriber(callback) && !_this9.hasSubscribers()) {
            _this9.unobserve(true);
          }
        }};
    };
    ExpressionObserver.prototype.call = function call() {
      var newValue = this.expression.evaluate(this.scope, lookupFunctions);
      var oldValue = this.oldValue;
      if (newValue !== oldValue) {
        this.oldValue = newValue;
        this.callSubscribers(newValue, oldValue);
      }
      this._version++;
      this.expression.connect(this, this.scope);
      this.unobserve(false);
    };
    var _ExpressionObserver = ExpressionObserver;
    ExpressionObserver = subscriberCollection()(ExpressionObserver) || ExpressionObserver;
    ExpressionObserver = connectable()(ExpressionObserver) || ExpressionObserver;
    return ExpressionObserver;
  })();
  var setProto = Set.prototype;
  function getSetObserver(taskQueue, set) {
    return ModifySetObserver.create(taskQueue, set);
  }
  var ModifySetObserver = (function(_ModifyCollectionObserver4) {
    _inherits(ModifySetObserver, _ModifyCollectionObserver4);
    function ModifySetObserver(taskQueue, set) {
      _classCallCheck(this, ModifySetObserver);
      _ModifyCollectionObserver4.call(this, taskQueue, set);
    }
    ModifySetObserver.create = function create(taskQueue, set) {
      var observer = new ModifySetObserver(taskQueue, set);
      set['add'] = function() {
        var type = 'add';
        var hasValue = set.has(arguments[0]);
        var methodCallResult = setProto['add'].apply(set, arguments);
        if (!hasValue) {
          observer.addChangeRecord({
            type: type,
            object: set,
            value: arguments[0]
          });
        }
        return methodCallResult;
      };
      set['delete'] = function() {
        var hasValue = set.has(arguments[0]);
        var methodCallResult = setProto['delete'].apply(set, arguments);
        if (hasValue) {
          observer.addChangeRecord({
            type: 'delete',
            object: set,
            value: arguments[0]
          });
        }
        return methodCallResult;
      };
      set['clear'] = function() {
        var methodCallResult = setProto['clear'].apply(set, arguments);
        observer.addChangeRecord({
          type: 'clear',
          object: set
        });
        return methodCallResult;
      };
      return observer;
    };
    return ModifySetObserver;
  })(ModifyCollectionObserver);
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-binding@1.0.0-beta.1.0.5", ["npm:aurelia-binding@1.0.0-beta.1.0.5/aurelia-binding"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-dependency-injection@1.0.0-beta.1.0.1/aurelia-dependency-injection", ["exports", "npm:core-js@1.2.6", "npm:aurelia-metadata@1.0.0-beta.1", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _coreJs, _aureliaMetadata, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  var _classInvokers;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.invoker = invoker;
  exports.factory = factory;
  exports.registration = registration;
  exports.transient = transient;
  exports.singleton = singleton;
  exports.autoinject = autoinject;
  exports.inject = inject;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var resolver = _aureliaMetadata.protocol.create('aurelia:resolver', function(target) {
    if (!(typeof target.get === 'function')) {
      return 'Resolvers must implement: get(container: Container, key: any): any';
    }
    return true;
  });
  exports.resolver = resolver;
  var Lazy = (function() {
    function Lazy(key) {
      _classCallCheck(this, _Lazy);
      this._key = key;
    }
    Lazy.prototype.get = function get(container) {
      var _this = this;
      return function() {
        return container.get(_this._key);
      };
    };
    Lazy.of = function of(key) {
      return new Lazy(key);
    };
    var _Lazy = Lazy;
    Lazy = resolver()(Lazy) || Lazy;
    return Lazy;
  })();
  exports.Lazy = Lazy;
  var All = (function() {
    function All(key) {
      _classCallCheck(this, _All);
      this._key = key;
    }
    All.prototype.get = function get(container) {
      return container.getAll(this._key);
    };
    All.of = function of(key) {
      return new All(key);
    };
    var _All = All;
    All = resolver()(All) || All;
    return All;
  })();
  exports.All = All;
  var Optional = (function() {
    function Optional(key) {
      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
      _classCallCheck(this, _Optional);
      this._key = key;
      this._checkParent = checkParent;
    }
    Optional.prototype.get = function get(container) {
      if (container.hasResolver(this._key, this._checkParent)) {
        return container.get(this._key);
      }
      return null;
    };
    Optional.of = function of(key) {
      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
      return new Optional(key, checkParent);
    };
    var _Optional = Optional;
    Optional = resolver()(Optional) || Optional;
    return Optional;
  })();
  exports.Optional = Optional;
  var Parent = (function() {
    function Parent(key) {
      _classCallCheck(this, _Parent);
      this._key = key;
    }
    Parent.prototype.get = function get(container) {
      return container.parent ? container.parent.get(this._key) : null;
    };
    Parent.of = function of(key) {
      return new Parent(key);
    };
    var _Parent = Parent;
    Parent = resolver()(Parent) || Parent;
    return Parent;
  })();
  exports.Parent = Parent;
  var StrategyResolver = (function() {
    function StrategyResolver(strategy, state) {
      _classCallCheck(this, _StrategyResolver);
      this.strategy = strategy;
      this.state = state;
    }
    StrategyResolver.prototype.get = function get(container, key) {
      switch (this.strategy) {
        case 0:
          return this.state;
        case 1:
          var singleton = container.invoke(this.state);
          this.state = singleton;
          this.strategy = 0;
          return singleton;
        case 2:
          return container.invoke(this.state);
        case 3:
          return this.state(container, key, this);
        case 4:
          return this.state[0].get(container, key);
        case 5:
          return container.get(this.state);
        default:
          throw new Error('Invalid strategy: ' + this.strategy);
      }
    };
    var _StrategyResolver = StrategyResolver;
    StrategyResolver = resolver()(StrategyResolver) || StrategyResolver;
    return StrategyResolver;
  })();
  exports.StrategyResolver = StrategyResolver;
  function invoker(value) {
    return function(target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, value, target);
    };
  }
  function factory(potentialTarget) {
    var deco = function deco(target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.invoker, FactoryInvoker.instance, target);
    };
    return potentialTarget ? deco(potentialTarget) : deco;
  }
  var FactoryInvoker = (function() {
    function FactoryInvoker() {
      _classCallCheck(this, FactoryInvoker);
    }
    FactoryInvoker.prototype.invoke = function invoke(container, fn, dependencies) {
      var i = dependencies.length;
      var args = new Array(i);
      while (i--) {
        args[i] = container.get(dependencies[i]);
      }
      return fn.apply(undefined, args);
    };
    FactoryInvoker.prototype.invokeWithDynamicDependencies = function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
      var i = staticDependencies.length;
      var args = new Array(i);
      while (i--) {
        args[i] = container.get(staticDependencies[i]);
      }
      if (dynamicDependencies !== undefined) {
        args = args.concat(dynamicDependencies);
      }
      return fn.apply(undefined, args);
    };
    _createClass(FactoryInvoker, null, [{
      key: 'instance',
      value: new FactoryInvoker(),
      enumerable: true
    }]);
    return FactoryInvoker;
  })();
  exports.FactoryInvoker = FactoryInvoker;
  function registration(value) {
    return function(target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.registration, value, target);
    };
  }
  function transient(key) {
    return registration(new TransientRegistration(key));
  }
  function singleton(keyOrRegisterInChild) {
    var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
    return registration(new SingletonRegistration(keyOrRegisterInChild, registerInChild));
  }
  var TransientRegistration = (function() {
    function TransientRegistration(key) {
      _classCallCheck(this, TransientRegistration);
      this._key = key;
    }
    TransientRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
      var resolver = new StrategyResolver(2, fn);
      container.registerResolver(this._key || key, resolver);
      return resolver;
    };
    return TransientRegistration;
  })();
  exports.TransientRegistration = TransientRegistration;
  var SingletonRegistration = (function() {
    function SingletonRegistration(keyOrRegisterInChild) {
      var registerInChild = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
      _classCallCheck(this, SingletonRegistration);
      if (typeof keyOrRegisterInChild === 'boolean') {
        this._registerInChild = keyOrRegisterInChild;
      } else {
        this._key = keyOrRegisterInChild;
        this._registerInChild = registerInChild;
      }
    }
    SingletonRegistration.prototype.registerResolver = function registerResolver(container, key, fn) {
      var resolver = new StrategyResolver(1, fn);
      if (this._registerInChild) {
        container.registerResolver(this._key || key, resolver);
      } else {
        container.root.registerResolver(this._key || key, resolver);
      }
      return resolver;
    };
    return SingletonRegistration;
  })();
  exports.SingletonRegistration = SingletonRegistration;
  var badKeyError = 'key/value cannot be null or undefined. Are you trying to inject/register something that doesn\'t exist with DI?';
  var _emptyParameters = Object.freeze([]);
  exports._emptyParameters = _emptyParameters;
  _aureliaMetadata.metadata.registration = 'aurelia:registration';
  _aureliaMetadata.metadata.invoker = 'aurelia:invoker';
  var resolverDecorates = resolver.decorates;
  var InvocationHandler = (function() {
    function InvocationHandler(fn, invoker, dependencies) {
      _classCallCheck(this, InvocationHandler);
      this.fn = fn;
      this.invoker = invoker;
      this.dependencies = dependencies;
    }
    InvocationHandler.prototype.invoke = function invoke(container, dynamicDependencies) {
      return dynamicDependencies !== undefined ? this.invoker.invokeWithDynamicDependencies(container, this.fn, this.dependencies, dynamicDependencies) : this.invoker.invoke(container, this.fn, this.dependencies);
    };
    return InvocationHandler;
  })();
  exports.InvocationHandler = InvocationHandler;
  function invokeWithDynamicDependencies(container, fn, staticDependencies, dynamicDependencies) {
    var i = staticDependencies.length;
    var args = new Array(i);
    while (i--) {
      args[i] = container.get(staticDependencies[i]);
    }
    if (dynamicDependencies !== undefined) {
      args = args.concat(dynamicDependencies);
    }
    return Reflect.construct(fn, args);
  }
  var classInvokers = (_classInvokers = {}, _classInvokers[0] = {
    invoke: function invoke(container, Type) {
      return new Type();
    },
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[1] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]));
    },
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[2] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]));
    },
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[3] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));
    },
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[4] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]));
    },
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers[5] = {
    invoke: function invoke(container, Type, deps) {
      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]), container.get(deps[3]), container.get(deps[4]));
    },
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers.fallback = {
    invoke: invokeWithDynamicDependencies,
    invokeWithDynamicDependencies: invokeWithDynamicDependencies
  }, _classInvokers);
  var Container = (function() {
    function Container(configuration) {
      _classCallCheck(this, Container);
      if (configuration === undefined) {
        configuration = {};
      }
      this._configuration = configuration;
      this._onHandlerCreated = configuration.onHandlerCreated;
      this._handlers = configuration.handlers || (configuration.handlers = new Map());
      this._resolvers = new Map();
      this.root = this;
      this.parent = null;
    }
    Container.prototype.makeGlobal = function makeGlobal() {
      Container.instance = this;
      return this;
    };
    Container.prototype.setHandlerCreatedCallback = function setHandlerCreatedCallback(onHandlerCreated) {
      this._onHandlerCreated = onHandlerCreated;
      this._configuration.onHandlerCreated = onHandlerCreated;
    };
    Container.prototype.registerInstance = function registerInstance(key, instance) {
      this.registerResolver(key, new StrategyResolver(0, instance === undefined ? key : instance));
    };
    Container.prototype.registerSingleton = function registerSingleton(key, fn) {
      this.registerResolver(key, new StrategyResolver(1, fn === undefined ? key : fn));
    };
    Container.prototype.registerTransient = function registerTransient(key, fn) {
      this.registerResolver(key, new StrategyResolver(2, fn === undefined ? key : fn));
    };
    Container.prototype.registerHandler = function registerHandler(key, handler) {
      this.registerResolver(key, new StrategyResolver(3, handler));
    };
    Container.prototype.registerAlias = function registerAlias(originalKey, aliasKey) {
      this.registerResolver(aliasKey, new StrategyResolver(5, originalKey));
    };
    Container.prototype.registerResolver = function registerResolver(key, resolver) {
      if (key === null || key === undefined) {
        throw new Error(badKeyError);
      }
      var allResolvers = this._resolvers;
      var result = allResolvers.get(key);
      if (result === undefined) {
        allResolvers.set(key, resolver);
      } else if (result.strategy === 4) {
        result.state.push(resolver);
      } else {
        allResolvers.set(key, new StrategyResolver(4, [result, resolver]));
      }
    };
    Container.prototype.autoRegister = function autoRegister(fn, key) {
      var resolver = undefined;
      if (typeof fn === 'function') {
        var _registration = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.registration, fn);
        if (_registration === undefined) {
          resolver = new StrategyResolver(1, fn);
          this.registerResolver(key === undefined ? fn : key, resolver);
        } else {
          resolver = _registration.registerResolver(this, key === undefined ? fn : key, fn);
        }
      } else {
        resolver = new StrategyResolver(0, fn);
        this.registerResolver(key === undefined ? fn : key, resolver);
      }
      return resolver;
    };
    Container.prototype.autoRegisterAll = function autoRegisterAll(fns) {
      var i = fns.length;
      while (i--) {
        this.autoRegister(fns[i]);
      }
    };
    Container.prototype.unregister = function unregister(key) {
      this._resolvers['delete'](key);
    };
    Container.prototype.hasResolver = function hasResolver(key) {
      var checkParent = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
      if (key === null || key === undefined) {
        throw new Error(badKeyError);
      }
      return this._resolvers.has(key) || checkParent && this.parent !== null && this.parent.hasResolver(key, checkParent);
    };
    Container.prototype.get = function get(key) {
      if (key === null || key === undefined) {
        throw new Error(badKeyError);
      }
      if (key === Container) {
        return this;
      }
      if (resolverDecorates(key)) {
        return key.get(this, key);
      }
      var resolver = this._resolvers.get(key);
      if (resolver === undefined) {
        if (this.parent === null) {
          return this.autoRegister(key).get(this, key);
        }
        return this.parent._get(key);
      }
      return resolver.get(this, key);
    };
    Container.prototype._get = function _get(key) {
      var resolver = this._resolvers.get(key);
      if (resolver === undefined) {
        if (this.parent === null) {
          return this.autoRegister(key).get(this, key);
        }
        return this.parent._get(key);
      }
      return resolver.get(this, key);
    };
    Container.prototype.getAll = function getAll(key) {
      if (key === null || key === undefined) {
        throw new Error(badKeyError);
      }
      var resolver = this._resolvers.get(key);
      if (resolver === undefined) {
        if (this.parent === null) {
          return _emptyParameters;
        }
        return this.parent.getAll(key);
      }
      if (resolver.strategy === 4) {
        var state = resolver.state;
        var i = state.length;
        var results = new Array(i);
        while (i--) {
          results[i] = state[i].get(this, key);
        }
        return results;
      }
      return resolver.get(this, key);
    };
    Container.prototype.createChild = function createChild() {
      var child = new Container(this._configuration);
      child.root = this.root;
      child.parent = this;
      return child;
    };
    Container.prototype.invoke = function invoke(fn, dynamicDependencies) {
      try {
        var _handler = this._handlers.get(fn);
        if (_handler === undefined) {
          _handler = this._createInvocationHandler(fn);
          this._handlers.set(fn, _handler);
        }
        return _handler.invoke(this, dynamicDependencies);
      } catch (e) {
        throw new _aureliaPal.AggregateError('Error invoking ' + fn.name + '. Check the inner error for details.', e, true);
      }
    };
    Container.prototype._createInvocationHandler = function _createInvocationHandler(fn) {
      var dependencies = undefined;
      if (typeof fn.inject === 'function') {
        dependencies = fn.inject();
      } else if (fn.inject === undefined) {
        dependencies = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, fn) || _emptyParameters;
      } else {
        dependencies = fn.inject;
      }
      var invoker = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.invoker, fn) || classInvokers[dependencies.length] || classInvokers.fallback;
      var handler = new InvocationHandler(fn, invoker, dependencies);
      return this._onHandlerCreated !== undefined ? this._onHandlerCreated(handler) : handler;
    };
    return Container;
  })();
  exports.Container = Container;
  function autoinject(potentialTarget) {
    var deco = function deco(target) {
      target.inject = _aureliaMetadata.metadata.getOwn(_aureliaMetadata.metadata.paramTypes, target) || _emptyParameters;
    };
    return potentialTarget ? deco(potentialTarget) : deco;
  }
  function inject() {
    for (var _len = arguments.length,
        rest = Array(_len),
        _key = 0; _key < _len; _key++) {
      rest[_key] = arguments[_key];
    }
    return function(target, key, descriptor) {
      if (descriptor) {
        var _fn = descriptor.value;
        _fn.inject = rest;
      } else {
        target.inject = rest;
      }
    };
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", ["npm:aurelia-dependency-injection@1.0.0-beta.1.0.1/aurelia-dependency-injection"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating@1.0.0-beta.1.0.3/aurelia-templating", ["exports", "npm:core-js@1.2.6", "npm:aurelia-logging@1.0.0-beta.1.1.1", "npm:aurelia-metadata@1.0.0-beta.1", "npm:aurelia-path@1.0.0-beta.1", "npm:aurelia-loader@1.0.0-beta.1.0.1", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-binding@1.0.0-beta.1.0.5", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-task-queue@1.0.0-beta.1.0.1"], function(exports, _coreJs, _aureliaLogging, _aureliaMetadata, _aureliaPath, _aureliaLoader, _aureliaPal, _aureliaBinding, _aureliaDependencyInjection, _aureliaTaskQueue) {
  'use strict';
  exports.__esModule = true;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports._hyphenate = _hyphenate;
  exports.children = children;
  exports.child = child;
  exports.resource = resource;
  exports.behavior = behavior;
  exports.customElement = customElement;
  exports.customAttribute = customAttribute;
  exports.templateController = templateController;
  exports.bindable = bindable;
  exports.dynamicOptions = dynamicOptions;
  exports.useShadowDOM = useShadowDOM;
  exports.processContent = processContent;
  exports.containerless = containerless;
  exports.useViewStrategy = useViewStrategy;
  exports.useView = useView;
  exports.inlineView = inlineView;
  exports.noView = noView;
  exports.elementConfig = elementConfig;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var animationEvent = {
    enterBegin: 'animation:enter:begin',
    enterActive: 'animation:enter:active',
    enterDone: 'animation:enter:done',
    enterTimeout: 'animation:enter:timeout',
    leaveBegin: 'animation:leave:begin',
    leaveActive: 'animation:leave:active',
    leaveDone: 'animation:leave:done',
    leaveTimeout: 'animation:leave:timeout',
    staggerNext: 'animation:stagger:next',
    removeClassBegin: 'animation:remove-class:begin',
    removeClassActive: 'animation:remove-class:active',
    removeClassDone: 'animation:remove-class:done',
    removeClassTimeout: 'animation:remove-class:timeout',
    addClassBegin: 'animation:add-class:begin',
    addClassActive: 'animation:add-class:active',
    addClassDone: 'animation:add-class:done',
    addClassTimeout: 'animation:add-class:timeout',
    animateBegin: 'animation:animate:begin',
    animateActive: 'animation:animate:active',
    animateDone: 'animation:animate:done',
    animateTimeout: 'animation:animate:timeout',
    sequenceBegin: 'animation:sequence:begin',
    sequenceDone: 'animation:sequence:done'
  };
  exports.animationEvent = animationEvent;
  var Animator = (function() {
    function Animator() {
      _classCallCheck(this, Animator);
    }
    Animator.prototype.enter = function enter(element) {
      return Promise.resolve(false);
    };
    Animator.prototype.leave = function leave(element) {
      return Promise.resolve(false);
    };
    Animator.prototype.removeClass = function removeClass(element, className) {
      element.classList.remove(className);
      return Promise.resolve(false);
    };
    Animator.prototype.addClass = function addClass(element, className) {
      element.classList.add(className);
      return Promise.resolve(false);
    };
    Animator.prototype.animate = function animate(element, className) {
      return Promise.resolve(false);
    };
    Animator.prototype.runSequence = function runSequence(animations) {};
    Animator.prototype.registerEffect = function registerEffect(effectName, properties) {};
    Animator.prototype.unregisterEffect = function unregisterEffect(effectName) {};
    return Animator;
  })();
  exports.Animator = Animator;
  var capitalMatcher = /([A-Z])/g;
  function addHyphenAndLower(char) {
    return '-' + char.toLowerCase();
  }
  function _hyphenate(name) {
    return (name.charAt(0).toLowerCase() + name.slice(1)).replace(capitalMatcher, addHyphenAndLower);
  }
  var ResourceLoadContext = (function() {
    function ResourceLoadContext() {
      _classCallCheck(this, ResourceLoadContext);
      this.dependencies = {};
    }
    ResourceLoadContext.prototype.addDependency = function addDependency(url) {
      this.dependencies[url] = true;
    };
    ResourceLoadContext.prototype.hasDependency = function hasDependency(url) {
      return url in this.dependencies;
    };
    return ResourceLoadContext;
  })();
  exports.ResourceLoadContext = ResourceLoadContext;
  var ViewCompileInstruction = (function() {
    _createClass(ViewCompileInstruction, null, [{
      key: 'normal',
      value: new ViewCompileInstruction(),
      enumerable: true
    }]);
    function ViewCompileInstruction() {
      var targetShadowDOM = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
      var compileSurrogate = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
      _classCallCheck(this, ViewCompileInstruction);
      this.targetShadowDOM = targetShadowDOM;
      this.compileSurrogate = compileSurrogate;
      this.associatedModuleId = null;
    }
    return ViewCompileInstruction;
  })();
  exports.ViewCompileInstruction = ViewCompileInstruction;
  var BehaviorInstruction = (function() {
    BehaviorInstruction.enhance = function enhance() {
      var instruction = new BehaviorInstruction();
      instruction.enhance = true;
      return instruction;
    };
    BehaviorInstruction.unitTest = function unitTest(type, attributes) {
      var instruction = new BehaviorInstruction();
      instruction.type = type;
      instruction.attributes = attributes || {};
      return instruction;
    };
    BehaviorInstruction.element = function element(node, type) {
      var instruction = new BehaviorInstruction();
      instruction.type = type;
      instruction.attributes = {};
      instruction.anchorIsContainer = !(node.hasAttribute('containerless') || type.containerless);
      instruction.initiatedByBehavior = true;
      return instruction;
    };
    BehaviorInstruction.attribute = function attribute(attrName, type) {
      var instruction = new BehaviorInstruction();
      instruction.attrName = attrName;
      instruction.type = type || null;
      instruction.attributes = {};
      return instruction;
    };
    BehaviorInstruction.dynamic = function dynamic(host, viewModel, viewFactory) {
      var instruction = new BehaviorInstruction();
      instruction.host = host;
      instruction.viewModel = viewModel;
      instruction.viewFactory = viewFactory;
      return instruction;
    };
    _createClass(BehaviorInstruction, null, [{
      key: 'normal',
      value: new BehaviorInstruction(),
      enumerable: true
    }]);
    function BehaviorInstruction() {
      _classCallCheck(this, BehaviorInstruction);
      this.initiatedByBehavior = false;
      this.enhance = false;
      this.partReplacements = null;
      this.viewFactory = null;
      this.originalAttrName = null;
      this.skipContentProcessing = false;
      this.contentFactory = null;
      this.viewModel = null;
      this.anchorIsContainer = false;
      this.host = null;
      this.attributes = null;
      this.type = null;
      this.attrName = null;
    }
    return BehaviorInstruction;
  })();
  exports.BehaviorInstruction = BehaviorInstruction;
  var TargetInstruction = (function() {
    TargetInstruction.contentSelector = function contentSelector(node, parentInjectorId) {
      var instruction = new TargetInstruction();
      instruction.parentInjectorId = parentInjectorId;
      instruction.contentSelector = true;
      instruction.selector = node.getAttribute('select');
      return instruction;
    };
    TargetInstruction.contentExpression = function contentExpression(expression) {
      var instruction = new TargetInstruction();
      instruction.contentExpression = expression;
      return instruction;
    };
    TargetInstruction.lifting = function lifting(parentInjectorId, liftingInstruction) {
      var instruction = new TargetInstruction();
      instruction.parentInjectorId = parentInjectorId;
      instruction.expressions = TargetInstruction.noExpressions;
      instruction.behaviorInstructions = [liftingInstruction];
      instruction.viewFactory = liftingInstruction.viewFactory;
      instruction.providers = [liftingInstruction.type.target];
      instruction.lifting = true;
      return instruction;
    };
    TargetInstruction.normal = function normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction) {
      var instruction = new TargetInstruction();
      instruction.injectorId = injectorId;
      instruction.parentInjectorId = parentInjectorId;
      instruction.providers = providers;
      instruction.behaviorInstructions = behaviorInstructions;
      instruction.expressions = expressions;
      instruction.anchorIsContainer = elementInstruction ? elementInstruction.anchorIsContainer : true;
      instruction.elementInstruction = elementInstruction;
      return instruction;
    };
    TargetInstruction.surrogate = function surrogate(providers, behaviorInstructions, expressions, values) {
      var instruction = new TargetInstruction();
      instruction.expressions = expressions;
      instruction.behaviorInstructions = behaviorInstructions;
      instruction.providers = providers;
      instruction.values = values;
      return instruction;
    };
    _createClass(TargetInstruction, null, [{
      key: 'noExpressions',
      value: Object.freeze([]),
      enumerable: true
    }]);
    function TargetInstruction() {
      _classCallCheck(this, TargetInstruction);
      this.injectorId = null;
      this.parentInjectorId = null;
      this.contentSelector = false;
      this.selector = null;
      this.contentExpression = null;
      this.expressions = null;
      this.behaviorInstructions = null;
      this.providers = null;
      this.viewFactory = null;
      this.anchorIsContainer = false;
      this.elementInstruction = null;
      this.lifting = false;
      this.values = null;
    }
    return TargetInstruction;
  })();
  exports.TargetInstruction = TargetInstruction;
  var viewStrategy = _aureliaMetadata.protocol.create('aurelia:view-strategy', {
    validate: function validate(target) {
      if (!(typeof target.loadViewFactory === 'function')) {
        return 'View strategies must implement: loadViewFactory(viewEngine: ViewEngine, compileInstruction: ViewCompileInstruction, loadContext?: ResourceLoadContext): Promise<ViewFactory>';
      }
      return true;
    },
    compose: function compose(target) {
      if (!(typeof target.makeRelativeTo === 'function')) {
        target.makeRelativeTo = _aureliaPal.PLATFORM.noop;
      }
    }
  });
  exports.viewStrategy = viewStrategy;
  var RelativeViewStrategy = (function() {
    function RelativeViewStrategy(path) {
      _classCallCheck(this, _RelativeViewStrategy);
      this.path = path;
      this.absolutePath = null;
    }
    RelativeViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext) {
      if (this.absolutePath === null && this.moduleId) {
        this.absolutePath = _aureliaPath.relativeToFile(this.path, this.moduleId);
      }
      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(this.absolutePath || this.path, compileInstruction, loadContext);
    };
    RelativeViewStrategy.prototype.makeRelativeTo = function makeRelativeTo(file) {
      if (this.absolutePath === null) {
        this.absolutePath = _aureliaPath.relativeToFile(this.path, file);
      }
    };
    var _RelativeViewStrategy = RelativeViewStrategy;
    RelativeViewStrategy = viewStrategy()(RelativeViewStrategy) || RelativeViewStrategy;
    return RelativeViewStrategy;
  })();
  exports.RelativeViewStrategy = RelativeViewStrategy;
  var ConventionalViewStrategy = (function() {
    function ConventionalViewStrategy(viewLocator, origin) {
      _classCallCheck(this, _ConventionalViewStrategy);
      this.moduleId = origin.moduleId;
      this.viewUrl = viewLocator.convertOriginToViewUrl(origin);
    }
    ConventionalViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext) {
      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(this.viewUrl, compileInstruction, loadContext);
    };
    var _ConventionalViewStrategy = ConventionalViewStrategy;
    ConventionalViewStrategy = viewStrategy()(ConventionalViewStrategy) || ConventionalViewStrategy;
    return ConventionalViewStrategy;
  })();
  exports.ConventionalViewStrategy = ConventionalViewStrategy;
  var NoViewStrategy = (function() {
    function NoViewStrategy() {
      _classCallCheck(this, _NoViewStrategy);
    }
    NoViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext) {
      return Promise.resolve(null);
    };
    var _NoViewStrategy = NoViewStrategy;
    NoViewStrategy = viewStrategy()(NoViewStrategy) || NoViewStrategy;
    return NoViewStrategy;
  })();
  exports.NoViewStrategy = NoViewStrategy;
  var TemplateRegistryViewStrategy = (function() {
    function TemplateRegistryViewStrategy(moduleId, entry) {
      _classCallCheck(this, _TemplateRegistryViewStrategy);
      this.moduleId = moduleId;
      this.entry = entry;
    }
    TemplateRegistryViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext) {
      var entry = this.entry;
      if (entry.factoryIsReady) {
        return Promise.resolve(entry.factory);
      }
      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(entry, compileInstruction, loadContext);
    };
    var _TemplateRegistryViewStrategy = TemplateRegistryViewStrategy;
    TemplateRegistryViewStrategy = viewStrategy()(TemplateRegistryViewStrategy) || TemplateRegistryViewStrategy;
    return TemplateRegistryViewStrategy;
  })();
  exports.TemplateRegistryViewStrategy = TemplateRegistryViewStrategy;
  var InlineViewStrategy = (function() {
    function InlineViewStrategy(markup, dependencies, dependencyBaseUrl) {
      _classCallCheck(this, _InlineViewStrategy);
      this.markup = markup;
      this.dependencies = dependencies || null;
      this.dependencyBaseUrl = dependencyBaseUrl || '';
    }
    InlineViewStrategy.prototype.loadViewFactory = function loadViewFactory(viewEngine, compileInstruction, loadContext) {
      var entry = this.entry;
      var dependencies = this.dependencies;
      if (entry && entry.factoryIsReady) {
        return Promise.resolve(entry.factory);
      }
      this.entry = entry = new _aureliaLoader.TemplateRegistryEntry(this.moduleId || this.dependencyBaseUrl);
      entry.template = _aureliaPal.DOM.createTemplateFromMarkup(this.markup);
      if (dependencies !== null) {
        for (var i = 0,
            ii = dependencies.length; i < ii; ++i) {
          var current = dependencies[i];
          if (typeof current === 'string' || typeof current === 'function') {
            entry.addDependency(current);
          } else {
            entry.addDependency(current.from, current.as);
          }
        }
      }
      compileInstruction.associatedModuleId = this.moduleId;
      return viewEngine.loadViewFactory(entry, compileInstruction, loadContext);
    };
    var _InlineViewStrategy = InlineViewStrategy;
    InlineViewStrategy = viewStrategy()(InlineViewStrategy) || InlineViewStrategy;
    return InlineViewStrategy;
  })();
  exports.InlineViewStrategy = InlineViewStrategy;
  var ViewLocator = (function() {
    function ViewLocator() {
      _classCallCheck(this, ViewLocator);
    }
    ViewLocator.prototype.getViewStrategy = function getViewStrategy(value) {
      if (!value) {
        return null;
      }
      if (typeof value === 'object' && 'getViewStrategy' in value) {
        var _origin = _aureliaMetadata.Origin.get(value.constructor);
        value = value.getViewStrategy();
        if (typeof value === 'string') {
          value = new RelativeViewStrategy(value);
        }
        viewStrategy.assert(value);
        if (_origin) {
          value.makeRelativeTo(_origin.moduleId);
        }
        return value;
      }
      if (typeof value === 'string') {
        value = new RelativeViewStrategy(value);
      }
      if (viewStrategy.validate(value)) {
        return value;
      }
      if (typeof value !== 'function') {
        value = value.constructor;
      }
      var origin = _aureliaMetadata.Origin.get(value);
      var strategy = _aureliaMetadata.metadata.get(ViewLocator.viewStrategyMetadataKey, value);
      if (!strategy) {
        if (!origin) {
          throw new Error('Cannot determinte default view strategy for object.', value);
        }
        strategy = this.createFallbackViewStrategy(origin);
      } else if (origin) {
        strategy.moduleId = origin.moduleId;
      }
      return strategy;
    };
    ViewLocator.prototype.createFallbackViewStrategy = function createFallbackViewStrategy(origin) {
      return new ConventionalViewStrategy(this, origin);
    };
    ViewLocator.prototype.convertOriginToViewUrl = function convertOriginToViewUrl(origin) {
      var moduleId = origin.moduleId;
      var id = moduleId.endsWith('.js') || moduleId.endsWith('.ts') ? moduleId.substring(0, moduleId.length - 3) : moduleId;
      return id + '.html';
    };
    _createClass(ViewLocator, null, [{
      key: 'viewStrategyMetadataKey',
      value: 'aurelia:view-strategy',
      enumerable: true
    }]);
    return ViewLocator;
  })();
  exports.ViewLocator = ViewLocator;
  var BindingLanguage = (function() {
    function BindingLanguage() {
      _classCallCheck(this, BindingLanguage);
    }
    BindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, attrName, attrValue) {
      throw new Error('A BindingLanguage must implement inspectAttribute(...)');
    };
    BindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, info, existingInstruction) {
      throw new Error('A BindingLanguage must implement createAttributeInstruction(...)');
    };
    BindingLanguage.prototype.parseText = function parseText(resources, value) {
      throw new Error('A BindingLanguage must implement parseText(...)');
    };
    return BindingLanguage;
  })();
  exports.BindingLanguage = BindingLanguage;
  function register(lookup, name, resource, type) {
    if (!name) {
      return;
    }
    var existing = lookup[name];
    if (existing) {
      if (existing !== resource) {
        throw new Error('Attempted to register ' + type + ' when one with the same name already exists. Name: ' + name + '.');
      }
      return;
    }
    lookup[name] = resource;
  }
  var ViewResources = (function() {
    function ViewResources(parent, viewUrl) {
      _classCallCheck(this, ViewResources);
      this.bindingLanguage = null;
      this.parent = parent || null;
      this.hasParent = this.parent !== null;
      this.viewUrl = viewUrl || '';
      this.lookupFunctions = {
        valueConverters: this.getValueConverter.bind(this),
        bindingBehaviors: this.getBindingBehavior.bind(this)
      };
      this.attributes = {};
      this.elements = {};
      this.valueConverters = {};
      this.bindingBehaviors = {};
      this.attributeMap = {};
      this.hook1 = null;
      this.hook2 = null;
      this.hook3 = null;
      this.additionalHooks = null;
    }
    ViewResources.prototype._onBeforeCompile = function _onBeforeCompile(content, resources, instruction) {
      if (this.hasParent) {
        this.parent._onBeforeCompile(content, resources, instruction);
      }
      if (this.hook1 !== null) {
        this.hook1.beforeCompile(content, resources, instruction);
        if (this.hook2 !== null) {
          this.hook2.beforeCompile(content, resources, instruction);
          if (this.hook3 !== null) {
            this.hook3.beforeCompile(content, resources, instruction);
            if (this.additionalHooks !== null) {
              var hooks = this.additionalHooks;
              for (var i = 0,
                  _length = hooks.length; i < _length; ++i) {
                hooks[i].beforeCompile(content, resources, instruction);
              }
            }
          }
        }
      }
    };
    ViewResources.prototype._onAfterCompile = function _onAfterCompile(viewFactory) {
      if (this.hasParent) {
        this.parent._onAfterCompile(viewFactory);
      }
      if (this.hook1 !== null) {
        this.hook1.afterCompile(viewFactory);
        if (this.hook2 !== null) {
          this.hook2.afterCompile(viewFactory);
          if (this.hook3 !== null) {
            this.hook3.afterCompile(viewFactory);
            if (this.additionalHooks !== null) {
              var hooks = this.additionalHooks;
              for (var i = 0,
                  _length2 = hooks.length; i < _length2; ++i) {
                hooks[i].afterCompile(viewFactory);
              }
            }
          }
        }
      }
    };
    ViewResources.prototype._onBeforeCreate = function _onBeforeCreate(viewFactory, container, content, instruction, bindingContext) {
      if (this.hasParent) {
        this.parent._onBeforeCreate(viewFactory, container, content, instruction, bindingContext);
      }
      if (this.hook1 !== null) {
        this.hook1.beforeCreate(viewFactory, container, content, instruction, bindingContext);
        if (this.hook2 !== null) {
          this.hook2.beforeCreate(viewFactory, container, content, instruction, bindingContext);
          if (this.hook3 !== null) {
            this.hook3.beforeCreate(viewFactory, container, content, instruction, bindingContext);
            if (this.additionalHooks !== null) {
              var hooks = this.additionalHooks;
              for (var i = 0,
                  _length3 = hooks.length; i < _length3; ++i) {
                hooks[i].beforeCreate(viewFactory, container, content, instruction, bindingContext);
              }
            }
          }
        }
      }
    };
    ViewResources.prototype._onAfterCreate = function _onAfterCreate(view) {
      if (this.hasParent) {
        this.parent._onAfterCreate(view);
      }
      if (this.hook1 !== null) {
        this.hook1.afterCreate(view);
        if (this.hook2 !== null) {
          this.hook2.afterCreate(view);
          if (this.hook3 !== null) {
            this.hook3.afterCreate(view);
            if (this.additionalHooks !== null) {
              var hooks = this.additionalHooks;
              for (var i = 0,
                  _length4 = hooks.length; i < _length4; ++i) {
                hooks[i].afterCreate(view);
              }
            }
          }
        }
      }
    };
    ViewResources.prototype.registerViewEngineHooks = function registerViewEngineHooks(hooks) {
      if (hooks.beforeCompile === undefined)
        hooks.beforeCompile = _aureliaPal.PLATFORM.noop;
      if (hooks.afterCompile === undefined)
        hooks.afterCompile = _aureliaPal.PLATFORM.noop;
      if (hooks.beforeCreate === undefined)
        hooks.beforeCreate = _aureliaPal.PLATFORM.noop;
      if (hooks.afterCreate === undefined)
        hooks.afterCreate = _aureliaPal.PLATFORM.noop;
      if (this.hook1 === null)
        this.hook1 = hooks;
      else if (this.hook2 === null)
        this.hook2 = hooks;
      else if (this.hook3 === null)
        this.hook3 = hooks;
      else {
        if (this.additionalHooks === null) {
          this.additionalHooks = [];
        }
        this.additionalHooks.push(hooks);
      }
    };
    ViewResources.prototype.getBindingLanguage = function getBindingLanguage(bindingLanguageFallback) {
      return this.bindingLanguage || (this.bindingLanguage = bindingLanguageFallback);
    };
    ViewResources.prototype.patchInParent = function patchInParent(newParent) {
      var originalParent = this.parent;
      this.parent = newParent || null;
      this.hasParent = this.parent !== null;
      if (newParent.parent === null) {
        newParent.parent = originalParent;
        newParent.hasParent = originalParent !== null;
      }
    };
    ViewResources.prototype.relativeToView = function relativeToView(path) {
      return _aureliaPath.relativeToFile(path, this.viewUrl);
    };
    ViewResources.prototype.registerElement = function registerElement(tagName, behavior) {
      register(this.elements, tagName, behavior, 'an Element');
    };
    ViewResources.prototype.getElement = function getElement(tagName) {
      return this.elements[tagName] || (this.hasParent ? this.parent.getElement(tagName) : null);
    };
    ViewResources.prototype.mapAttribute = function mapAttribute(attribute) {
      return this.attributeMap[attribute] || (this.hasParent ? this.parent.mapAttribute(attribute) : null);
    };
    ViewResources.prototype.registerAttribute = function registerAttribute(attribute, behavior, knownAttribute) {
      this.attributeMap[attribute] = knownAttribute;
      register(this.attributes, attribute, behavior, 'an Attribute');
    };
    ViewResources.prototype.getAttribute = function getAttribute(attribute) {
      return this.attributes[attribute] || (this.hasParent ? this.parent.getAttribute(attribute) : null);
    };
    ViewResources.prototype.registerValueConverter = function registerValueConverter(name, valueConverter) {
      register(this.valueConverters, name, valueConverter, 'a ValueConverter');
    };
    ViewResources.prototype.getValueConverter = function getValueConverter(name) {
      return this.valueConverters[name] || (this.hasParent ? this.parent.getValueConverter(name) : null);
    };
    ViewResources.prototype.registerBindingBehavior = function registerBindingBehavior(name, bindingBehavior) {
      register(this.bindingBehaviors, name, bindingBehavior, 'a BindingBehavior');
    };
    ViewResources.prototype.getBindingBehavior = function getBindingBehavior(name) {
      return this.bindingBehaviors[name] || (this.hasParent ? this.parent.getBindingBehavior(name) : null);
    };
    return ViewResources;
  })();
  exports.ViewResources = ViewResources;
  var View = (function() {
    function View(viewFactory, fragment, controllers, bindings, children, contentSelectors) {
      _classCallCheck(this, View);
      this.viewFactory = viewFactory;
      this.fragment = fragment;
      this.controllers = controllers;
      this.bindings = bindings;
      this.children = children;
      this.contentSelectors = contentSelectors;
      this.firstChild = fragment.firstChild;
      this.lastChild = fragment.lastChild;
      this.fromCache = false;
      this.isBound = false;
      this.isAttached = false;
      this.fromCache = false;
      this.bindingContext = null;
      this.overrideContext = null;
      this.controller = null;
      this.viewModelScope = null;
      this._isUserControlled = false;
    }
    View.prototype.returnToCache = function returnToCache() {
      this.viewFactory.returnViewToCache(this);
    };
    View.prototype.created = function created() {
      var i = undefined;
      var ii = undefined;
      var controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].created(this);
      }
    };
    View.prototype.bind = function bind(bindingContext, overrideContext, _systemUpdate) {
      var controllers = undefined;
      var bindings = undefined;
      var children = undefined;
      var i = undefined;
      var ii = undefined;
      if (_systemUpdate && this._isUserControlled) {
        return;
      }
      if (this.isBound) {
        if (this.bindingContext === bindingContext) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.bindingContext = bindingContext;
      this.overrideContext = overrideContext || _aureliaBinding.createOverrideContext(bindingContext);
      bindings = this.bindings;
      for (i = 0, ii = bindings.length; i < ii; ++i) {
        bindings[i].bind(this);
      }
      if (this.viewModelScope !== null) {
        bindingContext.bind(this.viewModelScope.bindingContext, this.viewModelScope.overrideContext);
        this.viewModelScope = null;
      }
      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].bind(this);
      }
      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].bind(bindingContext, overrideContext, true);
      }
    };
    View.prototype.addBinding = function addBinding(binding) {
      this.bindings.push(binding);
      if (this.isBound) {
        binding.bind(this.bindingContext);
      }
    };
    View.prototype.unbind = function unbind() {
      var controllers = undefined;
      var bindings = undefined;
      var children = undefined;
      var i = undefined;
      var ii = undefined;
      if (this.isBound) {
        this.isBound = false;
        this.bindingContext = null;
        this.overrideContext = null;
        if (this.controller !== null) {
          this.controller.unbind();
        }
        bindings = this.bindings;
        for (i = 0, ii = bindings.length; i < ii; ++i) {
          bindings[i].unbind();
        }
        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
          controllers[i].unbind();
        }
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].unbind();
        }
      }
    };
    View.prototype.insertNodesBefore = function insertNodesBefore(refNode) {
      var parent = refNode.parentNode;
      parent.insertBefore(this.fragment, refNode);
    };
    View.prototype.appendNodesTo = function appendNodesTo(parent) {
      parent.appendChild(this.fragment);
    };
    View.prototype.removeNodes = function removeNodes() {
      var start = this.firstChild;
      var end = this.lastChild;
      var fragment = this.fragment;
      var next = undefined;
      var current = start;
      var loop = true;
      while (loop) {
        if (current === end) {
          loop = false;
        }
        next = current.nextSibling;
        fragment.appendChild(current);
        current = next;
      }
    };
    View.prototype.attached = function attached() {
      var controllers = undefined;
      var children = undefined;
      var i = undefined;
      var ii = undefined;
      if (this.isAttached) {
        return;
      }
      this.isAttached = true;
      if (this.controller !== null) {
        this.controller.attached();
      }
      controllers = this.controllers;
      for (i = 0, ii = controllers.length; i < ii; ++i) {
        controllers[i].attached();
      }
      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].attached();
      }
    };
    View.prototype.detached = function detached() {
      var controllers = undefined;
      var children = undefined;
      var i = undefined;
      var ii = undefined;
      if (this.isAttached) {
        this.isAttached = false;
        if (this.controller !== null) {
          this.controller.detached();
        }
        controllers = this.controllers;
        for (i = 0, ii = controllers.length; i < ii; ++i) {
          controllers[i].detached();
        }
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].detached();
        }
      }
    };
    return View;
  })();
  exports.View = View;
  var placeholder = [];
  function findInsertionPoint(groups, index) {
    var insertionPoint = undefined;
    while (!insertionPoint && index >= 0) {
      insertionPoint = groups[index][0];
      index--;
    }
    return insertionPoint;
  }
  var _ContentSelector = (function() {
    _ContentSelector.applySelectors = function applySelectors(view, contentSelectors, callback) {
      var currentChild = view.fragment.firstChild;
      var contentMap = new Map();
      var nextSibling = undefined;
      var i = undefined;
      var ii = undefined;
      var contentSelector = undefined;
      while (currentChild) {
        nextSibling = currentChild.nextSibling;
        if (currentChild.isContentProjectionSource) {
          var viewSlotSelectors = contentSelectors.map(function(x) {
            return x.copyForViewSlot();
          });
          currentChild.viewSlot._installContentSelectors(viewSlotSelectors);
        } else {
          for (i = 0, ii = contentSelectors.length; i < ii; i++) {
            contentSelector = contentSelectors[i];
            if (contentSelector.matches(currentChild)) {
              var elements = contentMap.get(contentSelector);
              if (!elements) {
                elements = [];
                contentMap.set(contentSelector, elements);
              }
              elements.push(currentChild);
              break;
            }
          }
        }
        currentChild = nextSibling;
      }
      for (i = 0, ii = contentSelectors.length; i < ii; ++i) {
        contentSelector = contentSelectors[i];
        callback(contentSelector, contentMap.get(contentSelector) || placeholder);
      }
    };
    function _ContentSelector(anchor, selector) {
      _classCallCheck(this, _ContentSelector);
      this.anchor = anchor;
      this.selector = selector;
      this.all = !this.selector;
      this.groups = [];
    }
    _ContentSelector.prototype.copyForViewSlot = function copyForViewSlot() {
      return new _ContentSelector(this.anchor, this.selector);
    };
    _ContentSelector.prototype.matches = function matches(node) {
      return this.all || node.nodeType === 1 && node.matches(this.selector);
    };
    _ContentSelector.prototype.add = function add(group) {
      var anchor = this.anchor;
      var parent = anchor.parentNode;
      var i = undefined;
      var ii = undefined;
      for (i = 0, ii = group.length; i < ii; ++i) {
        parent.insertBefore(group[i], anchor);
      }
      this.groups.push(group);
    };
    _ContentSelector.prototype.insert = function insert(index, group) {
      if (group.length) {
        var anchor = findInsertionPoint(this.groups, index) || this.anchor;
        var _parent = anchor.parentNode;
        var i = undefined;
        var ii = undefined;
        for (i = 0, ii = group.length; i < ii; ++i) {
          _parent.insertBefore(group[i], anchor);
        }
      }
      this.groups.splice(index, 0, group);
    };
    _ContentSelector.prototype.removeAt = function removeAt(index, fragment) {
      var group = this.groups[index];
      var i = undefined;
      var ii = undefined;
      for (i = 0, ii = group.length; i < ii; ++i) {
        fragment.appendChild(group[i]);
      }
      this.groups.splice(index, 1);
    };
    return _ContentSelector;
  })();
  exports._ContentSelector = _ContentSelector;
  function getAnimatableElement(view) {
    var firstChild = view.firstChild;
    if (firstChild !== null && firstChild !== undefined && firstChild.nodeType === 8) {
      var _element = _aureliaPal.DOM.nextElementSibling(firstChild);
      if (_element !== null && _element !== undefined && _element.nodeType === 1 && _element.classList.contains('au-animate')) {
        return _element;
      }
    }
    return null;
  }
  var ViewSlot = (function() {
    function ViewSlot(anchor, anchorIsContainer) {
      var animator = arguments.length <= 2 || arguments[2] === undefined ? Animator.instance : arguments[2];
      _classCallCheck(this, ViewSlot);
      this.anchor = anchor;
      this.viewAddMethod = anchorIsContainer ? 'appendNodesTo' : 'insertNodesBefore';
      this.bindingContext = null;
      this.animator = animator;
      this.children = [];
      this.isBound = false;
      this.isAttached = false;
      this.contentSelectors = null;
      anchor.viewSlot = this;
      anchor.isContentProjectionSource = false;
    }
    ViewSlot.prototype.transformChildNodesIntoView = function transformChildNodesIntoView() {
      var parent = this.anchor;
      this.children.push({
        fragment: parent,
        firstChild: parent.firstChild,
        lastChild: parent.lastChild,
        returnToCache: function returnToCache() {},
        removeNodes: function removeNodes() {
          var last = undefined;
          while (last = parent.lastChild) {
            parent.removeChild(last);
          }
        },
        created: function created() {},
        bind: function bind() {},
        unbind: function unbind() {},
        attached: function attached() {},
        detached: function detached() {}
      });
    };
    ViewSlot.prototype.bind = function bind(bindingContext, overrideContext) {
      var i = undefined;
      var ii = undefined;
      var children = undefined;
      if (this.isBound) {
        if (this.bindingContext === bindingContext) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.bindingContext = bindingContext = bindingContext || this.bindingContext;
      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        children[i].bind(bindingContext, overrideContext, true);
      }
    };
    ViewSlot.prototype.unbind = function unbind() {
      if (this.isBound) {
        var i = undefined;
        var ii = undefined;
        var _children = this.children;
        this.isBound = false;
        this.bindingContext = null;
        for (i = 0, ii = _children.length; i < ii; ++i) {
          _children[i].unbind();
        }
      }
    };
    ViewSlot.prototype.add = function add(view) {
      view[this.viewAddMethod](this.anchor);
      this.children.push(view);
      if (this.isAttached) {
        view.attached();
        var animatableElement = getAnimatableElement(view);
        if (animatableElement !== null) {
          return this.animator.enter(animatableElement);
        }
      }
    };
    ViewSlot.prototype.insert = function insert(index, view) {
      var children = this.children;
      var length = children.length;
      if (index === 0 && length === 0 || index >= length) {
        return this.add(view);
      }
      view.insertNodesBefore(children[index].firstChild);
      children.splice(index, 0, view);
      if (this.isAttached) {
        view.attached();
        var animatableElement = getAnimatableElement(view);
        if (animatableElement !== null) {
          return this.animator.enter(animatableElement);
        }
      }
    };
    ViewSlot.prototype.remove = function remove(view, returnToCache, skipAnimation) {
      return this.removeAt(this.children.indexOf(view), returnToCache, skipAnimation);
    };
    ViewSlot.prototype.removeAt = function removeAt(index, returnToCache, skipAnimation) {
      var _this = this;
      var view = this.children[index];
      var removeAction = function removeAction() {
        index = _this.children.indexOf(view);
        view.removeNodes();
        _this.children.splice(index, 1);
        if (_this.isAttached) {
          view.detached();
        }
        if (returnToCache) {
          view.returnToCache();
        }
        return view;
      };
      if (!skipAnimation) {
        var animatableElement = getAnimatableElement(view);
        if (animatableElement !== null) {
          return this.animator.leave(animatableElement).then(function() {
            return removeAction();
          });
        }
      }
      return removeAction();
    };
    ViewSlot.prototype.removeAll = function removeAll(returnToCache, skipAnimation) {
      var _this2 = this;
      var children = this.children;
      var ii = children.length;
      var i = undefined;
      var rmPromises = [];
      children.forEach(function(child) {
        if (skipAnimation) {
          child.removeNodes();
          return;
        }
        var animatableElement = getAnimatableElement(child);
        if (animatableElement !== null) {
          rmPromises.push(_this2.animator.leave(animatableElement).then(function() {
            return child.removeNodes();
          }));
        } else {
          child.removeNodes();
        }
      });
      var removeAction = function removeAction() {
        if (_this2.isAttached) {
          for (i = 0; i < ii; ++i) {
            children[i].detached();
          }
        }
        if (returnToCache) {
          for (i = 0; i < ii; ++i) {
            children[i].returnToCache();
          }
        }
        _this2.children = [];
      };
      if (rmPromises.length > 0) {
        return Promise.all(rmPromises).then(function() {
          return removeAction();
        });
      }
      removeAction();
    };
    ViewSlot.prototype.attached = function attached() {
      var i = undefined;
      var ii = undefined;
      var children = undefined;
      var child = undefined;
      if (this.isAttached) {
        return;
      }
      this.isAttached = true;
      children = this.children;
      for (i = 0, ii = children.length; i < ii; ++i) {
        child = children[i];
        child.attached();
        var _element2 = child.firstChild ? _aureliaPal.DOM.nextElementSibling(child.firstChild) : null;
        if (child.firstChild && child.firstChild.nodeType === 8 && _element2 && _element2.nodeType === 1 && _element2.classList.contains('au-animate')) {
          this.animator.enter(_element2);
        }
      }
    };
    ViewSlot.prototype.detached = function detached() {
      var i = undefined;
      var ii = undefined;
      var children = undefined;
      if (this.isAttached) {
        this.isAttached = false;
        children = this.children;
        for (i = 0, ii = children.length; i < ii; ++i) {
          children[i].detached();
        }
      }
    };
    ViewSlot.prototype._installContentSelectors = function _installContentSelectors(contentSelectors) {
      this.contentSelectors = contentSelectors;
      this.add = this._contentSelectorAdd;
      this.insert = this._contentSelectorInsert;
      this.remove = this._contentSelectorRemove;
      this.removeAt = this._contentSelectorRemoveAt;
      this.removeAll = this._contentSelectorRemoveAll;
    };
    ViewSlot.prototype._contentSelectorAdd = function _contentSelectorAdd(view) {
      _ContentSelector.applySelectors(view, this.contentSelectors, function(contentSelector, group) {
        return contentSelector.add(group);
      });
      this.children.push(view);
      if (this.isAttached) {
        view.attached();
      }
    };
    ViewSlot.prototype._contentSelectorInsert = function _contentSelectorInsert(index, view) {
      if (index === 0 && !this.children.length || index >= this.children.length) {
        this.add(view);
      } else {
        _ContentSelector.applySelectors(view, this.contentSelectors, function(contentSelector, group) {
          return contentSelector.insert(index, group);
        });
        this.children.splice(index, 0, view);
        if (this.isAttached) {
          view.attached();
        }
      }
    };
    ViewSlot.prototype._contentSelectorRemove = function _contentSelectorRemove(view) {
      var index = this.children.indexOf(view);
      var contentSelectors = this.contentSelectors;
      var i = undefined;
      var ii = undefined;
      for (i = 0, ii = contentSelectors.length; i < ii; ++i) {
        contentSelectors[i].removeAt(index, view.fragment);
      }
      this.children.splice(index, 1);
      if (this.isAttached) {
        view.detached();
      }
    };
    ViewSlot.prototype._contentSelectorRemoveAt = function _contentSelectorRemoveAt(index) {
      var view = this.children[index];
      var contentSelectors = this.contentSelectors;
      var i = undefined;
      var ii = undefined;
      for (i = 0, ii = contentSelectors.length; i < ii; ++i) {
        contentSelectors[i].removeAt(index, view.fragment);
      }
      this.children.splice(index, 1);
      if (this.isAttached) {
        view.detached();
      }
      return view;
    };
    ViewSlot.prototype._contentSelectorRemoveAll = function _contentSelectorRemoveAll() {
      var children = this.children;
      var contentSelectors = this.contentSelectors;
      var ii = children.length;
      var jj = contentSelectors.length;
      var i = undefined;
      var j = undefined;
      var view = undefined;
      for (i = 0; i < ii; ++i) {
        view = children[i];
        for (j = 0; j < jj; ++j) {
          contentSelectors[j].removeAt(0, view.fragment);
        }
      }
      if (this.isAttached) {
        for (i = 0; i < ii; ++i) {
          children[i].detached();
        }
      }
      this.children = [];
    };
    return ViewSlot;
  })();
  exports.ViewSlot = ViewSlot;
  var ProviderResolver = (function() {
    function ProviderResolver() {
      _classCallCheck(this, _ProviderResolver);
    }
    ProviderResolver.prototype.get = function get(container, key) {
      var id = key.__providerId__;
      return id in container ? container[id] : container[id] = container.invoke(key);
    };
    var _ProviderResolver = ProviderResolver;
    ProviderResolver = _aureliaDependencyInjection.resolver(ProviderResolver) || ProviderResolver;
    return ProviderResolver;
  })();
  var providerResolverInstance = new ProviderResolver();
  function elementContainerGet(key) {
    if (key === _aureliaPal.DOM.Element) {
      return this.element;
    }
    if (key === BoundViewFactory) {
      if (this.boundViewFactory) {
        return this.boundViewFactory;
      }
      var factory = this.instruction.viewFactory;
      var _partReplacements = this.partReplacements;
      if (_partReplacements) {
        factory = _partReplacements[factory.part] || factory;
      }
      this.boundViewFactory = new BoundViewFactory(this, factory, _partReplacements);
      return this.boundViewFactory;
    }
    if (key === ViewSlot) {
      if (this.viewSlot === undefined) {
        this.viewSlot = new ViewSlot(this.element, this.instruction.anchorIsContainer);
        this.element.isContentProjectionSource = this.instruction.lifting;
        this.children.push(this.viewSlot);
      }
      return this.viewSlot;
    }
    if (key === ViewResources) {
      return this.viewResources;
    }
    if (key === TargetInstruction) {
      return this.instruction;
    }
    return this.superGet(key);
  }
  function createElementContainer(parent, element, instruction, children, partReplacements, resources) {
    var container = parent.createChild();
    var providers = undefined;
    var i = undefined;
    container.element = element;
    container.instruction = instruction;
    container.children = children;
    container.viewResources = resources;
    container.partReplacements = partReplacements;
    providers = instruction.providers;
    i = providers.length;
    while (i--) {
      container._resolvers.set(providers[i], providerResolverInstance);
    }
    container.superGet = container.get;
    container.get = elementContainerGet;
    return container;
  }
  function makeElementIntoAnchor(element, elementInstruction) {
    var anchor = _aureliaPal.DOM.createComment('anchor');
    if (elementInstruction) {
      anchor.hasAttribute = function(name) {
        return element.hasAttribute(name);
      };
      anchor.getAttribute = function(name) {
        return element.getAttribute(name);
      };
      anchor.setAttribute = function(name, value) {
        element.setAttribute(name, value);
      };
    }
    _aureliaPal.DOM.replaceNode(anchor, element);
    return anchor;
  }
  function applyInstructions(containers, element, instruction, controllers, bindings, children, contentSelectors, partReplacements, resources) {
    var behaviorInstructions = instruction.behaviorInstructions;
    var expressions = instruction.expressions;
    var elementContainer = undefined;
    var i = undefined;
    var ii = undefined;
    var current = undefined;
    var instance = undefined;
    if (instruction.contentExpression) {
      bindings.push(instruction.contentExpression.createBinding(element.nextSibling));
      element.parentNode.removeChild(element);
      return;
    }
    if (instruction.contentSelector) {
      var commentAnchor = _aureliaPal.DOM.createComment('anchor');
      _aureliaPal.DOM.replaceNode(commentAnchor, element);
      contentSelectors.push(new _ContentSelector(commentAnchor, instruction.selector));
      return;
    }
    if (behaviorInstructions.length) {
      if (!instruction.anchorIsContainer) {
        element = makeElementIntoAnchor(element, instruction.elementInstruction);
      }
      containers[instruction.injectorId] = elementContainer = createElementContainer(containers[instruction.parentInjectorId], element, instruction, children, partReplacements, resources);
      for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
        current = behaviorInstructions[i];
        instance = current.type.create(elementContainer, current, element, bindings);
        if (instance.contentView) {
          children.push(instance.contentView);
        }
        controllers.push(instance);
      }
    }
    for (i = 0, ii = expressions.length; i < ii; ++i) {
      bindings.push(expressions[i].createBinding(element));
    }
  }
  function styleStringToObject(style, target) {
    var attributes = style.split(';');
    var firstIndexOfColon = undefined;
    var i = undefined;
    var current = undefined;
    var key = undefined;
    var value = undefined;
    target = target || {};
    for (i = 0; i < attributes.length; i++) {
      current = attributes[i];
      firstIndexOfColon = current.indexOf(':');
      key = current.substring(0, firstIndexOfColon).trim();
      value = current.substring(firstIndexOfColon + 1).trim();
      target[key] = value;
    }
    return target;
  }
  function styleObjectToString(obj) {
    var result = '';
    for (var key in obj) {
      result += key + ':' + obj[key] + ';';
    }
    return result;
  }
  function applySurrogateInstruction(container, element, instruction, controllers, bindings, children) {
    var behaviorInstructions = instruction.behaviorInstructions;
    var expressions = instruction.expressions;
    var providers = instruction.providers;
    var values = instruction.values;
    var i = undefined;
    var ii = undefined;
    var current = undefined;
    var instance = undefined;
    var currentAttributeValue = undefined;
    i = providers.length;
    while (i--) {
      container._resolvers.set(providers[i], providerResolverInstance);
    }
    for (var key in values) {
      currentAttributeValue = element.getAttribute(key);
      if (currentAttributeValue) {
        if (key === 'class') {
          element.setAttribute('class', currentAttributeValue + ' ' + values[key]);
        } else if (key === 'style') {
          var styleObject = styleStringToObject(values[key]);
          styleStringToObject(currentAttributeValue, styleObject);
          element.setAttribute('style', styleObjectToString(styleObject));
        }
      } else {
        element.setAttribute(key, values[key]);
      }
    }
    if (behaviorInstructions.length) {
      for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
        current = behaviorInstructions[i];
        instance = current.type.create(container, current, element, bindings);
        if (instance.contentView) {
          children.push(instance.contentView);
        }
        controllers.push(instance);
      }
    }
    for (i = 0, ii = expressions.length; i < ii; ++i) {
      bindings.push(expressions[i].createBinding(element));
    }
  }
  var BoundViewFactory = (function() {
    function BoundViewFactory(parentContainer, viewFactory, partReplacements) {
      _classCallCheck(this, BoundViewFactory);
      this.parentContainer = parentContainer;
      this.viewFactory = viewFactory;
      this.factoryCreateInstruction = {partReplacements: partReplacements};
    }
    BoundViewFactory.prototype.create = function create() {
      var view = this.viewFactory.create(this.parentContainer.createChild(), this.factoryCreateInstruction);
      view._isUserControlled = true;
      return view;
    };
    BoundViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
      this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
    };
    BoundViewFactory.prototype.getCachedView = function getCachedView() {
      return this.viewFactory.getCachedView();
    };
    BoundViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
      this.viewFactory.returnViewToCache(view);
    };
    _createClass(BoundViewFactory, [{
      key: 'isCaching',
      get: function get() {
        return this.viewFactory.isCaching;
      }
    }]);
    return BoundViewFactory;
  })();
  exports.BoundViewFactory = BoundViewFactory;
  var ViewFactory = (function() {
    function ViewFactory(template, instructions, resources) {
      _classCallCheck(this, ViewFactory);
      this.isCaching = false;
      this.template = template;
      this.instructions = instructions;
      this.resources = resources;
      this.cacheSize = -1;
      this.cache = null;
    }
    ViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
      if (size) {
        if (size === '*') {
          size = Number.MAX_VALUE;
        } else if (typeof size === 'string') {
          size = parseInt(size, 10);
        }
      }
      if (this.cacheSize === -1 || !doNotOverrideIfAlreadySet) {
        this.cacheSize = size;
      }
      if (this.cacheSize > 0) {
        this.cache = [];
      } else {
        this.cache = null;
      }
      this.isCaching = this.cacheSize > 0;
    };
    ViewFactory.prototype.getCachedView = function getCachedView() {
      return this.cache !== null ? this.cache.pop() || null : null;
    };
    ViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
      if (view.isAttached) {
        view.detached();
      }
      if (view.isBound) {
        view.unbind();
      }
      if (this.cache !== null && this.cache.length < this.cacheSize) {
        view.fromCache = true;
        this.cache.push(view);
      }
    };
    ViewFactory.prototype.create = function create(container, createInstruction, element) {
      createInstruction = createInstruction || BehaviorInstruction.normal;
      element = element || null;
      var cachedView = this.getCachedView();
      if (cachedView !== null) {
        return cachedView;
      }
      var fragment = createInstruction.enhance ? this.template : this.template.cloneNode(true);
      var instructables = fragment.querySelectorAll('.au-target');
      var instructions = this.instructions;
      var resources = this.resources;
      var controllers = [];
      var bindings = [];
      var children = [];
      var contentSelectors = [];
      var containers = {root: container};
      var partReplacements = createInstruction.partReplacements;
      var i = undefined;
      var ii = undefined;
      var view = undefined;
      var instructable = undefined;
      var instruction = undefined;
      this.resources._onBeforeCreate(this, container, fragment, createInstruction);
      if (element !== null && this.surrogateInstruction !== null) {
        applySurrogateInstruction(container, element, this.surrogateInstruction, controllers, bindings, children);
      }
      for (i = 0, ii = instructables.length; i < ii; ++i) {
        instructable = instructables[i];
        instruction = instructions[instructable.getAttribute('au-target-id')];
        applyInstructions(containers, instructable, instruction, controllers, bindings, children, contentSelectors, partReplacements, resources);
      }
      view = new View(this, fragment, controllers, bindings, children, contentSelectors);
      if (!createInstruction.initiatedByBehavior) {
        view.created();
      }
      this.resources._onAfterCreate(view);
      return view;
    };
    return ViewFactory;
  })();
  exports.ViewFactory = ViewFactory;
  var nextInjectorId = 0;
  function getNextInjectorId() {
    return ++nextInjectorId;
  }
  function configureProperties(instruction, resources) {
    var type = instruction.type;
    var attrName = instruction.attrName;
    var attributes = instruction.attributes;
    var property = undefined;
    var key = undefined;
    var value = undefined;
    var knownAttribute = resources.mapAttribute(attrName);
    if (knownAttribute && attrName in attributes && knownAttribute !== attrName) {
      attributes[knownAttribute] = attributes[attrName];
      delete attributes[attrName];
    }
    for (key in attributes) {
      value = attributes[key];
      if (value !== null && typeof value === 'object') {
        property = type.attributes[key];
        if (property !== undefined) {
          value.targetProperty = property.name;
        } else {
          value.targetProperty = key;
        }
      }
    }
  }
  var lastAUTargetID = 0;
  function getNextAUTargetID() {
    return (++lastAUTargetID).toString();
  }
  function makeIntoInstructionTarget(element) {
    var value = element.getAttribute('class');
    var auTargetID = getNextAUTargetID();
    element.setAttribute('class', value ? value += ' au-target' : 'au-target');
    element.setAttribute('au-target-id', auTargetID);
    return auTargetID;
  }
  var ViewCompiler = (function() {
    function ViewCompiler(bindingLanguage, resources) {
      _classCallCheck(this, _ViewCompiler);
      this.bindingLanguage = bindingLanguage;
      this.resources = resources;
    }
    ViewCompiler.prototype.compile = function compile(source, resources, compileInstruction) {
      resources = resources || this.resources;
      compileInstruction = compileInstruction || ViewCompileInstruction.normal;
      source = typeof source === 'string' ? _aureliaPal.DOM.createTemplateFromMarkup(source) : source;
      var content = undefined;
      var part = undefined;
      var cacheSize = undefined;
      if (source.content) {
        part = source.getAttribute('part');
        cacheSize = source.getAttribute('view-cache');
        content = _aureliaPal.DOM.adoptNode(source.content);
      } else {
        content = source;
      }
      compileInstruction.targetShadowDOM = compileInstruction.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
      resources._onBeforeCompile(content, resources, compileInstruction);
      var instructions = {};
      this._compileNode(content, resources, instructions, source, 'root', !compileInstruction.targetShadowDOM);
      content.insertBefore(_aureliaPal.DOM.createComment('<view>'), content.firstChild);
      content.appendChild(_aureliaPal.DOM.createComment('</view>'));
      var factory = new ViewFactory(content, instructions, resources);
      factory.surrogateInstruction = compileInstruction.compileSurrogate ? this._compileSurrogate(source, resources) : null;
      factory.part = part;
      if (cacheSize) {
        factory.setCacheSize(cacheSize);
      }
      resources._onAfterCompile(factory);
      return factory;
    };
    ViewCompiler.prototype._compileNode = function _compileNode(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
      switch (node.nodeType) {
        case 1:
          return this._compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM);
        case 3:
          var expression = resources.getBindingLanguage(this.bindingLanguage).parseText(resources, node.wholeText);
          if (expression) {
            var marker = _aureliaPal.DOM.createElement('au-marker');
            var auTargetID = makeIntoInstructionTarget(marker);
            (node.parentNode || parentNode).insertBefore(marker, node);
            node.textContent = ' ';
            instructions[auTargetID] = TargetInstruction.contentExpression(expression);
            while (node.nextSibling && node.nextSibling.nodeType === 3) {
              (node.parentNode || parentNode).removeChild(node.nextSibling);
            }
          } else {
            while (node.nextSibling && node.nextSibling.nodeType === 3) {
              node = node.nextSibling;
            }
          }
          return node.nextSibling;
        case 11:
          var currentChild = node.firstChild;
          while (currentChild) {
            currentChild = this._compileNode(currentChild, resources, instructions, node, parentInjectorId, targetLightDOM);
          }
          break;
        default:
          break;
      }
      return node.nextSibling;
    };
    ViewCompiler.prototype._compileSurrogate = function _compileSurrogate(node, resources) {
      var attributes = node.attributes;
      var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
      var knownAttribute = undefined;
      var property = undefined;
      var instruction = undefined;
      var i = undefined;
      var ii = undefined;
      var attr = undefined;
      var attrName = undefined;
      var attrValue = undefined;
      var info = undefined;
      var type = undefined;
      var expressions = [];
      var expression = undefined;
      var behaviorInstructions = [];
      var values = {};
      var hasValues = false;
      var providers = [];
      for (i = 0, ii = attributes.length; i < ii; ++i) {
        attr = attributes[i];
        attrName = attr.name;
        attrValue = attr.value;
        info = bindingLanguage.inspectAttribute(resources, attrName, attrValue);
        type = resources.getAttribute(info.attrName);
        if (type) {
          knownAttribute = resources.mapAttribute(info.attrName);
          if (knownAttribute) {
            property = type.attributes[knownAttribute];
            if (property) {
              info.defaultBindingMode = property.defaultBindingMode;
              if (!info.command && !info.expression) {
                info.command = property.hasOptions ? 'options' : null;
              }
            }
          }
        }
        instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
        if (instruction) {
          if (instruction.alteredAttr) {
            type = resources.getAttribute(instruction.attrName);
          }
          if (instruction.discrete) {
            expressions.push(instruction);
          } else {
            if (type) {
              instruction.type = type;
              configureProperties(instruction, resources);
              if (type.liftsContent) {
                throw new Error('You cannot place a template controller on a surrogate element.');
              } else {
                behaviorInstructions.push(instruction);
              }
            } else {
              expressions.push(instruction.attributes[instruction.attrName]);
            }
          }
        } else {
          if (type) {
            instruction = BehaviorInstruction.attribute(attrName, type);
            instruction.attributes[resources.mapAttribute(attrName)] = attrValue;
            if (type.liftsContent) {
              throw new Error('You cannot place a template controller on a surrogate element.');
            } else {
              behaviorInstructions.push(instruction);
            }
          } else if (attrName !== 'id' && attrName !== 'part' && attrName !== 'replace-part') {
            hasValues = true;
            values[attrName] = attrValue;
          }
        }
      }
      if (expressions.length || behaviorInstructions.length || hasValues) {
        for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
          instruction = behaviorInstructions[i];
          instruction.type.compile(this, resources, node, instruction);
          providers.push(instruction.type.target);
        }
        for (i = 0, ii = expressions.length; i < ii; ++i) {
          expression = expressions[i];
          if (expression.attrToRemove !== undefined) {
            node.removeAttribute(expression.attrToRemove);
          }
        }
        return TargetInstruction.surrogate(providers, behaviorInstructions, expressions, values);
      }
      return null;
    };
    ViewCompiler.prototype._compileElement = function _compileElement(node, resources, instructions, parentNode, parentInjectorId, targetLightDOM) {
      var tagName = node.tagName.toLowerCase();
      var attributes = node.attributes;
      var expressions = [];
      var expression = undefined;
      var behaviorInstructions = [];
      var providers = [];
      var bindingLanguage = resources.getBindingLanguage(this.bindingLanguage);
      var liftingInstruction = undefined;
      var viewFactory = undefined;
      var type = undefined;
      var elementInstruction = undefined;
      var elementProperty = undefined;
      var i = undefined;
      var ii = undefined;
      var attr = undefined;
      var attrName = undefined;
      var attrValue = undefined;
      var instruction = undefined;
      var info = undefined;
      var property = undefined;
      var knownAttribute = undefined;
      var auTargetID = undefined;
      var injectorId = undefined;
      if (tagName === 'content') {
        if (targetLightDOM) {
          auTargetID = makeIntoInstructionTarget(node);
          instructions[auTargetID] = TargetInstruction.contentSelector(node, parentInjectorId);
        }
        return node.nextSibling;
      } else if (tagName === 'template') {
        viewFactory = this.compile(node, resources);
        viewFactory.part = node.getAttribute('part');
      } else {
        type = resources.getElement(tagName);
        if (type) {
          elementInstruction = BehaviorInstruction.element(node, type);
          behaviorInstructions.push(elementInstruction);
        }
      }
      for (i = 0, ii = attributes.length; i < ii; ++i) {
        attr = attributes[i];
        attrName = attr.name;
        attrValue = attr.value;
        info = bindingLanguage.inspectAttribute(resources, attrName, attrValue);
        type = resources.getAttribute(info.attrName);
        elementProperty = null;
        if (type) {
          knownAttribute = resources.mapAttribute(info.attrName);
          if (knownAttribute) {
            property = type.attributes[knownAttribute];
            if (property) {
              info.defaultBindingMode = property.defaultBindingMode;
              if (!info.command && !info.expression) {
                info.command = property.hasOptions ? 'options' : null;
              }
            }
          }
        } else if (elementInstruction) {
          elementProperty = elementInstruction.type.attributes[info.attrName];
          if (elementProperty) {
            info.defaultBindingMode = elementProperty.defaultBindingMode;
          }
        }
        if (elementProperty) {
          instruction = bindingLanguage.createAttributeInstruction(resources, node, info, elementInstruction);
        } else {
          instruction = bindingLanguage.createAttributeInstruction(resources, node, info, undefined, type);
        }
        if (instruction) {
          if (instruction.alteredAttr) {
            type = resources.getAttribute(instruction.attrName);
          }
          if (instruction.discrete) {
            expressions.push(instruction);
          } else {
            if (type) {
              instruction.type = type;
              configureProperties(instruction, resources);
              if (type.liftsContent) {
                instruction.originalAttrName = attrName;
                liftingInstruction = instruction;
                break;
              } else {
                behaviorInstructions.push(instruction);
              }
            } else if (elementProperty) {
              elementInstruction.attributes[info.attrName].targetProperty = elementProperty.name;
            } else {
              expressions.push(instruction.attributes[instruction.attrName]);
            }
          }
        } else {
          if (type) {
            instruction = BehaviorInstruction.attribute(attrName, type);
            instruction.attributes[resources.mapAttribute(attrName)] = attrValue;
            if (type.liftsContent) {
              instruction.originalAttrName = attrName;
              liftingInstruction = instruction;
              break;
            } else {
              behaviorInstructions.push(instruction);
            }
          } else if (elementProperty) {
            elementInstruction.attributes[attrName] = attrValue;
          }
        }
      }
      if (liftingInstruction) {
        liftingInstruction.viewFactory = viewFactory;
        node = liftingInstruction.type.compile(this, resources, node, liftingInstruction, parentNode);
        auTargetID = makeIntoInstructionTarget(node);
        instructions[auTargetID] = TargetInstruction.lifting(parentInjectorId, liftingInstruction);
      } else {
        if (expressions.length || behaviorInstructions.length) {
          injectorId = behaviorInstructions.length ? getNextInjectorId() : false;
          for (i = 0, ii = behaviorInstructions.length; i < ii; ++i) {
            instruction = behaviorInstructions[i];
            instruction.type.compile(this, resources, node, instruction, parentNode);
            providers.push(instruction.type.target);
          }
          for (i = 0, ii = expressions.length; i < ii; ++i) {
            expression = expressions[i];
            if (expression.attrToRemove !== undefined) {
              node.removeAttribute(expression.attrToRemove);
            }
          }
          auTargetID = makeIntoInstructionTarget(node);
          instructions[auTargetID] = TargetInstruction.normal(injectorId, parentInjectorId, providers, behaviorInstructions, expressions, elementInstruction);
        }
        if (elementInstruction && elementInstruction.skipContentProcessing) {
          return node.nextSibling;
        }
        var currentChild = node.firstChild;
        while (currentChild) {
          currentChild = this._compileNode(currentChild, resources, instructions, node, injectorId || parentInjectorId, targetLightDOM);
        }
      }
      return node.nextSibling;
    };
    var _ViewCompiler = ViewCompiler;
    ViewCompiler = _aureliaDependencyInjection.inject(BindingLanguage, ViewResources)(ViewCompiler) || ViewCompiler;
    return ViewCompiler;
  })();
  exports.ViewCompiler = ViewCompiler;
  var ResourceModule = (function() {
    function ResourceModule(moduleId) {
      _classCallCheck(this, ResourceModule);
      this.id = moduleId;
      this.moduleInstance = null;
      this.mainResource = null;
      this.resources = null;
      this.viewStrategy = null;
      this.isInitialized = false;
      this.onLoaded = null;
    }
    ResourceModule.prototype.initialize = function initialize(container) {
      var current = this.mainResource;
      var resources = this.resources;
      var vs = this.viewStrategy;
      if (this.isInitialized) {
        return;
      }
      this.isInitialized = true;
      if (current !== undefined) {
        current.metadata.viewStrategy = vs;
        current.initialize(container);
      }
      for (var i = 0,
          ii = resources.length; i < ii; ++i) {
        current = resources[i];
        current.metadata.viewStrategy = vs;
        current.initialize(container);
      }
    };
    ResourceModule.prototype.register = function register(registry, name) {
      var main = this.mainResource;
      var resources = this.resources;
      if (main !== undefined) {
        main.register(registry, name);
        name = null;
      }
      for (var i = 0,
          ii = resources.length; i < ii; ++i) {
        resources[i].register(registry, name);
        name = null;
      }
    };
    ResourceModule.prototype.load = function load(container, loadContext) {
      if (this.onLoaded !== null) {
        return this.onLoaded;
      }
      var main = this.mainResource;
      var resources = this.resources;
      var loads = undefined;
      if (main !== undefined) {
        loads = new Array(resources.length + 1);
        loads[0] = main.load(container, loadContext);
        for (var i = 0,
            ii = resources.length; i < ii; ++i) {
          loads[i + 1] = resources[i].load(container, loadContext);
        }
      } else {
        loads = new Array(resources.length);
        for (var i = 0,
            ii = resources.length; i < ii; ++i) {
          loads[i] = resources[i].load(container, loadContext);
        }
      }
      this.onLoaded = Promise.all(loads);
      return this.onLoaded;
    };
    return ResourceModule;
  })();
  exports.ResourceModule = ResourceModule;
  var ResourceDescription = (function() {
    function ResourceDescription(key, exportedValue, resourceTypeMeta) {
      _classCallCheck(this, ResourceDescription);
      if (!resourceTypeMeta) {
        resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);
        if (!resourceTypeMeta) {
          resourceTypeMeta = new HtmlBehaviorResource();
          resourceTypeMeta.elementName = _hyphenate(key);
          _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, resourceTypeMeta, exportedValue);
        }
      }
      if (resourceTypeMeta instanceof HtmlBehaviorResource) {
        if (resourceTypeMeta.elementName === undefined) {
          resourceTypeMeta.elementName = _hyphenate(key);
        } else if (resourceTypeMeta.attributeName === undefined) {
          resourceTypeMeta.attributeName = _hyphenate(key);
        } else if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
          HtmlBehaviorResource.convention(key, resourceTypeMeta);
        }
      } else if (!resourceTypeMeta.name) {
        resourceTypeMeta.name = _hyphenate(key);
      }
      this.metadata = resourceTypeMeta;
      this.value = exportedValue;
    }
    ResourceDescription.prototype.initialize = function initialize(container) {
      this.metadata.initialize(container, this.value);
    };
    ResourceDescription.prototype.register = function register(registry, name) {
      this.metadata.register(registry, name);
    };
    ResourceDescription.prototype.load = function load(container, loadContext) {
      return this.metadata.load(container, this.value, loadContext);
    };
    return ResourceDescription;
  })();
  exports.ResourceDescription = ResourceDescription;
  var ModuleAnalyzer = (function() {
    function ModuleAnalyzer() {
      _classCallCheck(this, ModuleAnalyzer);
      this.cache = {};
    }
    ModuleAnalyzer.prototype.getAnalysis = function getAnalysis(moduleId) {
      return this.cache[moduleId];
    };
    ModuleAnalyzer.prototype.analyze = function analyze(moduleId, moduleInstance, mainResourceKey) {
      var mainResource = undefined;
      var fallbackValue = undefined;
      var fallbackKey = undefined;
      var resourceTypeMeta = undefined;
      var key = undefined;
      var exportedValue = undefined;
      var resources = [];
      var conventional = undefined;
      var vs = undefined;
      var resourceModule = undefined;
      resourceModule = this.cache[moduleId];
      if (resourceModule) {
        return resourceModule;
      }
      resourceModule = new ResourceModule(moduleId);
      this.cache[moduleId] = resourceModule;
      if (typeof moduleInstance === 'function') {
        moduleInstance = {'default': moduleInstance};
      }
      if (mainResourceKey) {
        mainResource = new ResourceDescription(mainResourceKey, moduleInstance[mainResourceKey]);
      }
      for (key in moduleInstance) {
        exportedValue = moduleInstance[key];
        if (key === mainResourceKey || typeof exportedValue !== 'function') {
          continue;
        }
        resourceTypeMeta = _aureliaMetadata.metadata.get(_aureliaMetadata.metadata.resource, exportedValue);
        if (resourceTypeMeta) {
          if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
            HtmlBehaviorResource.convention(key, resourceTypeMeta);
          }
          if (resourceTypeMeta.attributeName === null && resourceTypeMeta.elementName === null) {
            resourceTypeMeta.elementName = _hyphenate(key);
          }
          if (!mainResource && resourceTypeMeta instanceof HtmlBehaviorResource && resourceTypeMeta.elementName !== null) {
            mainResource = new ResourceDescription(key, exportedValue, resourceTypeMeta);
          } else {
            resources.push(new ResourceDescription(key, exportedValue, resourceTypeMeta));
          }
        } else if (viewStrategy.decorates(exportedValue)) {
          vs = exportedValue;
        } else if (exportedValue instanceof _aureliaLoader.TemplateRegistryEntry) {
          vs = new TemplateRegistryViewStrategy(moduleId, exportedValue);
        } else {
          if (conventional = HtmlBehaviorResource.convention(key)) {
            if (conventional.elementName !== null && !mainResource) {
              mainResource = new ResourceDescription(key, exportedValue, conventional);
            } else {
              resources.push(new ResourceDescription(key, exportedValue, conventional));
            }
            _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
          } else if (conventional = _aureliaBinding.ValueConverterResource.convention(key)) {
            resources.push(new ResourceDescription(key, exportedValue, conventional));
            _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
          } else if (conventional = _aureliaBinding.BindingBehaviorResource.convention(key)) {
            resources.push(new ResourceDescription(key, exportedValue, conventional));
            _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, conventional, exportedValue);
          } else if (!fallbackValue) {
            fallbackValue = exportedValue;
            fallbackKey = key;
          }
        }
      }
      if (!mainResource && fallbackValue) {
        mainResource = new ResourceDescription(fallbackKey, fallbackValue);
      }
      resourceModule.moduleInstance = moduleInstance;
      resourceModule.mainResource = mainResource;
      resourceModule.resources = resources;
      resourceModule.viewStrategy = vs;
      return resourceModule;
    };
    return ModuleAnalyzer;
  })();
  exports.ModuleAnalyzer = ModuleAnalyzer;
  var logger = _aureliaLogging.getLogger('templating');
  function ensureRegistryEntry(loader, urlOrRegistryEntry) {
    if (urlOrRegistryEntry instanceof _aureliaLoader.TemplateRegistryEntry) {
      return Promise.resolve(urlOrRegistryEntry);
    }
    return loader.loadTemplate(urlOrRegistryEntry);
  }
  var ProxyViewFactory = (function() {
    function ProxyViewFactory(promise) {
      var _this3 = this;
      _classCallCheck(this, ProxyViewFactory);
      promise.then(function(x) {
        return _this3.viewFactory = x;
      });
    }
    ProxyViewFactory.prototype.create = function create(container, bindingContext, createInstruction, element) {
      return this.viewFactory.create(container, bindingContext, createInstruction, element);
    };
    ProxyViewFactory.prototype.setCacheSize = function setCacheSize(size, doNotOverrideIfAlreadySet) {
      this.viewFactory.setCacheSize(size, doNotOverrideIfAlreadySet);
    };
    ProxyViewFactory.prototype.getCachedView = function getCachedView() {
      return this.viewFactory.getCachedView();
    };
    ProxyViewFactory.prototype.returnViewToCache = function returnViewToCache(view) {
      this.viewFactory.returnViewToCache(view);
    };
    _createClass(ProxyViewFactory, [{
      key: 'isCaching',
      get: function get() {
        return this.viewFactory.isCaching;
      }
    }]);
    return ProxyViewFactory;
  })();
  var ViewEngine = (function() {
    function ViewEngine(loader, container, viewCompiler, moduleAnalyzer, appResources) {
      _classCallCheck(this, _ViewEngine);
      this.loader = loader;
      this.container = container;
      this.viewCompiler = viewCompiler;
      this.moduleAnalyzer = moduleAnalyzer;
      this.appResources = appResources;
      this._pluginMap = {};
    }
    ViewEngine.prototype.addResourcePlugin = function addResourcePlugin(extension, implementation) {
      var name = extension.replace('.', '') + '-resource-plugin';
      this._pluginMap[extension] = name;
      this.loader.addPlugin(name, implementation);
    };
    ViewEngine.prototype.loadViewFactory = function loadViewFactory(urlOrRegistryEntry, compileInstruction, loadContext) {
      var _this4 = this;
      loadContext = loadContext || new ResourceLoadContext();
      return ensureRegistryEntry(this.loader, urlOrRegistryEntry).then(function(registryEntry) {
        if (registryEntry.onReady) {
          if (!loadContext.hasDependency(urlOrRegistryEntry)) {
            loadContext.addDependency(urlOrRegistryEntry);
            return registryEntry.onReady;
          }
          return Promise.resolve(new ProxyViewFactory(registryEntry.onReady));
        }
        loadContext.addDependency(urlOrRegistryEntry);
        registryEntry.onReady = _this4.loadTemplateResources(registryEntry, compileInstruction, loadContext).then(function(resources) {
          registryEntry.resources = resources;
          var viewFactory = _this4.viewCompiler.compile(registryEntry.template, resources, compileInstruction);
          registryEntry.factory = viewFactory;
          return viewFactory;
        });
        return registryEntry.onReady;
      });
    };
    ViewEngine.prototype.loadTemplateResources = function loadTemplateResources(registryEntry, compileInstruction, loadContext) {
      var resources = new ViewResources(this.appResources, registryEntry.address);
      var dependencies = registryEntry.dependencies;
      var importIds = undefined;
      var names = undefined;
      compileInstruction = compileInstruction || ViewCompileInstruction.normal;
      if (dependencies.length === 0 && !compileInstruction.associatedModuleId) {
        return Promise.resolve(resources);
      }
      importIds = dependencies.map(function(x) {
        return x.src;
      });
      names = dependencies.map(function(x) {
        return x.name;
      });
      logger.debug('importing resources for ' + registryEntry.address, importIds);
      return this.importViewResources(importIds, names, resources, compileInstruction, loadContext);
    };
    ViewEngine.prototype.importViewModelResource = function importViewModelResource(moduleImport, moduleMember) {
      var _this5 = this;
      return this.loader.loadModule(moduleImport).then(function(viewModelModule) {
        var normalizedId = _aureliaMetadata.Origin.get(viewModelModule).moduleId;
        var resourceModule = _this5.moduleAnalyzer.analyze(normalizedId, viewModelModule, moduleMember);
        if (!resourceModule.mainResource) {
          throw new Error('No view model found in module "' + moduleImport + '".');
        }
        resourceModule.initialize(_this5.container);
        return resourceModule.mainResource;
      });
    };
    ViewEngine.prototype.importViewResources = function importViewResources(moduleIds, names, resources, compileInstruction, loadContext) {
      var _this6 = this;
      loadContext = loadContext || new ResourceLoadContext();
      compileInstruction = compileInstruction || ViewCompileInstruction.normal;
      moduleIds = moduleIds.map(function(x) {
        return _this6._applyLoaderPlugin(x);
      });
      return this.loader.loadAllModules(moduleIds).then(function(imports) {
        var i = undefined;
        var ii = undefined;
        var analysis = undefined;
        var normalizedId = undefined;
        var current = undefined;
        var associatedModule = undefined;
        var container = _this6.container;
        var moduleAnalyzer = _this6.moduleAnalyzer;
        var allAnalysis = new Array(imports.length);
        for (i = 0, ii = imports.length; i < ii; ++i) {
          current = imports[i];
          normalizedId = _aureliaMetadata.Origin.get(current).moduleId;
          analysis = moduleAnalyzer.analyze(normalizedId, current);
          analysis.initialize(container);
          analysis.register(resources, names[i]);
          allAnalysis[i] = analysis;
        }
        if (compileInstruction.associatedModuleId) {
          associatedModule = moduleAnalyzer.getAnalysis(compileInstruction.associatedModuleId);
          if (associatedModule) {
            associatedModule.register(resources);
          }
        }
        for (i = 0, ii = allAnalysis.length; i < ii; ++i) {
          allAnalysis[i] = allAnalysis[i].load(container, loadContext);
        }
        return Promise.all(allAnalysis).then(function() {
          return resources;
        });
      });
    };
    ViewEngine.prototype._applyLoaderPlugin = function _applyLoaderPlugin(id) {
      var index = id.lastIndexOf('.');
      if (index !== -1) {
        var ext = id.substring(index);
        var pluginName = this._pluginMap[ext];
        if (pluginName === undefined) {
          return id;
        }
        return this.loader.applyPluginToUrl(id, pluginName);
      }
      return id;
    };
    var _ViewEngine = ViewEngine;
    ViewEngine = _aureliaDependencyInjection.inject(_aureliaLoader.Loader, _aureliaDependencyInjection.Container, ViewCompiler, ModuleAnalyzer, ViewResources)(ViewEngine) || ViewEngine;
    return ViewEngine;
  })();
  exports.ViewEngine = ViewEngine;
  var Controller = (function() {
    function Controller(behavior, instruction, viewModel) {
      _classCallCheck(this, Controller);
      this.behavior = behavior;
      this.instruction = instruction;
      this.viewModel = viewModel;
      this.isAttached = false;
      this.view = null;
      this.isBound = false;
      this.bindingContext = null;
      var observerLookup = behavior.observerLocator.getOrCreateObserversLookup(viewModel);
      var handlesBind = behavior.handlesBind;
      var attributes = instruction.attributes;
      var boundProperties = this.boundProperties = [];
      var properties = behavior.properties;
      var i = undefined;
      var ii = undefined;
      behavior._ensurePropertiesDefined(viewModel, observerLookup);
      for (i = 0, ii = properties.length; i < ii; ++i) {
        properties[i]._initialize(viewModel, observerLookup, attributes, handlesBind, boundProperties);
      }
    }
    Controller.prototype.created = function created(owningView) {
      if (this.behavior.handlesCreated) {
        this.viewModel.created(owningView, this.view);
      }
    };
    Controller.prototype.automate = function automate(overrideContext, owningView) {
      this.view.bindingContext = this.viewModel;
      this.view.overrideContext = overrideContext || _aureliaBinding.createOverrideContext(this.viewModel);
      this.view._isUserControlled = true;
      if (this.behavior.handlesCreated) {
        this.viewModel.created(owningView || null, this.view);
      }
      this.bind(this.view);
    };
    Controller.prototype.bind = function bind(scope) {
      var skipSelfSubscriber = this.behavior.handlesBind;
      var boundProperties = this.boundProperties;
      var i = undefined;
      var ii = undefined;
      var x = undefined;
      var observer = undefined;
      var selfSubscriber = undefined;
      var context = scope.bindingContext;
      if (this.isBound) {
        if (this.bindingContext === context) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.bindingContext = context;
      for (i = 0, ii = boundProperties.length; i < ii; ++i) {
        x = boundProperties[i];
        observer = x.observer;
        selfSubscriber = observer.selfSubscriber;
        observer.publishing = false;
        if (skipSelfSubscriber) {
          observer.selfSubscriber = null;
        }
        x.binding.bind(scope);
        observer.call();
        observer.publishing = true;
        observer.selfSubscriber = selfSubscriber;
      }
      if (this.view !== null) {
        if (skipSelfSubscriber) {
          this.view.viewModelScope = scope;
        }
        this.view.bind(this.viewModel, _aureliaBinding.createOverrideContext(this.viewModel, scope.overrideContext));
      } else if (skipSelfSubscriber) {
        this.viewModel.bind(context, scope.overrideContext);
      }
    };
    Controller.prototype.unbind = function unbind() {
      if (this.isBound) {
        var boundProperties = this.boundProperties;
        var i = undefined;
        var ii = undefined;
        this.isBound = false;
        this.scope = null;
        if (this.view !== null) {
          this.view.unbind();
        }
        if (this.behavior.handlesUnbind) {
          this.viewModel.unbind();
        }
        for (i = 0, ii = boundProperties.length; i < ii; ++i) {
          boundProperties[i].binding.unbind();
        }
      }
    };
    Controller.prototype.attached = function attached() {
      if (this.isAttached) {
        return;
      }
      this.isAttached = true;
      if (this.behavior.handlesAttached) {
        this.viewModel.attached();
      }
      if (this.view !== null) {
        this.view.attached();
      }
    };
    Controller.prototype.detached = function detached() {
      if (this.isAttached) {
        this.isAttached = false;
        if (this.view !== null) {
          this.view.detached();
        }
        if (this.behavior.handlesDetached) {
          this.viewModel.detached();
        }
      }
    };
    return Controller;
  })();
  exports.Controller = Controller;
  var BehaviorPropertyObserver = (function() {
    function BehaviorPropertyObserver(taskQueue, obj, propertyName, selfSubscriber, initialValue) {
      _classCallCheck(this, _BehaviorPropertyObserver);
      this.taskQueue = taskQueue;
      this.obj = obj;
      this.propertyName = propertyName;
      this.notqueued = true;
      this.publishing = false;
      this.selfSubscriber = selfSubscriber;
      this.currentValue = this.oldValue = initialValue;
    }
    BehaviorPropertyObserver.prototype.getValue = function getValue() {
      return this.currentValue;
    };
    BehaviorPropertyObserver.prototype.setValue = function setValue(newValue) {
      var oldValue = this.currentValue;
      if (oldValue !== newValue) {
        if (this.publishing && this.notqueued) {
          this.notqueued = false;
          this.taskQueue.queueMicroTask(this);
        }
        this.oldValue = oldValue;
        this.currentValue = newValue;
      }
    };
    BehaviorPropertyObserver.prototype.call = function call() {
      var oldValue = this.oldValue;
      var newValue = this.currentValue;
      this.notqueued = true;
      if (newValue === oldValue) {
        return;
      }
      if (this.selfSubscriber) {
        this.selfSubscriber(newValue, oldValue);
      }
      this.callSubscribers(newValue, oldValue);
      this.oldValue = newValue;
    };
    BehaviorPropertyObserver.prototype.subscribe = function subscribe(context, callable) {
      this.addSubscriber(context, callable);
    };
    BehaviorPropertyObserver.prototype.unsubscribe = function unsubscribe(context, callable) {
      this.removeSubscriber(context, callable);
    };
    var _BehaviorPropertyObserver = BehaviorPropertyObserver;
    BehaviorPropertyObserver = _aureliaBinding.subscriberCollection()(BehaviorPropertyObserver) || BehaviorPropertyObserver;
    return BehaviorPropertyObserver;
  })();
  exports.BehaviorPropertyObserver = BehaviorPropertyObserver;
  function getObserver(behavior, instance, name) {
    var lookup = instance.__observers__;
    if (lookup === undefined) {
      if (!behavior.isInitialized) {
        behavior.initialize(_aureliaDependencyInjection.Container.instance || new _aureliaDependencyInjection.Container(), instance.constructor);
      }
      lookup = behavior.observerLocator.getOrCreateObserversLookup(instance);
      behavior._ensurePropertiesDefined(instance, lookup);
    }
    return lookup[name];
  }
  var BindableProperty = (function() {
    function BindableProperty(nameOrConfig) {
      _classCallCheck(this, BindableProperty);
      if (typeof nameOrConfig === 'string') {
        this.name = nameOrConfig;
      } else {
        Object.assign(this, nameOrConfig);
      }
      this.attribute = this.attribute || _hyphenate(this.name);
      this.defaultBindingMode = this.defaultBindingMode || _aureliaBinding.bindingMode.oneWay;
      this.changeHandler = this.changeHandler || null;
      this.owner = null;
      this.descriptor = null;
    }
    BindableProperty.prototype.registerWith = function registerWith(target, behavior, descriptor) {
      behavior.properties.push(this);
      behavior.attributes[this.attribute] = this;
      this.owner = behavior;
      if (descriptor) {
        this.descriptor = descriptor;
        return this._configureDescriptor(behavior, descriptor);
      }
    };
    BindableProperty.prototype._configureDescriptor = function _configureDescriptor(behavior, descriptor) {
      var name = this.name;
      descriptor.configurable = true;
      descriptor.enumerable = true;
      if ('initializer' in descriptor) {
        this.defaultValue = descriptor.initializer;
        delete descriptor.initializer;
        delete descriptor.writable;
      }
      if ('value' in descriptor) {
        this.defaultValue = descriptor.value;
        delete descriptor.value;
        delete descriptor.writable;
      }
      descriptor.get = function() {
        return getObserver(behavior, this, name).getValue();
      };
      descriptor.set = function(value) {
        getObserver(behavior, this, name).setValue(value);
      };
      descriptor.get.getObserver = function(obj) {
        return getObserver(behavior, obj, name);
      };
      return descriptor;
    };
    BindableProperty.prototype.defineOn = function defineOn(target, behavior) {
      var name = this.name;
      var handlerName = undefined;
      if (this.changeHandler === null) {
        handlerName = name + 'Changed';
        if (handlerName in target.prototype) {
          this.changeHandler = handlerName;
        }
      }
      if (this.descriptor === null) {
        Object.defineProperty(target.prototype, name, this._configureDescriptor(behavior, {}));
      }
    };
    BindableProperty.prototype.createObserver = function createObserver(viewModel) {
      var selfSubscriber = null;
      var defaultValue = this.defaultValue;
      var changeHandlerName = this.changeHandler;
      var name = this.name;
      var initialValue = undefined;
      if (this.hasOptions) {
        return undefined;
      }
      if (changeHandlerName in viewModel) {
        if ('propertyChanged' in viewModel) {
          selfSubscriber = function(newValue, oldValue) {
            viewModel[changeHandlerName](newValue, oldValue);
            viewModel.propertyChanged(name, newValue, oldValue);
          };
        } else {
          selfSubscriber = function(newValue, oldValue) {
            return viewModel[changeHandlerName](newValue, oldValue);
          };
        }
      } else if ('propertyChanged' in viewModel) {
        selfSubscriber = function(newValue, oldValue) {
          return viewModel.propertyChanged(name, newValue, oldValue);
        };
      } else if (changeHandlerName !== null) {
        throw new Error('Change handler ' + changeHandlerName + ' was specified but not delcared on the class.');
      }
      if (defaultValue !== undefined) {
        initialValue = typeof defaultValue === 'function' ? defaultValue.call(viewModel) : defaultValue;
      }
      return new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, this.name, selfSubscriber, initialValue);
    };
    BindableProperty.prototype._initialize = function _initialize(viewModel, observerLookup, attributes, behaviorHandlesBind, boundProperties) {
      var selfSubscriber = undefined;
      var observer = undefined;
      var attribute = undefined;
      var defaultValue = this.defaultValue;
      if (this.isDynamic) {
        for (var key in attributes) {
          this._createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, key, attributes[key], boundProperties);
        }
      } else if (!this.hasOptions) {
        observer = observerLookup[this.name];
        if (attributes !== null) {
          selfSubscriber = observer.selfSubscriber;
          attribute = attributes[this.attribute];
          if (behaviorHandlesBind) {
            observer.selfSubscriber = null;
          }
          if (typeof attribute === 'string') {
            viewModel[this.name] = attribute;
            observer.call();
          } else if (attribute) {
            boundProperties.push({
              observer: observer,
              binding: attribute.createBinding(viewModel)
            });
          } else if (defaultValue !== undefined) {
            observer.call();
          }
          observer.selfSubscriber = selfSubscriber;
        }
        observer.publishing = true;
      }
    };
    BindableProperty.prototype._createDynamicProperty = function _createDynamicProperty(viewModel, observerLookup, behaviorHandlesBind, name, attribute, boundProperties) {
      var changeHandlerName = name + 'Changed';
      var selfSubscriber = null;
      var observer = undefined;
      var info = undefined;
      if (changeHandlerName in viewModel) {
        if ('propertyChanged' in viewModel) {
          selfSubscriber = function(newValue, oldValue) {
            viewModel[changeHandlerName](newValue, oldValue);
            viewModel.propertyChanged(name, newValue, oldValue);
          };
        } else {
          selfSubscriber = function(newValue, oldValue) {
            return viewModel[changeHandlerName](newValue, oldValue);
          };
        }
      } else if ('propertyChanged' in viewModel) {
        selfSubscriber = function(newValue, oldValue) {
          return viewModel.propertyChanged(name, newValue, oldValue);
        };
      }
      observer = observerLookup[name] = new BehaviorPropertyObserver(this.owner.taskQueue, viewModel, name, selfSubscriber);
      Object.defineProperty(viewModel, name, {
        configurable: true,
        enumerable: true,
        get: observer.getValue.bind(observer),
        set: observer.setValue.bind(observer)
      });
      if (behaviorHandlesBind) {
        observer.selfSubscriber = null;
      }
      if (typeof attribute === 'string') {
        viewModel[name] = attribute;
        observer.call();
      } else if (attribute) {
        info = {
          observer: observer,
          binding: attribute.createBinding(viewModel)
        };
        boundProperties.push(info);
      }
      observer.publishing = true;
      observer.selfSubscriber = selfSubscriber;
    };
    return BindableProperty;
  })();
  exports.BindableProperty = BindableProperty;
  var contentSelectorViewCreateInstruction = {enhance: false};
  var lastProviderId = 0;
  function nextProviderId() {
    return ++lastProviderId;
  }
  function doProcessContent() {
    return true;
  }
  var HtmlBehaviorResource = (function() {
    function HtmlBehaviorResource() {
      _classCallCheck(this, HtmlBehaviorResource);
      this.elementName = null;
      this.attributeName = null;
      this.attributeDefaultBindingMode = undefined;
      this.liftsContent = false;
      this.targetShadowDOM = false;
      this.processContent = doProcessContent;
      this.usesShadowDOM = false;
      this.childBindings = null;
      this.hasDynamicOptions = false;
      this.containerless = false;
      this.properties = [];
      this.attributes = {};
      this.isInitialized = false;
    }
    HtmlBehaviorResource.convention = function convention(name, existing) {
      var behavior = undefined;
      if (name.endsWith('CustomAttribute')) {
        behavior = existing || new HtmlBehaviorResource();
        behavior.attributeName = _hyphenate(name.substring(0, name.length - 15));
      }
      if (name.endsWith('CustomElement')) {
        behavior = existing || new HtmlBehaviorResource();
        behavior.elementName = _hyphenate(name.substring(0, name.length - 13));
      }
      return behavior;
    };
    HtmlBehaviorResource.prototype.addChildBinding = function addChildBinding(behavior) {
      if (this.childBindings === null) {
        this.childBindings = [];
      }
      this.childBindings.push(behavior);
    };
    HtmlBehaviorResource.prototype.initialize = function initialize(container, target) {
      var proto = target.prototype;
      var properties = this.properties;
      var attributeName = this.attributeName;
      var attributeDefaultBindingMode = this.attributeDefaultBindingMode;
      var i = undefined;
      var ii = undefined;
      var current = undefined;
      if (this.isInitialized) {
        return;
      }
      this.isInitialized = true;
      target.__providerId__ = nextProviderId();
      this.observerLocator = container.get(_aureliaBinding.ObserverLocator);
      this.taskQueue = container.get(_aureliaTaskQueue.TaskQueue);
      this.target = target;
      this.usesShadowDOM = this.targetShadowDOM && _aureliaPal.FEATURE.shadowDOM;
      this.handlesCreated = 'created' in proto;
      this.handlesBind = 'bind' in proto;
      this.handlesUnbind = 'unbind' in proto;
      this.handlesAttached = 'attached' in proto;
      this.handlesDetached = 'detached' in proto;
      this.htmlName = this.elementName || this.attributeName;
      if (attributeName !== null) {
        if (properties.length === 0) {
          new BindableProperty({
            name: 'value',
            changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
            attribute: attributeName,
            defaultBindingMode: attributeDefaultBindingMode
          }).registerWith(target, this);
        }
        current = properties[0];
        if (properties.length === 1 && current.name === 'value') {
          current.isDynamic = current.hasOptions = this.hasDynamicOptions;
          current.defineOn(target, this);
        } else {
          for (i = 0, ii = properties.length; i < ii; ++i) {
            properties[i].defineOn(target, this);
          }
          current = new BindableProperty({
            name: 'value',
            changeHandler: 'valueChanged' in proto ? 'valueChanged' : null,
            attribute: attributeName,
            defaultBindingMode: attributeDefaultBindingMode
          });
          current.hasOptions = true;
          current.registerWith(target, this);
        }
      } else {
        for (i = 0, ii = properties.length; i < ii; ++i) {
          properties[i].defineOn(target, this);
        }
      }
    };
    HtmlBehaviorResource.prototype.register = function register(registry, name) {
      if (this.attributeName !== null) {
        registry.registerAttribute(name || this.attributeName, this, this.attributeName);
      }
      if (this.elementName !== null) {
        registry.registerElement(name || this.elementName, this);
      }
    };
    HtmlBehaviorResource.prototype.load = function load(container, target, loadContext, viewStrategy, transientView) {
      var _this7 = this;
      var options = undefined;
      if (this.elementName !== null) {
        viewStrategy = container.get(ViewLocator).getViewStrategy(viewStrategy || this.viewStrategy || target);
        options = new ViewCompileInstruction(this.targetShadowDOM, true);
        if (!viewStrategy.moduleId) {
          viewStrategy.moduleId = _aureliaMetadata.Origin.get(target).moduleId;
        }
        return viewStrategy.loadViewFactory(container.get(ViewEngine), options, loadContext).then(function(viewFactory) {
          if (!transientView || !_this7.viewFactory) {
            _this7.viewFactory = viewFactory;
          }
          return viewFactory;
        });
      }
      return Promise.resolve(this);
    };
    HtmlBehaviorResource.prototype.compile = function compile(compiler, resources, node, instruction, parentNode) {
      if (this.liftsContent) {
        if (!instruction.viewFactory) {
          var template = _aureliaPal.DOM.createElement('template');
          var fragment = _aureliaPal.DOM.createDocumentFragment();
          var cacheSize = node.getAttribute('view-cache');
          var part = node.getAttribute('part');
          node.removeAttribute(instruction.originalAttrName);
          _aureliaPal.DOM.replaceNode(template, node, parentNode);
          fragment.appendChild(node);
          instruction.viewFactory = compiler.compile(fragment, resources);
          if (part) {
            instruction.viewFactory.part = part;
            node.removeAttribute('part');
          }
          if (cacheSize) {
            instruction.viewFactory.setCacheSize(cacheSize);
            node.removeAttribute('view-cache');
          }
          node = template;
        }
      } else if (this.elementName !== null) {
        var _partReplacements2 = instruction.partReplacements = {};
        if (this.processContent(compiler, resources, node, instruction) && node.hasChildNodes()) {
          if (this.usesShadowDOM) {
            var currentChild = node.firstChild;
            var nextSibling = undefined;
            var toReplace = undefined;
            while (currentChild) {
              nextSibling = currentChild.nextSibling;
              if (currentChild.tagName === 'TEMPLATE' && (toReplace = currentChild.getAttribute('replace-part'))) {
                _partReplacements2[toReplace] = compiler.compile(currentChild, resources);
                _aureliaPal.DOM.removeNode(currentChild, parentNode);
              }
              currentChild = nextSibling;
            }
            instruction.skipContentProcessing = false;
          } else {
            var fragment = _aureliaPal.DOM.createDocumentFragment();
            var currentChild = node.firstChild;
            var nextSibling = undefined;
            var toReplace = undefined;
            while (currentChild) {
              nextSibling = currentChild.nextSibling;
              if (currentChild.tagName === 'TEMPLATE' && (toReplace = currentChild.getAttribute('replace-part'))) {
                _partReplacements2[toReplace] = compiler.compile(currentChild, resources);
                _aureliaPal.DOM.removeNode(currentChild, parentNode);
              } else {
                fragment.appendChild(currentChild);
              }
              currentChild = nextSibling;
            }
            instruction.contentFactory = compiler.compile(fragment, resources);
            instruction.skipContentProcessing = true;
          }
        } else {
          instruction.skipContentProcessing = true;
        }
      }
      return node;
    };
    HtmlBehaviorResource.prototype.create = function create(container, instruction, element, bindings) {
      var host = undefined;
      var au = null;
      instruction = instruction || BehaviorInstruction.normal;
      element = element || null;
      bindings = bindings || null;
      if (this.elementName !== null && element) {
        if (this.usesShadowDOM) {
          host = element.createShadowRoot();
          container.registerInstance(_aureliaPal.DOM.boundary, host);
        } else {
          host = element;
          if (this.targetShadowDOM) {
            container.registerInstance(_aureliaPal.DOM.boundary, host);
          }
        }
      }
      if (element !== null) {
        element.au = au = element.au || {};
      }
      var viewModel = instruction.viewModel || container.get(this.target);
      var controller = new Controller(this, instruction, viewModel);
      var childBindings = this.childBindings;
      var viewFactory = undefined;
      if (this.liftsContent) {
        au.controller = controller;
      } else if (this.elementName !== null) {
        viewFactory = instruction.viewFactory || this.viewFactory;
        container.viewModel = viewModel;
        if (viewFactory) {
          controller.view = viewFactory.create(container, instruction, element);
        }
        if (element !== null) {
          au.controller = controller;
          if (controller.view) {
            if (!this.usesShadowDOM) {
              if (instruction.contentFactory) {
                var contentView = instruction.contentFactory.create(container, contentSelectorViewCreateInstruction);
                _ContentSelector.applySelectors(contentView, controller.view.contentSelectors, function(contentSelector, group) {
                  return contentSelector.add(group);
                });
                controller.contentView = contentView;
              }
            }
            if (instruction.anchorIsContainer) {
              if (childBindings !== null) {
                for (var i = 0,
                    ii = childBindings.length; i < ii; ++i) {
                  controller.view.addBinding(childBindings[i].create(element, viewModel));
                }
              }
              controller.view.appendNodesTo(host);
            } else {
              controller.view.insertNodesBefore(host);
            }
          } else if (childBindings !== null) {
            for (var i = 0,
                ii = childBindings.length; i < ii; ++i) {
              bindings.push(childBindings[i].create(element, viewModel));
            }
          }
        } else if (controller.view) {
          controller.view.controller = controller;
          if (childBindings !== null) {
            for (var i = 0,
                ii = childBindings.length; i < ii; ++i) {
              controller.view.addBinding(childBindings[i].create(instruction.host, viewModel));
            }
          }
        } else if (childBindings !== null) {
          for (var i = 0,
              ii = childBindings.length; i < ii; ++i) {
            bindings.push(childBindings[i].create(instruction.host, viewModel));
          }
        }
      } else if (childBindings !== null) {
        for (var i = 0,
            ii = childBindings.length; i < ii; ++i) {
          bindings.push(childBindings[i].create(element, viewModel));
        }
      }
      if (au !== null) {
        au[this.htmlName] = controller;
      }
      if (instruction.initiatedByBehavior && viewFactory) {
        controller.view.created();
      }
      return controller;
    };
    HtmlBehaviorResource.prototype._ensurePropertiesDefined = function _ensurePropertiesDefined(instance, lookup) {
      var properties = undefined;
      var i = undefined;
      var ii = undefined;
      var observer = undefined;
      if ('__propertiesDefined__' in lookup) {
        return;
      }
      lookup.__propertiesDefined__ = true;
      properties = this.properties;
      for (i = 0, ii = properties.length; i < ii; ++i) {
        observer = properties[i].createObserver(instance);
        if (observer !== undefined) {
          lookup[observer.propertyName] = observer;
        }
      }
    };
    return HtmlBehaviorResource;
  })();
  exports.HtmlBehaviorResource = HtmlBehaviorResource;
  function createChildObserverDecorator(selectorOrConfig, all) {
    return function(target, key, descriptor) {
      var actualTarget = typeof key === 'string' ? target.constructor : target;
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);
      if (typeof selectorOrConfig === 'string') {
        selectorOrConfig = {
          selector: selectorOrConfig,
          name: key
        };
      }
      if (descriptor) {
        descriptor.writable = true;
      }
      selectorOrConfig.all = all;
      r.addChildBinding(new ChildObserver(selectorOrConfig));
    };
  }
  function children(selectorOrConfig) {
    return createChildObserverDecorator(selectorOrConfig, true);
  }
  function child(selectorOrConfig) {
    return createChildObserverDecorator(selectorOrConfig, false);
  }
  var ChildObserver = (function() {
    function ChildObserver(config) {
      _classCallCheck(this, ChildObserver);
      this.name = config.name;
      this.changeHandler = config.changeHandler || this.name + 'Changed';
      this.selector = config.selector;
      this.all = config.all;
    }
    ChildObserver.prototype.create = function create(target, viewModel) {
      return new ChildObserverBinder(this.selector, target, this.name, viewModel, this.changeHandler, this.all);
    };
    return ChildObserver;
  })();
  var noMutations = [];
  function trackMutation(groupedMutations, binder, record) {
    var mutations = groupedMutations.get(binder);
    if (!mutations) {
      mutations = [];
      groupedMutations.set(binder, mutations);
    }
    mutations.push(record);
  }
  function onChildChange(mutations, observer) {
    var binders = observer.binders;
    var bindersLength = binders.length;
    var groupedMutations = new Map();
    for (var i = 0,
        ii = mutations.length; i < ii; ++i) {
      var record = mutations[i];
      var added = record.addedNodes;
      var removed = record.removedNodes;
      for (var j = 0,
          jj = removed.length; j < jj; ++j) {
        var node = removed[j];
        if (node.nodeType === 1) {
          for (var k = 0; k < bindersLength; ++k) {
            var binder = binders[k];
            if (binder.onRemove(node)) {
              trackMutation(groupedMutations, binder, record);
            }
          }
        }
      }
      for (var j = 0,
          jj = added.length; j < jj; ++j) {
        var node = added[j];
        if (node.nodeType === 1) {
          for (var k = 0; k < bindersLength; ++k) {
            var binder = binders[k];
            if (binder.onAdd(node)) {
              trackMutation(groupedMutations, binder, record);
            }
          }
        }
      }
    }
    groupedMutations.forEach(function(value, key) {
      if (key.changeHandler !== null) {
        key.viewModel[key.changeHandler](value);
      }
    });
  }
  var ChildObserverBinder = (function() {
    function ChildObserverBinder(selector, target, property, viewModel, changeHandler, all) {
      _classCallCheck(this, ChildObserverBinder);
      this.selector = selector;
      this.target = target;
      this.property = property;
      this.viewModel = viewModel;
      this.changeHandler = changeHandler in viewModel ? changeHandler : null;
      this.all = all;
    }
    ChildObserverBinder.prototype.bind = function bind(source) {
      var target = this.target;
      var viewModel = this.viewModel;
      var selector = this.selector;
      var current = target.firstElementChild;
      var observer = target.__childObserver__;
      if (!observer) {
        observer = target.__childObserver__ = _aureliaPal.DOM.createMutationObserver(onChildChange);
        observer.observe(target, {childList: true});
        observer.binders = [];
      }
      observer.binders.push(this);
      if (this.all) {
        var items = viewModel[this.property];
        if (!items) {
          items = viewModel[this.property] = [];
        } else {
          items.length = 0;
        }
        while (current) {
          if (current.matches(selector)) {
            items.push(current.au && current.au.controller ? current.au.controller.viewModel : current);
          }
          current = current.nextElementSibling;
        }
        if (this.changeHandler !== null) {
          this.viewModel[this.changeHandler](noMutations);
        }
      } else {
        while (current) {
          if (current.matches(selector)) {
            var value = current.au && current.au.controller ? current.au.controller.viewModel : current;
            this.viewModel[this.property] = value;
            if (this.changeHandler !== null) {
              this.viewModel[this.changeHandler](value);
            }
            break;
          }
          current = current.nextElementSibling;
        }
      }
    };
    ChildObserverBinder.prototype.onRemove = function onRemove(element) {
      if (element.matches(this.selector)) {
        var value = element.au && element.au.controller ? element.au.controller.viewModel : element;
        if (this.all) {
          var items = this.viewModel[this.property];
          var index = items.indexOf(value);
          if (index !== -1) {
            items.splice(index, 1);
          }
          return true;
        }
        return false;
      }
    };
    ChildObserverBinder.prototype.onAdd = function onAdd(element) {
      var selector = this.selector;
      if (element.matches(selector)) {
        var value = element.au && element.au.controller ? element.au.controller.viewModel : element;
        if (this.all) {
          var items = this.viewModel[this.property];
          var index = 0;
          var prev = element.previousElementSibling;
          while (prev) {
            if (prev.matches(selector)) {
              index++;
            }
            prev = prev.previousElementSibling;
          }
          items.splice(index, 0, value);
          return true;
        }
        this.viewModel[this.property] = value;
        if (this.changeHandler !== null) {
          this.viewModel[this.changeHandler](value);
        }
      }
      return false;
    };
    ChildObserverBinder.prototype.unbind = function unbind() {
      if (this.target.__childObserver__) {
        this.target.__childObserver__.disconnect();
        this.target.__childObserver__ = null;
      }
    };
    return ChildObserverBinder;
  })();
  function tryActivateViewModel(context) {
    if (context.skipActivation || typeof context.viewModel.activate !== 'function') {
      return Promise.resolve();
    }
    return context.viewModel.activate(context.model) || Promise.resolve();
  }
  var CompositionEngine = (function() {
    function CompositionEngine(viewEngine, viewLocator) {
      _classCallCheck(this, _CompositionEngine);
      this.viewEngine = viewEngine;
      this.viewLocator = viewLocator;
    }
    CompositionEngine.prototype._createControllerAndSwap = function _createControllerAndSwap(context) {
      var _this8 = this;
      var removeResponse = context.viewSlot.removeAll(true);
      var afterRemove = function afterRemove() {
        return _this8.createController(context).then(function(controller) {
          if (context.currentController) {
            context.currentController.unbind();
          }
          controller.automate(context.overrideContext, context.owningView);
          context.viewSlot.add(controller.view);
          return controller;
        });
      };
      if (removeResponse instanceof Promise) {
        return removeResponse.then(afterRemove);
      }
      return afterRemove();
    };
    CompositionEngine.prototype.createController = function createController(context) {
      var _this9 = this;
      var childContainer = undefined;
      var viewModel = undefined;
      var viewModelResource = undefined;
      var m = undefined;
      return this.ensureViewModel(context).then(tryActivateViewModel).then(function() {
        childContainer = context.childContainer;
        viewModel = context.viewModel;
        viewModelResource = context.viewModelResource;
        m = viewModelResource.metadata;
        var viewStrategy = _this9.viewLocator.getViewStrategy(context.view || viewModel);
        if (context.viewResources) {
          viewStrategy.makeRelativeTo(context.viewResources.viewUrl);
        }
        return m.load(childContainer, viewModelResource.value, null, viewStrategy, true);
      }).then(function(viewFactory) {
        return m.create(childContainer, BehaviorInstruction.dynamic(context.host, viewModel, viewFactory));
      });
    };
    CompositionEngine.prototype.ensureViewModel = function ensureViewModel(context) {
      var childContainer = context.childContainer = context.childContainer || context.container.createChild();
      if (typeof context.viewModel === 'string') {
        context.viewModel = context.viewResources ? context.viewResources.relativeToView(context.viewModel) : context.viewModel;
        return this.viewEngine.importViewModelResource(context.viewModel).then(function(viewModelResource) {
          childContainer.autoRegister(viewModelResource.value);
          if (context.host) {
            childContainer.registerInstance(_aureliaPal.DOM.Element, context.host);
          }
          context.viewModel = childContainer.viewModel = childContainer.get(viewModelResource.value);
          context.viewModelResource = viewModelResource;
          return context;
        });
      }
      var m = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, context.viewModel.constructor);
      m.elementName = m.elementName || 'dynamic-element';
      m.initialize(context.container || childContainer, context.viewModel.constructor);
      context.viewModelResource = {
        metadata: m,
        value: context.viewModel.constructor
      };
      childContainer.viewModel = context.viewModel;
      return Promise.resolve(context);
    };
    CompositionEngine.prototype.compose = function compose(context) {
      context.childContainer = context.childContainer || context.container.createChild();
      context.view = this.viewLocator.getViewStrategy(context.view);
      if (context.viewModel) {
        return this._createControllerAndSwap(context);
      } else if (context.view) {
        if (context.viewResources) {
          context.view.makeRelativeTo(context.viewResources.viewUrl);
        }
        return context.view.loadViewFactory(this.viewEngine, new ViewCompileInstruction()).then(function(viewFactory) {
          var removeResponse = context.viewSlot.removeAll(true);
          if (removeResponse instanceof Promise) {
            return removeResponse.then(function() {
              var result = viewFactory.create(context.childContainer);
              result.bind(context.bindingContext, context.overrideContext);
              context.viewSlot.add(result);
              return result;
            });
          }
          var result = viewFactory.create(context.childContainer);
          result.bind(context.bindingContext, context.overrideContext);
          context.viewSlot.add(result);
          return result;
        });
      } else if (context.viewSlot) {
        context.viewSlot.removeAll();
        return Promise.resolve(null);
      }
    };
    var _CompositionEngine = CompositionEngine;
    CompositionEngine = _aureliaDependencyInjection.inject(ViewEngine, ViewLocator)(CompositionEngine) || CompositionEngine;
    return CompositionEngine;
  })();
  exports.CompositionEngine = CompositionEngine;
  var ElementConfigResource = (function() {
    function ElementConfigResource() {
      _classCallCheck(this, ElementConfigResource);
    }
    ElementConfigResource.prototype.initialize = function initialize(container, target) {};
    ElementConfigResource.prototype.register = function register(registry, name) {};
    ElementConfigResource.prototype.load = function load(container, target) {
      var config = new Target();
      var eventManager = container.get(_aureliaBinding.EventManager);
      eventManager.registerElementConfig(config);
    };
    return ElementConfigResource;
  })();
  exports.ElementConfigResource = ElementConfigResource;
  function validateBehaviorName(name, type) {
    if (/[A-Z]/.test(name)) {
      throw new Error('\'' + name + '\' is not a valid ' + type + ' name.  Upper-case letters are not allowed because the DOM is not case-sensitive.');
    }
  }
  function resource(instance) {
    return function(target) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, instance, target);
    };
  }
  function behavior(override) {
    return function(target) {
      if (override instanceof HtmlBehaviorResource) {
        _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, override, target);
      } else {
        var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
        Object.assign(r, override);
      }
    };
  }
  function customElement(name) {
    validateBehaviorName(name, 'custom element');
    return function(target) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
      r.elementName = name;
    };
  }
  function customAttribute(name, defaultBindingMode) {
    validateBehaviorName(name, 'custom attribute');
    return function(target) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, target);
      r.attributeName = name;
      r.attributeDefaultBindingMode = defaultBindingMode;
    };
  }
  function templateController(target) {
    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.liftsContent = true;
    };
    return target ? deco(target) : deco;
  }
  function bindable(nameOrConfigOrTarget, key, descriptor) {
    var deco = function deco(target, key2, descriptor2) {
      var actualTarget = key2 ? target.constructor : target;
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, actualTarget);
      var prop = undefined;
      if (key2) {
        nameOrConfigOrTarget = nameOrConfigOrTarget || {};
        nameOrConfigOrTarget.name = key2;
      }
      prop = new BindableProperty(nameOrConfigOrTarget);
      return prop.registerWith(actualTarget, r, descriptor2);
    };
    if (!nameOrConfigOrTarget) {
      return deco;
    }
    if (key) {
      var target = nameOrConfigOrTarget;
      nameOrConfigOrTarget = null;
      return deco(target, key, descriptor);
    }
    return deco;
  }
  function dynamicOptions(target) {
    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.hasDynamicOptions = true;
    };
    return target ? deco(target) : deco;
  }
  function useShadowDOM(target) {
    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.targetShadowDOM = true;
    };
    return target ? deco(target) : deco;
  }
  function doNotProcessContent() {
    return false;
  }
  function processContent(processor) {
    return function(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.processContent = processor || doNotProcessContent;
    };
  }
  function containerless(target) {
    var deco = function deco(t) {
      var r = _aureliaMetadata.metadata.getOrCreateOwn(_aureliaMetadata.metadata.resource, HtmlBehaviorResource, t);
      r.containerless = true;
    };
    return target ? deco(target) : deco;
  }
  function useViewStrategy(strategy) {
    return function(target) {
      _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, strategy, target);
    };
  }
  function useView(path) {
    return useViewStrategy(new RelativeViewStrategy(path));
  }
  function inlineView(markup, dependencies, dependencyBaseUrl) {
    return useViewStrategy(new InlineViewStrategy(markup, dependencies, dependencyBaseUrl));
  }
  function noView(target) {
    var deco = function deco(t) {
      _aureliaMetadata.metadata.define(ViewLocator.viewStrategyMetadataKey, new NoViewStrategy(), t);
    };
    return target ? deco(target) : deco;
  }
  function elementConfig(target) {
    var deco = function deco(t) {
      _aureliaMetadata.metadata.define(_aureliaMetadata.metadata.resource, new ElementConfigResource(), t);
    };
    return target ? deco(target) : deco;
  }
  var TemplatingEngine = (function() {
    function TemplatingEngine(container, moduleAnalyzer, viewCompiler, compositionEngine) {
      _classCallCheck(this, _TemplatingEngine);
      this._container = container;
      this._moduleAnalyzer = moduleAnalyzer;
      this._viewCompiler = viewCompiler;
      this._compositionEngine = compositionEngine;
      container.registerInstance(Animator, Animator.instance = new Animator());
    }
    TemplatingEngine.prototype.configureAnimator = function configureAnimator(animator) {
      this._container.unregister(Animator);
      this._container.registerInstance(Animator, Animator.instance = animator);
    };
    TemplatingEngine.prototype.compose = function compose(context) {
      return this._compositionEngine.compose(context);
    };
    TemplatingEngine.prototype.enhance = function enhance(instruction) {
      if (instruction instanceof _aureliaPal.DOM.Element) {
        instruction = {element: instruction};
      }
      var compilerInstructions = {};
      var resources = instruction.resources || this._container.get(ViewResources);
      this._viewCompiler._compileNode(instruction.element, resources, compilerInstructions, instruction.element.parentNode, 'root', true);
      var factory = new ViewFactory(instruction.element, compilerInstructions, resources);
      var container = instruction.container || this._container.createChild();
      var view = factory.create(container, BehaviorInstruction.enhance());
      view.bind(instruction.bindingContext || {});
      return view;
    };
    TemplatingEngine.prototype.createControllerForUnitTest = function createControllerForUnitTest(viewModelType, attributesFromHTML) {
      var _moduleAnalyzer$analyze;
      var exportName = viewModelType.name;
      var resourceModule = this._moduleAnalyzer.analyze('test-module', (_moduleAnalyzer$analyze = {}, _moduleAnalyzer$analyze[exportName] = viewModelType, _moduleAnalyzer$analyze), exportName);
      var description = resourceModule.mainResource;
      description.initialize(this._container);
      var viewModel = this._container.get(viewModelType);
      var instruction = BehaviorInstruction.unitTest(description, attributesFromHTML);
      return new Controller(description.metadata, instruction, viewModel);
    };
    TemplatingEngine.prototype.createViewModelForUnitTest = function createViewModelForUnitTest(viewModelType, attributesFromHTML, bindingContext) {
      var controller = this.createControllerForUnitTest(viewModelType, attributesFromHTML);
      controller.bind(_aureliaBinding.createScopeForTest(bindingContext));
      return controller.viewModel;
    };
    var _TemplatingEngine = TemplatingEngine;
    TemplatingEngine = _aureliaDependencyInjection.inject(_aureliaDependencyInjection.Container, ModuleAnalyzer, ViewCompiler, CompositionEngine)(TemplatingEngine) || TemplatingEngine;
    return TemplatingEngine;
  })();
  exports.TemplatingEngine = TemplatingEngine;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating@1.0.0-beta.1.0.3", ["npm:aurelia-templating@1.0.0-beta.1.0.3/aurelia-templating"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-binding@1.0.0-beta.1.0.2/aurelia-templating-binding", ["exports", "npm:aurelia-logging@1.0.0-beta.1.1.1", "npm:aurelia-binding@1.0.0-beta.1.0.5", "npm:aurelia-templating@1.0.0-beta.1.0.3"], function(exports, _aureliaLogging, _aureliaBinding, _aureliaTemplating) {
  'use strict';
  exports.__esModule = true;
  exports.configure = configure;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var InterpolationBindingExpression = (function() {
    function InterpolationBindingExpression(observerLocator, targetProperty, parts, mode, lookupFunctions, attribute) {
      _classCallCheck(this, InterpolationBindingExpression);
      this.observerLocator = observerLocator;
      this.targetProperty = targetProperty;
      this.parts = parts;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
      this.attribute = this.attrToRemove = attribute;
      this.discrete = false;
    }
    InterpolationBindingExpression.prototype.createBinding = function createBinding(target) {
      if (this.parts.length === 3) {
        return new ChildInterpolationBinding(target, this.observerLocator, this.parts[1], this.mode, this.lookupFunctions, this.targetProperty, this.parts[0], this.parts[2]);
      }
      return new InterpolationBinding(this.observerLocator, this.parts, target, this.targetProperty, this.mode, this.lookupFunctions);
    };
    return InterpolationBindingExpression;
  })();
  exports.InterpolationBindingExpression = InterpolationBindingExpression;
  function validateTarget(target, propertyName) {
    if (propertyName === 'style') {
      _aureliaLogging.getLogger('templating-binding').info('Internet Explorer does not support interpolation in "style" attributes.  Use the style attribute\'s alias, "css" instead.');
    } else if (target.parentElement && target.parentElement.nodeName === 'TEXTAREA' && propertyName === 'textContent') {
      throw new Error('Interpolation binding cannot be used in the content of a textarea element.  Use <textarea value.bind="expression"></textarea> instead.');
    }
  }
  var InterpolationBinding = (function() {
    function InterpolationBinding(observerLocator, parts, target, targetProperty, mode, lookupFunctions) {
      _classCallCheck(this, InterpolationBinding);
      validateTarget(target, targetProperty);
      this.observerLocator = observerLocator;
      this.parts = parts;
      this.target = target;
      this.targetProperty = targetProperty;
      this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
    }
    InterpolationBinding.prototype.interpolate = function interpolate() {
      if (this.isBound) {
        var value = '';
        var parts = this.parts;
        for (var i = 0,
            ii = parts.length; i < ii; i++) {
          value += i % 2 === 0 ? parts[i] : this['childBinding' + i].value;
        }
        this.targetAccessor.setValue(value, this.target, this.targetProperty);
      }
    };
    InterpolationBinding.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.source = source;
      var parts = this.parts;
      for (var i = 1,
          ii = parts.length; i < ii; i += 2) {
        var binding = new ChildInterpolationBinding(this, this.observerLocator, parts[i], this.mode, this.lookupFunctions);
        binding.bind(source);
        this['childBinding' + i] = binding;
      }
      this.isBound = true;
      this.interpolate();
    };
    InterpolationBinding.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      this.source = null;
      var parts = this.parts;
      for (var i = 1,
          ii = parts.length; i < ii; i += 2) {
        var _name = 'childBinding' + i;
        this[_name].unbind();
      }
    };
    return InterpolationBinding;
  })();
  exports.InterpolationBinding = InterpolationBinding;
  var ChildInterpolationBinding = (function() {
    function ChildInterpolationBinding(target, observerLocator, sourceExpression, mode, lookupFunctions, targetProperty, left, right) {
      _classCallCheck(this, _ChildInterpolationBinding);
      if (target instanceof InterpolationBinding) {
        this.parent = target;
      } else {
        validateTarget(target, targetProperty);
        this.target = target;
        this.targetProperty = targetProperty;
        this.targetAccessor = observerLocator.getAccessor(target, targetProperty);
      }
      this.observerLocator = observerLocator;
      this.sourceExpression = sourceExpression;
      this.mode = mode;
      this.lookupFunctions = lookupFunctions;
      this.left = left;
      this.right = right;
    }
    ChildInterpolationBinding.prototype.updateTarget = function updateTarget(value) {
      value = value === null || value === undefined ? '' : value.toString();
      if (value !== this.value) {
        this.value = value;
        if (this.parent) {
          this.parent.interpolate();
        } else {
          this.targetAccessor.setValue(this.left + value + this.right, this.target, this.targetProperty);
        }
      }
    };
    ChildInterpolationBinding.prototype.call = function call() {
      if (!this.isBound) {
        return;
      }
      var value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
      this.updateTarget(value);
      if (this.mode !== _aureliaBinding.bindingMode.oneTime) {
        this._version++;
        this.sourceExpression.connect(this, this.source);
        if (value instanceof Array) {
          this.observeArray(value);
        }
        this.unobserve(false);
      }
    };
    ChildInterpolationBinding.prototype.bind = function bind(source) {
      if (this.isBound) {
        if (this.source === source) {
          return;
        }
        this.unbind();
      }
      this.isBound = true;
      this.source = source;
      var sourceExpression = this.sourceExpression;
      if (sourceExpression.bind) {
        sourceExpression.bind(this, source, this.lookupFunctions);
      }
      var value = sourceExpression.evaluate(source, this.lookupFunctions);
      this.updateTarget(value);
      if (this.mode === _aureliaBinding.bindingMode.oneWay) {
        _aureliaBinding.enqueueBindingConnect(this);
      }
    };
    ChildInterpolationBinding.prototype.unbind = function unbind() {
      if (!this.isBound) {
        return;
      }
      this.isBound = false;
      var sourceExpression = this.sourceExpression;
      if (sourceExpression.unbind) {
        sourceExpression.unbind(this, this.source);
      }
      this.source = null;
      this.unobserve(true);
    };
    ChildInterpolationBinding.prototype.connect = function connect(evaluate) {
      if (!this.isBound) {
        return;
      }
      if (evaluate) {
        var value = this.sourceExpression.evaluate(this.source, this.lookupFunctions);
        this.updateTarget(value);
      }
      this.sourceExpression.connect(this, this.source);
      if (this.value instanceof Array) {
        this.observeArray(this.value);
      }
    };
    var _ChildInterpolationBinding = ChildInterpolationBinding;
    ChildInterpolationBinding = _aureliaBinding.connectable()(ChildInterpolationBinding) || ChildInterpolationBinding;
    return ChildInterpolationBinding;
  })();
  exports.ChildInterpolationBinding = ChildInterpolationBinding;
  var SyntaxInterpreter = (function() {
    SyntaxInterpreter.inject = function inject() {
      return [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, _aureliaBinding.EventManager];
    };
    function SyntaxInterpreter(parser, observerLocator, eventManager) {
      _classCallCheck(this, SyntaxInterpreter);
      this.parser = parser;
      this.observerLocator = observerLocator;
      this.eventManager = eventManager;
    }
    SyntaxInterpreter.prototype.interpret = function interpret(resources, element, info, existingInstruction, context) {
      if (info.command in this) {
        return this[info.command](resources, element, info, existingInstruction, context);
      }
      return this.handleUnknownCommand(resources, element, info, existingInstruction, context);
    };
    SyntaxInterpreter.prototype.handleUnknownCommand = function handleUnknownCommand(resources, element, info, existingInstruction, context) {
      _aureliaLogging.getLogger('templating-binding').warn('Unknown binding command.', info);
      return existingInstruction;
    };
    SyntaxInterpreter.prototype.determineDefaultBindingMode = function determineDefaultBindingMode(element, attrName, context) {
      var tagName = element.tagName.toLowerCase();
      if (tagName === 'input') {
        return attrName === 'value' || attrName === 'checked' || attrName === 'files' ? _aureliaBinding.bindingMode.twoWay : _aureliaBinding.bindingMode.oneWay;
      } else if (tagName === 'textarea' || tagName === 'select') {
        return attrName === 'value' ? _aureliaBinding.bindingMode.twoWay : _aureliaBinding.bindingMode.oneWay;
      } else if (attrName === 'textcontent' || attrName === 'innerhtml') {
        return element.contentEditable === 'true' ? _aureliaBinding.bindingMode.twoWay : _aureliaBinding.bindingMode.oneWay;
      } else if (attrName === 'scrolltop' || attrName === 'scrollleft') {
        return _aureliaBinding.bindingMode.twoWay;
      }
      if (context && attrName in context.attributes) {
        return context.attributes[attrName].defaultBindingMode || _aureliaBinding.bindingMode.oneWay;
      }
      return _aureliaBinding.bindingMode.oneWay;
    };
    SyntaxInterpreter.prototype.bind = function bind(resources, element, info, existingInstruction, context) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap[info.attrName] || info.attrName, this.parser.parse(info.attrValue), info.defaultBindingMode || this.determineDefaultBindingMode(element, info.attrName, context), resources.lookupFunctions);
      return instruction;
    };
    SyntaxInterpreter.prototype.trigger = function trigger(resources, element, info) {
      return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), false, true, resources.lookupFunctions);
    };
    SyntaxInterpreter.prototype.delegate = function delegate(resources, element, info) {
      return new _aureliaBinding.ListenerExpression(this.eventManager, info.attrName, this.parser.parse(info.attrValue), true, true, resources.lookupFunctions);
    };
    SyntaxInterpreter.prototype.call = function call(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      instruction.attributes[info.attrName] = new _aureliaBinding.CallExpression(this.observerLocator, info.attrName, this.parser.parse(info.attrValue), resources.lookupFunctions);
      return instruction;
    };
    SyntaxInterpreter.prototype.options = function options(resources, element, info, existingInstruction, context) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      var attrValue = info.attrValue;
      var language = this.language;
      var name = null;
      var target = '';
      var current = undefined;
      var i = undefined;
      var ii = undefined;
      for (i = 0, ii = attrValue.length; i < ii; ++i) {
        current = attrValue[i];
        if (current === ';') {
          info = language.inspectAttribute(resources, name, target.trim());
          language.createAttributeInstruction(resources, element, info, instruction, context);
          if (!instruction.attributes[info.attrName]) {
            instruction.attributes[info.attrName] = info.attrValue;
          }
          target = '';
          name = null;
        } else if (current === ':' && name === null) {
          name = target.trim();
          target = '';
        } else {
          target += current;
        }
      }
      if (name !== null) {
        info = language.inspectAttribute(resources, name, target.trim());
        language.createAttributeInstruction(resources, element, info, instruction, context);
        if (!instruction.attributes[info.attrName]) {
          instruction.attributes[info.attrName] = info.attrValue;
        }
      }
      return instruction;
    };
    SyntaxInterpreter.prototype['for'] = function _for(resources, element, info, existingInstruction) {
      var parts = undefined;
      var keyValue = undefined;
      var instruction = undefined;
      var attrValue = undefined;
      var isDestructuring = undefined;
      attrValue = info.attrValue;
      isDestructuring = attrValue.match(/^ *[[].+[\]]/);
      parts = isDestructuring ? attrValue.split('of ') : attrValue.split(' of ');
      if (parts.length !== 2) {
        throw new Error('Incorrect syntax for "for". The form is: "$local of $items" or "[$key, $value] of $items".');
      }
      instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      if (isDestructuring) {
        keyValue = parts[0].replace(/[[\]]/g, '').replace(/,/g, ' ').replace(/\s+/g, ' ').trim().split(' ');
        instruction.attributes.key = keyValue[0];
        instruction.attributes.value = keyValue[1];
      } else {
        instruction.attributes.local = parts[0];
      }
      instruction.attributes.items = new _aureliaBinding.BindingExpression(this.observerLocator, 'items', this.parser.parse(parts[1]), _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions);
      return instruction;
    };
    SyntaxInterpreter.prototype['two-way'] = function twoWay(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap[info.attrName] || info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.twoWay, resources.lookupFunctions);
      return instruction;
    };
    SyntaxInterpreter.prototype['one-way'] = function oneWay(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap[info.attrName] || info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions);
      return instruction;
    };
    SyntaxInterpreter.prototype['one-time'] = function oneTime(resources, element, info, existingInstruction) {
      var instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(info.attrName);
      instruction.attributes[info.attrName] = new _aureliaBinding.BindingExpression(this.observerLocator, this.attributeMap[info.attrName] || info.attrName, this.parser.parse(info.attrValue), _aureliaBinding.bindingMode.oneTime, resources.lookupFunctions);
      return instruction;
    };
    return SyntaxInterpreter;
  })();
  exports.SyntaxInterpreter = SyntaxInterpreter;
  var info = {};
  var TemplatingBindingLanguage = (function(_BindingLanguage) {
    _inherits(TemplatingBindingLanguage, _BindingLanguage);
    TemplatingBindingLanguage.inject = function inject() {
      return [_aureliaBinding.Parser, _aureliaBinding.ObserverLocator, SyntaxInterpreter];
    };
    function TemplatingBindingLanguage(parser, observerLocator, syntaxInterpreter) {
      _classCallCheck(this, TemplatingBindingLanguage);
      _BindingLanguage.call(this);
      this.parser = parser;
      this.observerLocator = observerLocator;
      this.syntaxInterpreter = syntaxInterpreter;
      this.emptyStringExpression = this.parser.parse('\'\'');
      syntaxInterpreter.language = this;
      this.attributeMap = syntaxInterpreter.attributeMap = {
        'contenteditable': 'contentEditable',
        'for': 'htmlFor',
        'tabindex': 'tabIndex',
        'textcontent': 'textContent',
        'innerhtml': 'innerHTML',
        'maxlength': 'maxLength',
        'minlength': 'minLength',
        'formaction': 'formAction',
        'formenctype': 'formEncType',
        'formmethod': 'formMethod',
        'formnovalidate': 'formNoValidate',
        'formtarget': 'formTarget',
        'rowspan': 'rowSpan',
        'colspan': 'colSpan',
        'scrolltop': 'scrollTop',
        'scrollleft': 'scrollLeft',
        'readonly': 'readOnly'
      };
    }
    TemplatingBindingLanguage.prototype.inspectAttribute = function inspectAttribute(resources, attrName, attrValue) {
      var parts = attrName.split('.');
      info.defaultBindingMode = null;
      if (parts.length === 2) {
        info.attrName = parts[0].trim();
        info.attrValue = attrValue;
        info.command = parts[1].trim();
        if (info.command === 'ref') {
          info.expression = new _aureliaBinding.NameExpression(attrValue, info.attrName);
          info.command = null;
          info.attrName = 'ref';
        } else {
          info.expression = null;
        }
      } else if (attrName === 'ref') {
        info.attrName = attrName;
        info.attrValue = attrValue;
        info.command = null;
        info.expression = new _aureliaBinding.NameExpression(attrValue, 'element');
      } else {
        info.attrName = attrName;
        info.attrValue = attrValue;
        info.command = null;
        info.expression = this.parseContent(resources, attrName, attrValue);
      }
      return info;
    };
    TemplatingBindingLanguage.prototype.createAttributeInstruction = function createAttributeInstruction(resources, element, theInfo, existingInstruction, context) {
      var instruction = undefined;
      if (theInfo.expression) {
        if (theInfo.attrName === 'ref') {
          return theInfo.expression;
        }
        instruction = existingInstruction || _aureliaTemplating.BehaviorInstruction.attribute(theInfo.attrName);
        instruction.attributes[theInfo.attrName] = theInfo.expression;
      } else if (theInfo.command) {
        instruction = this.syntaxInterpreter.interpret(resources, element, theInfo, existingInstruction, context);
      }
      return instruction;
    };
    TemplatingBindingLanguage.prototype.parseText = function parseText(resources, value) {
      return this.parseContent(resources, 'textContent', value);
    };
    TemplatingBindingLanguage.prototype.parseContent = function parseContent(resources, attrName, attrValue) {
      var i = attrValue.indexOf('${', 0);
      var ii = attrValue.length;
      var char = undefined;
      var pos = 0;
      var open = 0;
      var quote = null;
      var interpolationStart = undefined;
      var parts = undefined;
      var partIndex = 0;
      while (i >= 0 && i < ii - 2) {
        open = 1;
        interpolationStart = i;
        i += 2;
        do {
          char = attrValue[i];
          i++;
          if (char === "'" || char === '"') {
            if (quote === null) {
              quote = char;
            } else if (quote === char) {
              quote = null;
            }
            continue;
          }
          if (char === '\\') {
            i++;
            continue;
          }
          if (quote !== null) {
            continue;
          }
          if (char === '{') {
            open++;
          } else if (char === '}') {
            open--;
          }
        } while (open > 0 && i < ii);
        if (open === 0) {
          parts = parts || [];
          if (attrValue[interpolationStart - 1] === '\\' && attrValue[interpolationStart - 2] !== '\\') {
            parts[partIndex] = attrValue.substring(pos, interpolationStart - 1) + attrValue.substring(interpolationStart, i);
            partIndex++;
            parts[partIndex] = this.emptyStringExpression;
            partIndex++;
          } else {
            parts[partIndex] = attrValue.substring(pos, interpolationStart);
            partIndex++;
            parts[partIndex] = this.parser.parse(attrValue.substring(interpolationStart + 2, i - 1));
            partIndex++;
          }
          pos = i;
          i = attrValue.indexOf('${', i);
        } else {
          break;
        }
      }
      if (partIndex === 0) {
        return null;
      }
      parts[partIndex] = attrValue.substr(pos);
      return new InterpolationBindingExpression(this.observerLocator, this.attributeMap[attrName] || attrName, parts, _aureliaBinding.bindingMode.oneWay, resources.lookupFunctions, attrName);
    };
    return TemplatingBindingLanguage;
  })(_aureliaTemplating.BindingLanguage);
  exports.TemplatingBindingLanguage = TemplatingBindingLanguage;
  function configure(config) {
    config.container.registerSingleton(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
    config.container.registerAlias(_aureliaTemplating.BindingLanguage, TemplatingBindingLanguage);
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-binding@1.0.0-beta.1.0.2", ["npm:aurelia-templating-binding@1.0.0-beta.1.0.2/aurelia-templating-binding"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/compose", ["exports", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-task-queue@1.0.0-beta.1.0.1", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaDependencyInjection, _aureliaTaskQueue, _aureliaTemplating, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  var _createDecoratedClass = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === 'function') {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        Object.defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _defineDecoratedPropertyDescriptor(target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor)
      return;
    var descriptor = {};
    for (var _key in _descriptor)
      descriptor[_key] = _descriptor[_key];
    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  }
  var Compose = (function() {
    var _instanceInitializers = {};
    _createDecoratedClass(Compose, [{
      key: 'model',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }, {
      key: 'view',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }, {
      key: 'viewModel',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }], null, _instanceInitializers);
    function Compose(element, container, compositionEngine, viewSlot, viewResources, taskQueue) {
      _classCallCheck(this, _Compose);
      _defineDecoratedPropertyDescriptor(this, 'model', _instanceInitializers);
      _defineDecoratedPropertyDescriptor(this, 'view', _instanceInitializers);
      _defineDecoratedPropertyDescriptor(this, 'viewModel', _instanceInitializers);
      this.element = element;
      this.container = container;
      this.compositionEngine = compositionEngine;
      this.viewSlot = viewSlot;
      this.viewResources = viewResources;
      this.taskQueue = taskQueue;
      this.currentController = null;
      this.currentViewModel = null;
    }
    Compose.prototype.created = function created(owningView) {
      this.owningView = owningView;
    };
    Compose.prototype.bind = function bind(bindingContext, overrideContext) {
      this.bindingContext = bindingContext;
      this.overrideContext = overrideContext;
      processInstruction(this, createInstruction(this, {
        view: this.view,
        viewModel: this.viewModel,
        model: this.model
      }));
    };
    Compose.prototype.unbind = function unbind(bindingContext, overrideContext) {
      this.bindingContext = null;
      this.overrideContext = null;
      var returnToCache = true;
      var skipAnimation = true;
      this.viewSlot.removeAll(returnToCache, skipAnimation);
    };
    Compose.prototype.modelChanged = function modelChanged(newValue, oldValue) {
      var _this = this;
      if (this.currentInstruction) {
        this.currentInstruction.model = newValue;
        return;
      }
      this.taskQueue.queueMicroTask(function() {
        if (_this.currentInstruction) {
          _this.currentInstruction.model = newValue;
          return;
        }
        var vm = _this.currentViewModel;
        if (vm && typeof vm.activate === 'function') {
          vm.activate(newValue);
        }
      });
    };
    Compose.prototype.viewChanged = function viewChanged(newValue, oldValue) {
      var _this2 = this;
      var instruction = createInstruction(this, {
        view: newValue,
        viewModel: this.currentViewModel || this.viewModel,
        model: this.model
      });
      if (this.currentInstruction) {
        this.currentInstruction = instruction;
        return;
      }
      this.currentInstruction = instruction;
      this.taskQueue.queueMicroTask(function() {
        return processInstruction(_this2, _this2.currentInstruction);
      });
    };
    Compose.prototype.viewModelChanged = function viewModelChanged(newValue, oldValue) {
      var _this3 = this;
      var instruction = createInstruction(this, {
        viewModel: newValue,
        view: this.view,
        model: this.model
      });
      if (this.currentInstruction) {
        this.currentInstruction = instruction;
        return;
      }
      this.currentInstruction = instruction;
      this.taskQueue.queueMicroTask(function() {
        return processInstruction(_this3, _this3.currentInstruction);
      });
    };
    var _Compose = Compose;
    Compose = _aureliaDependencyInjection.inject(_aureliaPal.DOM.Element, _aureliaDependencyInjection.Container, _aureliaTemplating.CompositionEngine, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaTaskQueue.TaskQueue)(Compose) || Compose;
    Compose = _aureliaTemplating.noView(Compose) || Compose;
    Compose = _aureliaTemplating.customElement('compose')(Compose) || Compose;
    return Compose;
  })();
  exports.Compose = Compose;
  function createInstruction(composer, instruction) {
    return Object.assign(instruction, {
      bindingContext: composer.bindingContext,
      overrideContext: composer.overrideContext,
      owningView: composer.owningView,
      container: composer.container,
      viewSlot: composer.viewSlot,
      viewResources: composer.viewResources,
      currentController: composer.currentController,
      host: composer.element
    });
  }
  function processInstruction(composer, instruction) {
    composer.currentInstruction = null;
    composer.compositionEngine.compose(instruction).then(function(controller) {
      composer.currentController = controller;
      composer.currentViewModel = controller ? controller.viewModel : null;
    });
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/if", ["exports", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-task-queue@1.0.0-beta.1.0.1"], function(exports, _aureliaTemplating, _aureliaDependencyInjection, _aureliaTaskQueue) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var If = (function() {
    function If(viewFactory, viewSlot, taskQueue) {
      _classCallCheck(this, _If);
      this.viewFactory = viewFactory;
      this.viewSlot = viewSlot;
      this.showing = false;
      this.taskQueue = taskQueue;
      this.view = null;
      this.bindingContext = null;
      this.overrideContext = null;
    }
    If.prototype.bind = function bind(bindingContext, overrideContext) {
      this.bindingContext = bindingContext;
      this.overrideContext = overrideContext;
      this.valueChanged(this.value);
    };
    If.prototype.valueChanged = function valueChanged(newValue) {
      var _this = this;
      if (!newValue) {
        if (this.view !== null && this.showing) {
          this.taskQueue.queueMicroTask(function() {
            var viewOrPromise = _this.viewSlot.remove(_this.view);
            if (viewOrPromise instanceof Promise) {
              viewOrPromise.then(function() {
                return _this.view.unbind();
              });
            } else {
              _this.view.unbind();
            }
          });
        }
        this.showing = false;
        return;
      }
      if (this.view === null) {
        this.view = this.viewFactory.create();
      }
      if (!this.view.isBound) {
        this.view.bind(this.bindingContext, this.overrideContext);
      }
      if (!this.showing) {
        this.showing = true;
        this.viewSlot.add(this.view);
      }
    };
    If.prototype.unbind = function unbind() {
      if (this.view === null) {
        return;
      }
      this.view.unbind();
      if (!this.viewFactory.isCaching) {
        return;
      }
      if (this.showing) {
        this.showing = false;
        this.viewSlot.remove(this.view, true, true);
      }
      this.view.returnToCache();
      this.view = null;
    };
    var _If = If;
    If = _aureliaDependencyInjection.inject(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot, _aureliaTaskQueue.TaskQueue)(If) || If;
    If = _aureliaTemplating.templateController(If) || If;
    If = _aureliaTemplating.customAttribute('if')(If) || If;
    return If;
  })();
  exports.If = If;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/with", ["exports", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _aureliaDependencyInjection, _aureliaTemplating, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var With = (function() {
    function With(viewFactory, viewSlot) {
      _classCallCheck(this, _With);
      this.viewFactory = viewFactory;
      this.viewSlot = viewSlot;
      this.parentOverrideContext = null;
      this.view = null;
    }
    With.prototype.bind = function bind(bindingContext, overrideContext) {
      this.parentOverrideContext = overrideContext;
      this.valueChanged(this.value);
    };
    With.prototype.valueChanged = function valueChanged(newValue) {
      var overrideContext = _aureliaBinding.createOverrideContext(newValue, this.parentOverrideContext);
      if (!this.view) {
        this.view = this.viewFactory.create();
        this.view.bind(newValue, overrideContext);
        this.viewSlot.add(this.view);
      } else {
        this.view.bind(newValue, overrideContext);
      }
    };
    With.prototype.unbind = function unbind() {
      this.parentOverrideContext = null;
      if (this.view) {
        this.view.unbind();
      }
    };
    var _With = With;
    With = _aureliaDependencyInjection.inject(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot)(With) || With;
    With = _aureliaTemplating.templateController(With) || With;
    With = _aureliaTemplating.customAttribute('with')(With) || With;
    return With;
  })();
  exports.With = With;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/null-repeat-strategy", ["exports"], function(exports) {
  "use strict";
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var NullRepeatStrategy = (function() {
    function NullRepeatStrategy() {
      _classCallCheck(this, NullRepeatStrategy);
    }
    NullRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      repeat.viewSlot.removeAll(true);
    };
    NullRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {};
    return NullRepeatStrategy;
  })();
  exports.NullRepeatStrategy = NullRepeatStrategy;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-utilities", ["exports", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  exports.updateOverrideContexts = updateOverrideContexts;
  exports.createFullOverrideContext = createFullOverrideContext;
  exports.updateOverrideContext = updateOverrideContext;
  exports.getItemsSourceExpression = getItemsSourceExpression;
  exports.unwrapExpression = unwrapExpression;
  exports.isOneTime = isOneTime;
  exports.updateOneTimeBinding = updateOneTimeBinding;
  var oneTime = _aureliaBinding.bindingMode.oneTime;
  function updateOverrideContexts(views, startIndex) {
    var length = views.length;
    if (startIndex > 0) {
      startIndex = startIndex - 1;
    }
    for (; startIndex < length; ++startIndex) {
      updateOverrideContext(views[startIndex].overrideContext, startIndex, length);
    }
  }
  function createFullOverrideContext(repeat, data, index, length, key) {
    var bindingContext = {};
    var overrideContext = _aureliaBinding.createOverrideContext(bindingContext, repeat.scope.overrideContext);
    if (typeof key !== 'undefined') {
      bindingContext[repeat.key] = key;
      bindingContext[repeat.value] = data;
    } else {
      bindingContext[repeat.local] = data;
    }
    updateOverrideContext(overrideContext, index, length);
    return overrideContext;
  }
  function updateOverrideContext(overrideContext, index, length) {
    var first = index === 0;
    var last = index === length - 1;
    var even = index % 2 === 0;
    overrideContext.$index = index;
    overrideContext.$first = first;
    overrideContext.$last = last;
    overrideContext.$middle = !(first || last);
    overrideContext.$odd = !even;
    overrideContext.$even = even;
  }
  function getItemsSourceExpression(instruction, attrName) {
    return instruction.behaviorInstructions.filter(function(bi) {
      return bi.originalAttrName === attrName;
    })[0].attributes.items.sourceExpression;
  }
  function unwrapExpression(expression) {
    var unwrapped = false;
    while (expression instanceof _aureliaBinding.BindingBehavior) {
      expression = expression.expression;
    }
    while (expression instanceof _aureliaBinding.ValueConverter) {
      expression = expression.expression;
      unwrapped = true;
    }
    return unwrapped ? expression : null;
  }
  function isOneTime(expression) {
    while (expression instanceof _aureliaBinding.BindingBehavior) {
      if (expression.name === 'oneTime') {
        return true;
      }
      expression = expression.expression;
    }
    return false;
  }
  function updateOneTimeBinding(binding) {
    if (binding.call && binding.mode === oneTime) {
      binding.call(_aureliaBinding.sourceContext);
    }
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/array-repeat-strategy", ["exports", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-utilities", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _repeatUtilities, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var ArrayRepeatStrategy = (function() {
    function ArrayRepeatStrategy() {
      _classCallCheck(this, ArrayRepeatStrategy);
    }
    ArrayRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
      return observerLocator.getArrayObserver(items);
    };
    ArrayRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      var _this = this;
      if (repeat.viewsRequireLifecycle) {
        var removePromise = repeat.viewSlot.removeAll(true);
        if (removePromise instanceof Promise) {
          removePromise.then(function() {
            return _this._standardProcessInstanceChanged(repeat, items);
          });
          return;
        }
        this._standardProcessInstanceChanged(repeat, items);
        return;
      }
      this._inPlaceProcessItems(repeat, items);
    };
    ArrayRepeatStrategy.prototype._standardProcessInstanceChanged = function _standardProcessInstanceChanged(repeat, items) {
      for (var i = 0,
          ii = items.length; i < ii; i++) {
        var overrideContext = _repeatUtilities.createFullOverrideContext(repeat, items[i], i, ii);
        var view = repeat.viewFactory.create();
        view.bind(overrideContext.bindingContext, overrideContext);
        repeat.viewSlot.add(view);
      }
    };
    ArrayRepeatStrategy.prototype._inPlaceProcessItems = function _inPlaceProcessItems(repeat, items) {
      var itemsLength = items.length;
      var viewsLength = repeat.viewSlot.children.length;
      while (viewsLength > itemsLength) {
        viewsLength--;
        repeat.viewSlot.removeAt(viewsLength, true);
      }
      var local = repeat.local;
      for (var i = 0; i < viewsLength; i++) {
        var view = repeat.viewSlot.children[i];
        var last = i === itemsLength - 1;
        var middle = i !== 0 && !last;
        if (view.bindingContext[local] === items[i] && view.overrideContext.$middle === middle && view.overrideContext.$last === last) {
          continue;
        }
        view.bindingContext[local] = items[i];
        view.overrideContext.$middle = middle;
        view.overrideContext.$last = last;
        var j = view.bindings.length;
        while (j--) {
          _repeatUtilities.updateOneTimeBinding(view.bindings[j]);
        }
        j = view.controllers.length;
        while (j--) {
          var k = view.controllers[j].boundProperties.length;
          while (k--) {
            var binding = view.controllers[j].boundProperties[k].binding;
            _repeatUtilities.updateOneTimeBinding(binding);
          }
        }
      }
      for (var i = viewsLength; i < itemsLength; i++) {
        var overrideContext = _repeatUtilities.createFullOverrideContext(repeat, items[i], i, itemsLength);
        var view = repeat.viewFactory.create();
        view.bind(overrideContext.bindingContext, overrideContext);
        repeat.viewSlot.add(view);
      }
    };
    ArrayRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, array, splices) {
      if (repeat.viewsRequireLifecycle) {
        this._standardProcessInstanceMutated(repeat, array, splices);
        return;
      }
      this._inPlaceProcessItems(repeat, array);
    };
    ArrayRepeatStrategy.prototype._standardProcessInstanceMutated = function _standardProcessInstanceMutated(repeat, array, splices) {
      var _this2 = this;
      if (repeat.__queuedSplices) {
        for (var i = 0,
            ii = splices.length; i < ii; ++i) {
          var _splices$i = splices[i];
          var index = _splices$i.index;
          var removed = _splices$i.removed;
          var addedCount = _splices$i.addedCount;
          _aureliaBinding.mergeSplice(repeat.__queuedSplices, index, removed, addedCount);
        }
        repeat.__array = array.slice(0);
        return;
      }
      var maybePromise = this._runSplices(repeat, array, splices);
      if (maybePromise instanceof Promise) {
        (function() {
          var queuedSplices = repeat.__queuedSplices = [];
          var runQueuedSplices = function runQueuedSplices() {
            if (!queuedSplices.length) {
              delete repeat.__queuedSplices;
              delete repeat.__array;
              return;
            }
            var nextPromise = _this2._runSplices(repeat, repeat.__array, queuedSplices) || Promise.resolve();
            queuedSplices = repeat.__queuedSplices = [];
            nextPromise.then(runQueuedSplices);
          };
          maybePromise.then(runQueuedSplices);
        })();
      }
    };
    ArrayRepeatStrategy.prototype._runSplices = function _runSplices(repeat, array, splices) {
      var _this3 = this;
      var removeDelta = 0;
      var viewSlot = repeat.viewSlot;
      var rmPromises = [];
      for (var i = 0,
          ii = splices.length; i < ii; ++i) {
        var splice = splices[i];
        var removed = splice.removed;
        for (var j = 0,
            jj = removed.length; j < jj; ++j) {
          var viewOrPromise = viewSlot.removeAt(splice.index + removeDelta + rmPromises.length, true);
          if (viewOrPromise instanceof Promise) {
            rmPromises.push(viewOrPromise);
          }
        }
        removeDelta -= splice.addedCount;
      }
      if (rmPromises.length > 0) {
        return Promise.all(rmPromises).then(function() {
          var spliceIndexLow = _this3._handleAddedSplices(repeat, array, splices);
          _repeatUtilities.updateOverrideContexts(repeat.viewSlot.children, spliceIndexLow);
        });
      }
      var spliceIndexLow = this._handleAddedSplices(repeat, array, splices);
      _repeatUtilities.updateOverrideContexts(repeat.viewSlot.children, spliceIndexLow);
    };
    ArrayRepeatStrategy.prototype._handleAddedSplices = function _handleAddedSplices(repeat, array, splices) {
      var spliceIndex = undefined;
      var spliceIndexLow = undefined;
      var arrayLength = array.length;
      for (var i = 0,
          ii = splices.length; i < ii; ++i) {
        var splice = splices[i];
        var addIndex = spliceIndex = splice.index;
        var end = splice.index + splice.addedCount;
        if (typeof spliceIndexLow === 'undefined' || spliceIndexLow === null || spliceIndexLow > splice.index) {
          spliceIndexLow = spliceIndex;
        }
        for (; addIndex < end; ++addIndex) {
          var overrideContext = _repeatUtilities.createFullOverrideContext(repeat, array[addIndex], addIndex, arrayLength);
          var view = repeat.viewFactory.create();
          view.bind(overrideContext.bindingContext, overrideContext);
          repeat.viewSlot.insert(addIndex, view);
        }
      }
      return spliceIndexLow;
    };
    return ArrayRepeatStrategy;
  })();
  exports.ArrayRepeatStrategy = ArrayRepeatStrategy;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/map-repeat-strategy", ["exports", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-utilities"], function(exports, _repeatUtilities) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var MapRepeatStrategy = (function() {
    function MapRepeatStrategy() {
      _classCallCheck(this, MapRepeatStrategy);
    }
    MapRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
      return observerLocator.getMapObserver(items);
    };
    MapRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      var _this = this;
      var removePromise = repeat.viewSlot.removeAll(true);
      if (removePromise instanceof Promise) {
        removePromise.then(function() {
          return _this._standardProcessItems(repeat, items);
        });
        return;
      }
      this._standardProcessItems(repeat, items);
    };
    MapRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
      var viewFactory = repeat.viewFactory;
      var viewSlot = repeat.viewSlot;
      var index = 0;
      var overrideContext = undefined;
      var view = undefined;
      items.forEach(function(value, key) {
        overrideContext = _repeatUtilities.createFullOverrideContext(repeat, value, index, items.size, key);
        view = viewFactory.create();
        view.bind(overrideContext.bindingContext, overrideContext);
        viewSlot.add(view);
        ++index;
      });
    };
    MapRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, map, records) {
      var viewSlot = repeat.viewSlot;
      var key = undefined;
      var i = undefined;
      var ii = undefined;
      var view = undefined;
      var overrideContext = undefined;
      var removeIndex = undefined;
      var record = undefined;
      var rmPromises = [];
      var viewOrPromise = undefined;
      for (i = 0, ii = records.length; i < ii; ++i) {
        record = records[i];
        key = record.key;
        switch (record.type) {
          case 'update':
            removeIndex = this._getViewIndexByKey(repeat, key);
            viewOrPromise = viewSlot.removeAt(removeIndex, true);
            if (viewOrPromise instanceof Promise) {
              rmPromises.push(viewOrPromise);
            }
            overrideContext = _repeatUtilities.createFullOverrideContext(repeat, map.get(key), removeIndex, map.size, key);
            view = repeat.viewFactory.create();
            view.bind(overrideContext.bindingContext, overrideContext);
            viewSlot.insert(removeIndex, view);
            break;
          case 'add':
            overrideContext = _repeatUtilities.createFullOverrideContext(repeat, map.get(key), map.size - 1, map.size, key);
            view = repeat.viewFactory.create();
            view.bind(overrideContext.bindingContext, overrideContext);
            viewSlot.insert(map.size - 1, view);
            break;
          case 'delete':
            if (record.oldValue === undefined) {
              return;
            }
            removeIndex = this._getViewIndexByKey(repeat, key);
            viewOrPromise = viewSlot.removeAt(removeIndex, true);
            if (viewOrPromise instanceof Promise) {
              rmPromises.push(viewOrPromise);
            }
            break;
          case 'clear':
            viewSlot.removeAll(true);
            break;
          default:
            continue;
        }
      }
      if (rmPromises.length > 0) {
        Promise.all(rmPromises).then(function() {
          _repeatUtilities.updateOverrideContexts(repeat.viewSlot.children, 0);
        });
      } else {
        _repeatUtilities.updateOverrideContexts(repeat.viewSlot.children, 0);
      }
    };
    MapRepeatStrategy.prototype._getViewIndexByKey = function _getViewIndexByKey(repeat, key) {
      var viewSlot = repeat.viewSlot;
      var i = undefined;
      var ii = undefined;
      var child = undefined;
      for (i = 0, ii = viewSlot.children.length; i < ii; ++i) {
        child = viewSlot.children[i];
        if (child.bindingContext[repeat.key] === key) {
          return i;
        }
      }
    };
    return MapRepeatStrategy;
  })();
  exports.MapRepeatStrategy = MapRepeatStrategy;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/set-repeat-strategy", ["exports", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-utilities"], function(exports, _repeatUtilities) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var SetRepeatStrategy = (function() {
    function SetRepeatStrategy() {
      _classCallCheck(this, SetRepeatStrategy);
    }
    SetRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver(observerLocator, items) {
      return observerLocator.getSetObserver(items);
    };
    SetRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, items) {
      var _this = this;
      var removePromise = repeat.viewSlot.removeAll(true);
      if (removePromise instanceof Promise) {
        removePromise.then(function() {
          return _this._standardProcessItems(repeat, items);
        });
        return;
      }
      this._standardProcessItems(repeat, items);
    };
    SetRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, items) {
      var viewFactory = repeat.viewFactory;
      var viewSlot = repeat.viewSlot;
      var index = 0;
      var overrideContext = undefined;
      var view = undefined;
      items.forEach(function(value) {
        overrideContext = _repeatUtilities.createFullOverrideContext(repeat, value, index, items.size);
        view = viewFactory.create();
        view.bind(overrideContext.bindingContext, overrideContext);
        viewSlot.add(view);
        ++index;
      });
    };
    SetRepeatStrategy.prototype.instanceMutated = function instanceMutated(repeat, set, records) {
      var viewSlot = repeat.viewSlot;
      var value = undefined;
      var i = undefined;
      var ii = undefined;
      var view = undefined;
      var overrideContext = undefined;
      var removeIndex = undefined;
      var record = undefined;
      var rmPromises = [];
      var viewOrPromise = undefined;
      for (i = 0, ii = records.length; i < ii; ++i) {
        record = records[i];
        value = record.value;
        switch (record.type) {
          case 'add':
            overrideContext = _repeatUtilities.createFullOverrideContext(repeat, value, set.size - 1, set.size);
            view = repeat.viewFactory.create();
            view.bind(overrideContext.bindingContext, overrideContext);
            viewSlot.insert(set.size - 1, view);
            break;
          case 'delete':
            removeIndex = this._getViewIndexByValue(repeat, value);
            viewOrPromise = viewSlot.removeAt(removeIndex, true);
            if (viewOrPromise instanceof Promise) {
              rmPromises.push(viewOrPromise);
            }
            break;
          case 'clear':
            viewSlot.removeAll(true);
            break;
          default:
            continue;
        }
      }
      if (rmPromises.length > 0) {
        Promise.all(rmPromises).then(function() {
          _repeatUtilities.updateOverrideContexts(repeat.viewSlot.children, 0);
        });
      } else {
        _repeatUtilities.updateOverrideContexts(repeat.viewSlot.children, 0);
      }
    };
    SetRepeatStrategy.prototype._getViewIndexByValue = function _getViewIndexByValue(repeat, value) {
      var viewSlot = repeat.viewSlot;
      var i = undefined;
      var ii = undefined;
      var child = undefined;
      for (i = 0, ii = viewSlot.children.length; i < ii; ++i) {
        child = viewSlot.children[i];
        if (child.bindingContext[repeat.local] === value) {
          return i;
        }
      }
    };
    return SetRepeatStrategy;
  })();
  exports.SetRepeatStrategy = SetRepeatStrategy;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/number-repeat-strategy", ["exports", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-utilities"], function(exports, _repeatUtilities) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var NumberRepeatStrategy = (function() {
    function NumberRepeatStrategy() {
      _classCallCheck(this, NumberRepeatStrategy);
    }
    NumberRepeatStrategy.prototype.getCollectionObserver = function getCollectionObserver() {
      return null;
    };
    NumberRepeatStrategy.prototype.instanceChanged = function instanceChanged(repeat, value) {
      var _this = this;
      var removePromise = repeat.viewSlot.removeAll(true);
      if (removePromise instanceof Promise) {
        removePromise.then(function() {
          return _this._standardProcessItems(repeat, value);
        });
        return;
      }
      this._standardProcessItems(repeat, value);
    };
    NumberRepeatStrategy.prototype._standardProcessItems = function _standardProcessItems(repeat, value) {
      var viewFactory = repeat.viewFactory;
      var viewSlot = repeat.viewSlot;
      var childrenLength = viewSlot.children.length;
      var i = undefined;
      var ii = undefined;
      var overrideContext = undefined;
      var view = undefined;
      var viewsToRemove = undefined;
      value = Math.floor(value);
      viewsToRemove = childrenLength - value;
      if (viewsToRemove > 0) {
        if (viewsToRemove > childrenLength) {
          viewsToRemove = childrenLength;
        }
        for (i = 0, ii = viewsToRemove; i < ii; ++i) {
          viewSlot.removeAt(childrenLength - (i + 1), true);
        }
        return;
      }
      for (i = childrenLength, ii = value; i < ii; ++i) {
        overrideContext = _repeatUtilities.createFullOverrideContext(repeat, i, i, ii);
        view = viewFactory.create();
        view.bind(overrideContext.bindingContext, overrideContext);
        viewSlot.add(view);
      }
      _repeatUtilities.updateOverrideContexts(repeat.viewSlot.children, 0);
    };
    return NumberRepeatStrategy;
  })();
  exports.NumberRepeatStrategy = NumberRepeatStrategy;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-strategy-locator", ["exports", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/null-repeat-strategy", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/array-repeat-strategy", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/map-repeat-strategy", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/set-repeat-strategy", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/number-repeat-strategy"], function(exports, _nullRepeatStrategy, _arrayRepeatStrategy, _mapRepeatStrategy, _setRepeatStrategy, _numberRepeatStrategy) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var RepeatStrategyLocator = (function() {
    function RepeatStrategyLocator() {
      _classCallCheck(this, RepeatStrategyLocator);
      this.matchers = [];
      this.strategies = [];
      this.addStrategy(function(items) {
        return items === null || items === undefined;
      }, new _nullRepeatStrategy.NullRepeatStrategy());
      this.addStrategy(function(items) {
        return items instanceof Array;
      }, new _arrayRepeatStrategy.ArrayRepeatStrategy());
      this.addStrategy(function(items) {
        return items instanceof Map;
      }, new _mapRepeatStrategy.MapRepeatStrategy());
      this.addStrategy(function(items) {
        return items instanceof Set;
      }, new _setRepeatStrategy.SetRepeatStrategy());
      this.addStrategy(function(items) {
        return typeof items === 'number';
      }, new _numberRepeatStrategy.NumberRepeatStrategy());
    }
    RepeatStrategyLocator.prototype.addStrategy = function addStrategy(matcher, strategy) {
      this.matchers.push(matcher);
      this.strategies.push(strategy);
    };
    RepeatStrategyLocator.prototype.getStrategy = function getStrategy(items) {
      var matchers = this.matchers;
      for (var i = 0,
          ii = matchers.length; i < ii; ++i) {
        if (matchers[i](items)) {
          return this.strategies[i];
        }
      }
      return null;
    };
    return RepeatStrategyLocator;
  })();
  exports.RepeatStrategyLocator = RepeatStrategyLocator;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/analyze-view-factory", ["exports"], function(exports) {
  'use strict';
  exports.__esModule = true;
  exports.viewsRequireLifecycle = viewsRequireLifecycle;
  var lifecycleOptionalBehaviors = ['focus', 'if', 'repeat', 'show', 'with'];
  exports.lifecycleOptionalBehaviors = lifecycleOptionalBehaviors;
  function behaviorRequiresLifecycle(instruction) {
    var t = instruction.type;
    var name = t.elementName !== null ? t.elementName : t.attributeName;
    if (lifecycleOptionalBehaviors.indexOf(name) === -1) {
      return t.handlesAttached || t.handlesBind || t.handlesCreated || t.handlesDetached || t.handlesUnbind;
    }
    return instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
  }
  function targetRequiresLifecycle(instruction) {
    var behaviors = instruction.behaviorInstructions;
    if (behaviors) {
      var i = behaviors.length;
      while (i--) {
        if (behaviorRequiresLifecycle(behaviors[i])) {
          return true;
        }
      }
    }
    return instruction.viewFactory && viewsRequireLifecycle(instruction.viewFactory);
  }
  function viewsRequireLifecycle(viewFactory) {
    if ('_viewsRequireLifecycle' in viewFactory) {
      return viewFactory._viewsRequireLifecycle;
    }
    if (viewFactory.viewFactory) {
      viewFactory._viewsRequireLifecycle = viewsRequireLifecycle(viewFactory.viewFactory);
      return viewFactory._viewsRequireLifecycle;
    }
    if (viewFactory.template.querySelector('.au-animate')) {
      viewFactory._viewsRequireLifecycle = true;
      return true;
    }
    for (var id in viewFactory.instructions) {
      if (targetRequiresLifecycle(viewFactory.instructions[id])) {
        viewFactory._viewsRequireLifecycle = true;
        return true;
      }
    }
    viewFactory._viewsRequireLifecycle = false;
    return false;
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat", ["exports", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-binding@1.0.0-beta.1.0.5", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-strategy-locator", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat-utilities", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/analyze-view-factory"], function(exports, _aureliaDependencyInjection, _aureliaBinding, _aureliaTemplating, _repeatStrategyLocator, _repeatUtilities, _analyzeViewFactory) {
  'use strict';
  exports.__esModule = true;
  var _createDecoratedClass = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === 'function') {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        Object.defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _defineDecoratedPropertyDescriptor(target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor)
      return;
    var descriptor = {};
    for (var _key in _descriptor)
      descriptor[_key] = _descriptor[_key];
    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  }
  var Repeat = (function() {
    var _instanceInitializers = {};
    _createDecoratedClass(Repeat, [{
      key: 'items',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }, {
      key: 'local',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }, {
      key: 'key',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }, {
      key: 'value',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }], null, _instanceInitializers);
    function Repeat(viewFactory, instruction, viewSlot, viewResources, observerLocator, strategyLocator) {
      _classCallCheck(this, _Repeat);
      _defineDecoratedPropertyDescriptor(this, 'items', _instanceInitializers);
      _defineDecoratedPropertyDescriptor(this, 'local', _instanceInitializers);
      _defineDecoratedPropertyDescriptor(this, 'key', _instanceInitializers);
      _defineDecoratedPropertyDescriptor(this, 'value', _instanceInitializers);
      this.viewFactory = viewFactory;
      this.instruction = instruction;
      this.viewSlot = viewSlot;
      this.lookupFunctions = viewResources.lookupFunctions;
      this.observerLocator = observerLocator;
      this.local = 'item';
      this.key = 'key';
      this.value = 'value';
      this.strategyLocator = strategyLocator;
      this.ignoreMutation = false;
      this.sourceExpression = _repeatUtilities.getItemsSourceExpression(this.instruction, 'repeat.for');
      this.isOneTime = _repeatUtilities.isOneTime(this.sourceExpression);
      this.viewsRequireLifecycle = _analyzeViewFactory.viewsRequireLifecycle(viewFactory);
    }
    Repeat.prototype.call = function call(context, changes) {
      this[context](this.items, changes);
    };
    Repeat.prototype.bind = function bind(bindingContext, overrideContext) {
      this.scope = {
        bindingContext: bindingContext,
        overrideContext: overrideContext
      };
      this.itemsChanged();
    };
    Repeat.prototype.unbind = function unbind() {
      this.scope = null;
      this.items = null;
      this.viewSlot.removeAll(true);
      this._unsubscribeCollection();
    };
    Repeat.prototype._unsubscribeCollection = function _unsubscribeCollection() {
      if (this.collectionObserver) {
        this.collectionObserver.unsubscribe(this.callContext, this);
        this.collectionObserver = null;
        this.callContext = null;
      }
    };
    Repeat.prototype.itemsChanged = function itemsChanged() {
      this._unsubscribeCollection();
      if (!this.scope) {
        return;
      }
      var items = this.items;
      this.strategy = this.strategyLocator.getStrategy(items);
      if (!this.isOneTime && !this._observeInnerCollection()) {
        this._observeCollection();
      }
      this.strategy.instanceChanged(this, items);
    };
    Repeat.prototype._getInnerCollection = function _getInnerCollection() {
      var expression = _repeatUtilities.unwrapExpression(this.sourceExpression);
      if (!expression) {
        return null;
      }
      return expression.evaluate(this.scope, null);
    };
    Repeat.prototype.handleCollectionMutated = function handleCollectionMutated(collection, changes) {
      this.strategy.instanceMutated(this, collection, changes);
    };
    Repeat.prototype.handleInnerCollectionMutated = function handleInnerCollectionMutated(collection, changes) {
      var _this = this;
      if (this.ignoreMutation) {
        return;
      }
      this.ignoreMutation = true;
      var newItems = this.sourceExpression.evaluate(this.scope, this.lookupFunctions);
      this.observerLocator.taskQueue.queueMicroTask(function() {
        return _this.ignoreMutation = false;
      });
      if (newItems === this.items) {
        this.itemsChanged();
      } else {
        this.items = newItems;
      }
    };
    Repeat.prototype._observeInnerCollection = function _observeInnerCollection() {
      var items = this._getInnerCollection();
      var strategy = this.strategyLocator.getStrategy(items);
      if (!strategy) {
        return false;
      }
      this.collectionObserver = strategy.getCollectionObserver(this.observerLocator, items);
      if (!this.collectionObserver) {
        return false;
      }
      this.callContext = 'handleInnerCollectionMutated';
      this.collectionObserver.subscribe(this.callContext, this);
      return true;
    };
    Repeat.prototype._observeCollection = function _observeCollection() {
      var items = this.items;
      this.collectionObserver = this.strategy.getCollectionObserver(this.observerLocator, items);
      if (this.collectionObserver) {
        this.callContext = 'handleCollectionMutated';
        this.collectionObserver.subscribe(this.callContext, this);
      }
    };
    var _Repeat = Repeat;
    Repeat = _aureliaDependencyInjection.inject(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.TargetInstruction, _aureliaTemplating.ViewSlot, _aureliaTemplating.ViewResources, _aureliaBinding.ObserverLocator, _repeatStrategyLocator.RepeatStrategyLocator)(Repeat) || Repeat;
    Repeat = _aureliaTemplating.templateController(Repeat) || Repeat;
    Repeat = _aureliaTemplating.customAttribute('repeat')(Repeat) || Repeat;
    return Repeat;
  })();
  exports.Repeat = Repeat;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/show", ["exports", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaDependencyInjection, _aureliaTemplating, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var Show = (function() {
    function Show(element, animator) {
      _classCallCheck(this, _Show);
      this.element = element;
      this.animator = animator;
    }
    Show.prototype.valueChanged = function valueChanged(newValue) {
      if (newValue) {
        this.animator.removeClass(this.element, 'aurelia-hide');
      } else {
        this.animator.addClass(this.element, 'aurelia-hide');
      }
    };
    Show.prototype.bind = function bind(bindingContext) {
      this.valueChanged(this.value);
    };
    var _Show = Show;
    Show = _aureliaDependencyInjection.inject(_aureliaPal.DOM.Element, _aureliaTemplating.Animator)(Show) || Show;
    Show = _aureliaTemplating.customAttribute('show')(Show) || Show;
    return Show;
  })();
  exports.Show = Show;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/html-sanitizer", ["exports"], function(exports) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var SCRIPT_REGEX = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi;
  var HTMLSanitizer = (function() {
    function HTMLSanitizer() {
      _classCallCheck(this, HTMLSanitizer);
    }
    HTMLSanitizer.prototype.sanitize = function sanitize(input) {
      return input.replace(SCRIPT_REGEX, '');
    };
    return HTMLSanitizer;
  })();
  exports.HTMLSanitizer = HTMLSanitizer;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/sanitize-html", ["exports", "npm:aurelia-binding@1.0.0-beta.1.0.5", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/html-sanitizer"], function(exports, _aureliaBinding, _aureliaDependencyInjection, _htmlSanitizer) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var SanitizeHTMLValueConverter = (function() {
    function SanitizeHTMLValueConverter(sanitizer) {
      _classCallCheck(this, _SanitizeHTMLValueConverter);
      this.sanitizer = sanitizer;
    }
    SanitizeHTMLValueConverter.prototype.toView = function toView(untrustedMarkup) {
      if (untrustedMarkup === null || untrustedMarkup === undefined) {
        return null;
      }
      return this.sanitizer.sanitize(untrustedMarkup);
    };
    var _SanitizeHTMLValueConverter = SanitizeHTMLValueConverter;
    SanitizeHTMLValueConverter = _aureliaDependencyInjection.inject(_htmlSanitizer.HTMLSanitizer)(SanitizeHTMLValueConverter) || SanitizeHTMLValueConverter;
    SanitizeHTMLValueConverter = _aureliaBinding.valueConverter('sanitizeHTML')(SanitizeHTMLValueConverter) || SanitizeHTMLValueConverter;
    return SanitizeHTMLValueConverter;
  })();
  exports.SanitizeHTMLValueConverter = SanitizeHTMLValueConverter;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/replaceable", ["exports", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-templating@1.0.0-beta.1.0.3"], function(exports, _aureliaDependencyInjection, _aureliaTemplating) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var Replaceable = (function() {
    function Replaceable(viewFactory, viewSlot) {
      _classCallCheck(this, _Replaceable);
      this.viewFactory = viewFactory;
      this.viewSlot = viewSlot;
      this.view = null;
    }
    Replaceable.prototype.bind = function bind(bindingContext, overrideContext) {
      if (this.view === null) {
        this.view = this.viewFactory.create();
        this.viewSlot.add(this.view);
      }
      this.view.bind(bindingContext, overrideContext);
    };
    Replaceable.prototype.unbind = function unbind() {
      this.view.unbind();
    };
    var _Replaceable = Replaceable;
    Replaceable = _aureliaDependencyInjection.inject(_aureliaTemplating.BoundViewFactory, _aureliaTemplating.ViewSlot)(Replaceable) || Replaceable;
    Replaceable = _aureliaTemplating.templateController(Replaceable) || Replaceable;
    Replaceable = _aureliaTemplating.customAttribute('replaceable')(Replaceable) || Replaceable;
    return Replaceable;
  })();
  exports.Replaceable = Replaceable;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/focus", ["exports", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-binding@1.0.0-beta.1.0.5", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-task-queue@1.0.0-beta.1.0.1", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaTemplating, _aureliaBinding, _aureliaDependencyInjection, _aureliaTaskQueue, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var Focus = (function() {
    function Focus(element, taskQueue) {
      var _this = this;
      _classCallCheck(this, _Focus);
      this.element = element;
      this.taskQueue = taskQueue;
      this.focusListener = function(e) {
        _this.value = true;
      };
      this.blurListener = function(e) {
        if (_aureliaPal.DOM.activeElement !== _this.element) {
          _this.value = false;
        }
      };
    }
    Focus.prototype.valueChanged = function valueChanged(newValue) {
      if (newValue) {
        this._giveFocus();
      } else {
        this.element.blur();
      }
    };
    Focus.prototype._giveFocus = function _giveFocus() {
      var _this2 = this;
      this.taskQueue.queueMicroTask(function() {
        if (_this2.value) {
          _this2.element.focus();
        }
      });
    };
    Focus.prototype.attached = function attached() {
      this.element.addEventListener('focus', this.focusListener);
      this.element.addEventListener('blur', this.blurListener);
    };
    Focus.prototype.detached = function detached() {
      this.element.removeEventListener('focus', this.focusListener);
      this.element.removeEventListener('blur', this.blurListener);
    };
    var _Focus = Focus;
    Focus = _aureliaDependencyInjection.inject(_aureliaPal.DOM.Element, _aureliaTaskQueue.TaskQueue)(Focus) || Focus;
    Focus = _aureliaTemplating.customAttribute('focus', _aureliaBinding.bindingMode.twoWay)(Focus) || Focus;
    return Focus;
  })();
  exports.Focus = Focus;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/compile-spy", ["exports", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-logging@1.0.0-beta.1.1.1", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaTemplating, _aureliaDependencyInjection, _aureliaLogging, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var CompileSpy = (function() {
    function CompileSpy(element, instruction) {
      _classCallCheck(this, _CompileSpy);
      _aureliaLogging.getLogger('compile-spy').info(element, instruction);
    }
    var _CompileSpy = CompileSpy;
    CompileSpy = _aureliaDependencyInjection.inject(_aureliaPal.DOM.Element, _aureliaTemplating.TargetInstruction)(CompileSpy) || CompileSpy;
    CompileSpy = _aureliaTemplating.customAttribute('compile-spy')(CompileSpy) || CompileSpy;
    return CompileSpy;
  })();
  exports.CompileSpy = CompileSpy;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/view-spy", ["exports", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-logging@1.0.0-beta.1.1.1"], function(exports, _aureliaTemplating, _aureliaLogging) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var ViewSpy = (function() {
    function ViewSpy() {
      _classCallCheck(this, _ViewSpy);
      this.logger = _aureliaLogging.getLogger('view-spy');
    }
    ViewSpy.prototype._log = function _log(lifecycleName, context) {
      if (!this.value && lifecycleName === 'created') {
        this.logger.info(lifecycleName, this.view);
      } else if (this.value && this.value.indexOf(lifecycleName) !== -1) {
        this.logger.info(lifecycleName, this.view, context);
      }
    };
    ViewSpy.prototype.created = function created(view) {
      this.view = view;
      this._log('created');
    };
    ViewSpy.prototype.bind = function bind(bindingContext) {
      this._log('bind', bindingContext);
    };
    ViewSpy.prototype.attached = function attached() {
      this._log('attached');
    };
    ViewSpy.prototype.detached = function detached() {
      this._log('detached');
    };
    ViewSpy.prototype.unbind = function unbind() {
      this._log('unbind');
    };
    var _ViewSpy = ViewSpy;
    ViewSpy = _aureliaTemplating.customAttribute('view-spy')(ViewSpy) || ViewSpy;
    return ViewSpy;
  })();
  exports.ViewSpy = ViewSpy;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/dynamic-element", ["exports", "npm:aurelia-templating@1.0.0-beta.1.0.3"], function(exports, _aureliaTemplating) {
  'use strict';
  exports.__esModule = true;
  exports._createDynamicElement = _createDynamicElement;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _createDynamicElement(name, viewUrl, bindableNames) {
    var DynamicElement = (function() {
      function DynamicElement() {
        _classCallCheck(this, _DynamicElement);
      }
      DynamicElement.prototype.bind = function bind(bindingContext) {
        this.$parent = bindingContext;
      };
      var _DynamicElement = DynamicElement;
      DynamicElement = _aureliaTemplating.useView(viewUrl)(DynamicElement) || DynamicElement;
      DynamicElement = _aureliaTemplating.customElement(name)(DynamicElement) || DynamicElement;
      return DynamicElement;
    })();
    for (var i = 0,
        ii = bindableNames.length; i < ii; ++i) {
      _aureliaTemplating.bindable(bindableNames[i])(DynamicElement);
    }
    return DynamicElement;
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/css-resource", ["exports", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-loader@1.0.0-beta.1.0.1", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-path@1.0.0-beta.1", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaTemplating, _aureliaLoader, _aureliaDependencyInjection, _aureliaPath, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  exports._createCSSResource = _createCSSResource;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var cssUrlMatcher = /url\((?!['"]data)([^)]+)\)/gi;
  function fixupCSSUrls(address, css) {
    return css.replace(cssUrlMatcher, function(match, p1) {
      var quote = p1.charAt(0);
      if (quote === '\'' || quote === '"') {
        p1 = p1.substr(1, p1.length - 2);
      }
      return 'url(\'' + _aureliaPath.relativeToFile(p1, address) + '\')';
    });
  }
  var CSSResource = (function() {
    function CSSResource(address) {
      _classCallCheck(this, CSSResource);
      this.address = address;
      this._global = null;
      this._scoped = null;
    }
    CSSResource.prototype.initialize = function initialize(container, target) {
      this._global = new target('global');
      this._scoped = new target('scoped');
    };
    CSSResource.prototype.register = function register(registry, name) {
      registry.registerViewEngineHooks(name === 'scoped' ? this._scoped : this._global);
    };
    CSSResource.prototype.load = function load(container) {
      var _this = this;
      return container.get(_aureliaLoader.Loader).loadText(this.address).then(function(text) {
        text = fixupCSSUrls(_this.address, text);
        _this._global.css = text;
        _this._scoped.css = text;
      });
    };
    return CSSResource;
  })();
  var CSSViewEngineHooks = (function() {
    function CSSViewEngineHooks(mode) {
      _classCallCheck(this, CSSViewEngineHooks);
      this.mode = mode;
      this.css = null;
      this._alreadyGloballyInjected = false;
    }
    CSSViewEngineHooks.prototype.beforeCompile = function beforeCompile(content, resources, instruction) {
      if (this.mode === 'scoped') {
        if (instruction.targetShadowDOM) {
          _aureliaPal.DOM.injectStyles(this.css, content, true);
        } else if (_aureliaPal.FEATURE.scopedCSS) {
          var styleNode = _aureliaPal.DOM.injectStyles(this.css, content, true);
          styleNode.setAttribute('scoped', 'scoped');
        } else if (!this._alreadyGloballyInjected) {
          _aureliaPal.DOM.injectStyles(this.css);
          this._alreadyGloballyInjected = true;
        }
      } else if (!this._alreadyGloballyInjected) {
        _aureliaPal.DOM.injectStyles(this.css);
        this._alreadyGloballyInjected = true;
      }
    };
    return CSSViewEngineHooks;
  })();
  function _createCSSResource(address) {
    var ViewCSS = (function(_CSSViewEngineHooks) {
      _inherits(ViewCSS, _CSSViewEngineHooks);
      function ViewCSS() {
        _classCallCheck(this, _ViewCSS);
        _CSSViewEngineHooks.apply(this, arguments);
      }
      var _ViewCSS = ViewCSS;
      ViewCSS = _aureliaTemplating.resource(new CSSResource(address))(ViewCSS) || ViewCSS;
      return ViewCSS;
    })(CSSViewEngineHooks);
    return ViewCSS;
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/binding-mode-behaviors", ["exports", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var ModeBindingBehavior = (function() {
    function ModeBindingBehavior(mode) {
      _classCallCheck(this, ModeBindingBehavior);
      this.mode = mode;
    }
    ModeBindingBehavior.prototype.bind = function bind(binding, source, lookupFunctions) {
      binding.originalMode = binding.mode;
      binding.mode = this.mode;
    };
    ModeBindingBehavior.prototype.unbind = function unbind(binding, source) {
      binding.mode = binding.originalMode;
      binding.originalMode = null;
    };
    return ModeBindingBehavior;
  })();
  var OneTimeBindingBehavior = (function(_ModeBindingBehavior) {
    _inherits(OneTimeBindingBehavior, _ModeBindingBehavior);
    function OneTimeBindingBehavior() {
      _classCallCheck(this, OneTimeBindingBehavior);
      _ModeBindingBehavior.call(this, _aureliaBinding.bindingMode.oneTime);
    }
    return OneTimeBindingBehavior;
  })(ModeBindingBehavior);
  exports.OneTimeBindingBehavior = OneTimeBindingBehavior;
  var OneWayBindingBehavior = (function(_ModeBindingBehavior2) {
    _inherits(OneWayBindingBehavior, _ModeBindingBehavior2);
    function OneWayBindingBehavior() {
      _classCallCheck(this, OneWayBindingBehavior);
      _ModeBindingBehavior2.call(this, _aureliaBinding.bindingMode.oneWay);
    }
    return OneWayBindingBehavior;
  })(ModeBindingBehavior);
  exports.OneWayBindingBehavior = OneWayBindingBehavior;
  var TwoWayBindingBehavior = (function(_ModeBindingBehavior3) {
    _inherits(TwoWayBindingBehavior, _ModeBindingBehavior3);
    function TwoWayBindingBehavior() {
      _classCallCheck(this, TwoWayBindingBehavior);
      _ModeBindingBehavior3.call(this, _aureliaBinding.bindingMode.twoWay);
    }
    return TwoWayBindingBehavior;
  })(ModeBindingBehavior);
  exports.TwoWayBindingBehavior = TwoWayBindingBehavior;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/throttle-binding-behavior", ["exports", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function throttle(newValue) {
    var _this = this;
    var state = this.throttleState;
    var elapsed = +new Date() - state.last;
    if (elapsed >= state.delay) {
      clearTimeout(state.timeoutId);
      state.timeoutId = null;
      state.last = +new Date();
      this.throttledMethod(newValue);
      return;
    }
    state.newValue = newValue;
    if (state.timeoutId === null) {
      state.timeoutId = setTimeout(function() {
        state.timeoutId = null;
        state.last = +new Date();
        _this.throttledMethod(state.newValue);
      }, state.delay - elapsed);
    }
  }
  var ThrottleBindingBehavior = (function() {
    function ThrottleBindingBehavior() {
      _classCallCheck(this, ThrottleBindingBehavior);
    }
    ThrottleBindingBehavior.prototype.bind = function bind(binding, source) {
      var delay = arguments.length <= 2 || arguments[2] === undefined ? 200 : arguments[2];
      var methodToThrottle = 'updateTarget';
      if (binding.callSource) {
        methodToThrottle = 'callSource';
      } else if (binding.updateSource && binding.mode === _aureliaBinding.bindingMode.twoWay) {
        methodToThrottle = 'updateSource';
      }
      binding.throttledMethod = binding[methodToThrottle];
      binding.throttledMethod.originalName = methodToThrottle;
      binding[methodToThrottle] = throttle;
      binding.throttleState = {
        delay: delay,
        last: 0,
        timeoutId: null
      };
    };
    ThrottleBindingBehavior.prototype.unbind = function unbind(binding, source) {
      var methodToRestore = binding.throttledMethod.originalName;
      binding[methodToRestore] = binding.throttledMethod;
      binding.throttledMethod = null;
      clearTimeout(binding.throttleState.timeoutId);
      binding.throttleState = null;
    };
    return ThrottleBindingBehavior;
  })();
  exports.ThrottleBindingBehavior = ThrottleBindingBehavior;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/debounce-binding-behavior", ["exports", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function debounce(newValue) {
    var _this = this;
    var state = this.debounceState;
    if (state.immediate) {
      state.immediate = false;
      this.debouncedMethod(newValue);
      return;
    }
    clearTimeout(state.timeoutId);
    state.timeoutId = setTimeout(function() {
      return _this.debouncedMethod(newValue);
    }, state.delay);
  }
  var DebounceBindingBehavior = (function() {
    function DebounceBindingBehavior() {
      _classCallCheck(this, DebounceBindingBehavior);
    }
    DebounceBindingBehavior.prototype.bind = function bind(binding, source) {
      var delay = arguments.length <= 2 || arguments[2] === undefined ? 200 : arguments[2];
      var methodToDebounce = 'updateTarget';
      if (binding.callSource) {
        methodToDebounce = 'callSource';
      } else if (binding.updateSource && binding.mode === _aureliaBinding.bindingMode.twoWay) {
        methodToDebounce = 'updateSource';
      }
      binding.debouncedMethod = binding[methodToDebounce];
      binding.debouncedMethod.originalName = methodToDebounce;
      binding[methodToDebounce] = debounce;
      binding.debounceState = {
        delay: delay,
        timeoutId: null,
        immediate: methodToDebounce === 'updateTarget'
      };
    };
    DebounceBindingBehavior.prototype.unbind = function unbind(binding, source) {
      var methodToRestore = binding.debouncedMethod.originalName;
      binding[methodToRestore] = binding.debouncedMethod;
      binding.debouncedMethod = null;
      clearTimeout(binding.debounceState.timeoutId);
      binding.debounceState = null;
    };
    return DebounceBindingBehavior;
  })();
  exports.DebounceBindingBehavior = DebounceBindingBehavior;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/binding-signaler", ["exports", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var BindingSignaler = (function() {
    function BindingSignaler() {
      _classCallCheck(this, BindingSignaler);
      this.signals = {};
    }
    BindingSignaler.prototype.signal = function signal(name) {
      var bindings = this.signals[name];
      if (!bindings) {
        return;
      }
      var i = bindings.length;
      while (i--) {
        bindings[i].call(_aureliaBinding.sourceContext);
      }
    };
    return BindingSignaler;
  })();
  exports.BindingSignaler = BindingSignaler;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/signal-binding-behavior", ["exports", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/binding-signaler"], function(exports, _bindingSignaler) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var SignalBindingBehavior = (function() {
    SignalBindingBehavior.inject = function inject() {
      return [_bindingSignaler.BindingSignaler];
    };
    function SignalBindingBehavior(bindingSignaler) {
      _classCallCheck(this, SignalBindingBehavior);
      this.signals = bindingSignaler.signals;
    }
    SignalBindingBehavior.prototype.bind = function bind(binding, source, name) {
      if (!binding.updateTarget) {
        throw new Error('Only property bindings and string interpolation bindings can be signaled.  Trigger, delegate and call bindings cannot be signaled.');
      }
      var bindings = this.signals[name] || (this.signals[name] = []);
      bindings.push(binding);
      binding.signalName = name;
    };
    SignalBindingBehavior.prototype.unbind = function unbind(binding, source) {
      var name = binding.signalName;
      binding.signalName = null;
      var bindings = this.signals[name];
      bindings.splice(bindings.indexOf(binding), 1);
    };
    return SignalBindingBehavior;
  })();
  exports.SignalBindingBehavior = SignalBindingBehavior;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/update-trigger-binding-behavior", ["exports", "npm:aurelia-binding@1.0.0-beta.1.0.5"], function(exports, _aureliaBinding) {
  'use strict';
  exports.__esModule = true;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var eventNamesRequired = 'The updateTrigger binding behavior requires at least one event name argument: eg <input value.bind="firstName & updateTrigger:\'blur\'">';
  var notApplicableMessage = 'The updateTrigger binding behavior can only be applied to two-way bindings on input/select elements.';
  var UpdateTriggerBindingBehavior = (function() {
    _createClass(UpdateTriggerBindingBehavior, null, [{
      key: 'inject',
      value: [_aureliaBinding.EventManager],
      enumerable: true
    }]);
    function UpdateTriggerBindingBehavior(eventManager) {
      _classCallCheck(this, UpdateTriggerBindingBehavior);
      this.eventManager = eventManager;
    }
    UpdateTriggerBindingBehavior.prototype.bind = function bind(binding, source) {
      for (var _len = arguments.length,
          events = Array(_len > 2 ? _len - 2 : 0),
          _key = 2; _key < _len; _key++) {
        events[_key - 2] = arguments[_key];
      }
      if (events.length === 0) {
        throw new Error(eventNamesRequired);
      }
      if (binding.mode !== _aureliaBinding.bindingMode.twoWay) {
        throw new Error(notApplicableMessage);
      }
      var targetObserver = binding.observerLocator.getObserver(binding.target, binding.targetProperty);
      if (!targetObserver.handler) {
        throw new Error(notApplicableMessage);
      }
      binding.targetObserver = targetObserver;
      targetObserver.originalHandler = binding.targetObserver.handler;
      var handler = this.eventManager.createElementHandler(events);
      targetObserver.handler = handler;
    };
    UpdateTriggerBindingBehavior.prototype.unbind = function unbind(binding, source) {
      binding.targetObserver.handler = binding.targetObserver.originalHandler;
      binding.targetObserver.originalHandler = null;
    };
    return UpdateTriggerBindingBehavior;
  })();
  exports.UpdateTriggerBindingBehavior = UpdateTriggerBindingBehavior;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4/aurelia-templating-resources", ["exports", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/compose", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/if", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/with", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/repeat", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/show", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/sanitize-html", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/replaceable", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/focus", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/compile-spy", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/view-spy", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/dynamic-element", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/css-resource", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/html-sanitizer", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/binding-mode-behaviors", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/throttle-binding-behavior", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/debounce-binding-behavior", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/signal-binding-behavior", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/binding-signaler", "npm:aurelia-templating-resources@1.0.0-beta.1.0.4/update-trigger-binding-behavior"], function(exports, _compose, _if, _with, _repeat, _show, _sanitizeHtml, _replaceable, _focus, _compileSpy, _viewSpy, _aureliaTemplating, _dynamicElement, _cssResource, _aureliaPal, _htmlSanitizer, _bindingModeBehaviors, _throttleBindingBehavior, _debounceBindingBehavior, _signalBindingBehavior, _bindingSignaler, _updateTriggerBindingBehavior) {
  'use strict';
  exports.__esModule = true;
  function configure(config) {
    if (_aureliaPal.FEATURE.shadowDOM) {
      _aureliaPal.DOM.injectStyles('body /deep/ .aurelia-hide { display:none !important; }');
    } else {
      _aureliaPal.DOM.injectStyles('.aurelia-hide { display:none !important; }');
    }
    config.globalResources('./compose', './if', './with', './repeat', './show', './replaceable', './sanitize-html', './focus', './compile-spy', './view-spy', './binding-mode-behaviors', './throttle-binding-behavior', './debounce-binding-behavior', './signal-binding-behavior', './update-trigger-binding-behavior');
    var viewEngine = config.container.get(_aureliaTemplating.ViewEngine);
    var loader = config.aurelia.loader;
    viewEngine.addResourcePlugin('.html', {'fetch': function fetch(address) {
        return loader.loadTemplate(address).then(function(registryEntry) {
          var _ref;
          var bindable = registryEntry.template.getAttribute('bindable');
          var elementName = address.replace('.html', '');
          var index = elementName.lastIndexOf('/');
          if (index !== 0) {
            elementName = elementName.substring(index + 1);
          }
          if (bindable) {
            bindable = bindable.split(',').map(function(x) {
              return x.trim();
            });
            registryEntry.template.removeAttribute('bindable');
          } else {
            bindable = [];
          }
          return _ref = {}, _ref[elementName] = _dynamicElement._createDynamicElement(elementName, address, bindable), _ref;
        });
      }});
    viewEngine.addResourcePlugin('.css', {'fetch': function fetch(address) {
        var _ref2;
        return _ref2 = {}, _ref2[address] = _cssResource._createCSSResource(address), _ref2;
      }});
  }
  exports.Compose = _compose.Compose;
  exports.If = _if.If;
  exports.With = _with.With;
  exports.Repeat = _repeat.Repeat;
  exports.Show = _show.Show;
  exports.HTMLSanitizer = _htmlSanitizer.HTMLSanitizer;
  exports.SanitizeHTMLValueConverter = _sanitizeHtml.SanitizeHTMLValueConverter;
  exports.Replaceable = _replaceable.Replaceable;
  exports.Focus = _focus.Focus;
  exports.CompileSpy = _compileSpy.CompileSpy;
  exports.ViewSpy = _viewSpy.ViewSpy;
  exports.configure = configure;
  exports.OneTimeBindingBehavior = _bindingModeBehaviors.OneTimeBindingBehavior;
  exports.OneWayBindingBehavior = _bindingModeBehaviors.OneWayBindingBehavior;
  exports.TwoWayBindingBehavior = _bindingModeBehaviors.TwoWayBindingBehavior;
  exports.ThrottleBindingBehavior = _throttleBindingBehavior.ThrottleBindingBehavior;
  exports.DebounceBindingBehavior = _debounceBindingBehavior.DebounceBindingBehavior;
  exports.SignalBindingBehavior = _signalBindingBehavior.SignalBindingBehavior;
  exports.BindingSignaler = _bindingSignaler.BindingSignaler;
  exports.UpdateTriggerBindingBehavior = _updateTriggerBindingBehavior.UpdateTriggerBindingBehavior;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-resources@1.0.0-beta.1.0.4", ["npm:aurelia-templating-resources@1.0.0-beta.1.0.4/aurelia-templating-resources"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-route-recognizer@1.0.0-beta.1/aurelia-route-recognizer", ["exports", "npm:core-js@1.2.6", "npm:aurelia-path@1.0.0-beta.1"], function(exports, _coreJs, _aureliaPath) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var State = (function() {
    function State(charSpec) {
      _classCallCheck(this, State);
      this.charSpec = charSpec;
      this.nextStates = [];
    }
    State.prototype.get = function get(charSpec) {
      for (var _iterator = this.nextStates,
          _isArray = Array.isArray(_iterator),
          _i = 0,
          _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var child = _ref;
        var isEqual = child.charSpec.validChars === charSpec.validChars && child.charSpec.invalidChars === charSpec.invalidChars;
        if (isEqual) {
          return child;
        }
      }
    };
    State.prototype.put = function put(charSpec) {
      var state = this.get(charSpec);
      if (state) {
        return state;
      }
      state = new State(charSpec);
      this.nextStates.push(state);
      if (charSpec.repeat) {
        state.nextStates.push(state);
      }
      return state;
    };
    State.prototype.match = function match(ch) {
      var nextStates = this.nextStates;
      var results = [];
      for (var i = 0,
          l = nextStates.length; i < l; i++) {
        var child = nextStates[i];
        var charSpec = child.charSpec;
        if (charSpec.validChars !== undefined) {
          if (charSpec.validChars.indexOf(ch) !== -1) {
            results.push(child);
          }
        } else if (charSpec.invalidChars !== undefined) {
          if (charSpec.invalidChars.indexOf(ch) === -1) {
            results.push(child);
          }
        }
      }
      return results;
    };
    return State;
  })();
  exports.State = State;
  var specials = ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\'];
  var escapeRegex = new RegExp('(\\' + specials.join('|\\') + ')', 'g');
  var StaticSegment = (function() {
    function StaticSegment(string) {
      _classCallCheck(this, StaticSegment);
      this.string = string;
    }
    StaticSegment.prototype.eachChar = function eachChar(callback) {
      for (var _iterator2 = this.string,
          _isArray2 = Array.isArray(_iterator2),
          _i2 = 0,
          _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
        var _ref2;
        if (_isArray2) {
          if (_i2 >= _iterator2.length)
            break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done)
            break;
          _ref2 = _i2.value;
        }
        var ch = _ref2;
        callback({validChars: ch});
      }
    };
    StaticSegment.prototype.regex = function regex() {
      return this.string.replace(escapeRegex, '\\$1');
    };
    StaticSegment.prototype.generate = function generate() {
      return this.string;
    };
    return StaticSegment;
  })();
  exports.StaticSegment = StaticSegment;
  var DynamicSegment = (function() {
    function DynamicSegment(name) {
      _classCallCheck(this, DynamicSegment);
      this.name = name;
    }
    DynamicSegment.prototype.eachChar = function eachChar(callback) {
      callback({
        invalidChars: '/',
        repeat: true
      });
    };
    DynamicSegment.prototype.regex = function regex() {
      return '([^/]+)';
    };
    DynamicSegment.prototype.generate = function generate(params, consumed) {
      consumed[this.name] = true;
      return params[this.name];
    };
    return DynamicSegment;
  })();
  exports.DynamicSegment = DynamicSegment;
  var StarSegment = (function() {
    function StarSegment(name) {
      _classCallCheck(this, StarSegment);
      this.name = name;
    }
    StarSegment.prototype.eachChar = function eachChar(callback) {
      callback({
        invalidChars: '',
        repeat: true
      });
    };
    StarSegment.prototype.regex = function regex() {
      return '(.+)';
    };
    StarSegment.prototype.generate = function generate(params, consumed) {
      consumed[this.name] = true;
      return params[this.name];
    };
    return StarSegment;
  })();
  exports.StarSegment = StarSegment;
  var EpsilonSegment = (function() {
    function EpsilonSegment() {
      _classCallCheck(this, EpsilonSegment);
    }
    EpsilonSegment.prototype.eachChar = function eachChar() {};
    EpsilonSegment.prototype.regex = function regex() {
      return '';
    };
    EpsilonSegment.prototype.generate = function generate() {
      return '';
    };
    return EpsilonSegment;
  })();
  exports.EpsilonSegment = EpsilonSegment;
  var RouteRecognizer = (function() {
    function RouteRecognizer() {
      _classCallCheck(this, RouteRecognizer);
      this.rootState = new State();
      this.names = {};
    }
    RouteRecognizer.prototype.add = function add(route) {
      var _this = this;
      if (Array.isArray(route)) {
        route.forEach(function(r) {
          return _this.add(r);
        });
        return undefined;
      }
      var currentState = this.rootState;
      var regex = '^';
      var types = {
        statics: 0,
        dynamics: 0,
        stars: 0
      };
      var names = [];
      var routeName = route.handler.name;
      var isEmpty = true;
      var segments = parse(route.path, names, types);
      for (var i = 0,
          ii = segments.length; i < ii; i++) {
        var segment = segments[i];
        if (segment instanceof EpsilonSegment) {
          continue;
        }
        isEmpty = false;
        currentState = currentState.put({validChars: '/'});
        regex += '/';
        currentState = addSegment(currentState, segment);
        regex += segment.regex();
      }
      if (isEmpty) {
        currentState = currentState.put({validChars: '/'});
        regex += '/';
      }
      var handlers = [{
        handler: route.handler,
        names: names
      }];
      if (routeName) {
        this.names[routeName] = {
          segments: segments,
          handlers: handlers
        };
      }
      currentState.handlers = handlers;
      currentState.regex = new RegExp(regex + '$');
      currentState.types = types;
      return currentState;
    };
    RouteRecognizer.prototype.handlersFor = function handlersFor(name) {
      var route = this.names[name];
      if (!route) {
        throw new Error('There is no route named ' + name);
      }
      return [].concat(route.handlers);
    };
    RouteRecognizer.prototype.hasRoute = function hasRoute(name) {
      return !!this.names[name];
    };
    RouteRecognizer.prototype.generate = function generate(name, params) {
      var routeParams = Object.assign({}, params);
      var route = this.names[name];
      if (!route) {
        throw new Error('There is no route named ' + name);
      }
      var segments = route.segments;
      var consumed = {};
      var output = '';
      for (var i = 0,
          l = segments.length; i < l; i++) {
        var segment = segments[i];
        if (segment instanceof EpsilonSegment) {
          continue;
        }
        output += '/';
        var segmentValue = segment.generate(routeParams, consumed);
        if (segmentValue === null || segmentValue === undefined) {
          throw new Error('A value is required for route parameter \'' + segment.name + '\' in route \'' + name + '\'.');
        }
        output += segmentValue;
      }
      if (output.charAt(0) !== '/') {
        output = '/' + output;
      }
      for (var param in consumed) {
        delete routeParams[param];
      }
      var queryString = _aureliaPath.buildQueryString(routeParams);
      output += queryString ? '?' + queryString : '';
      return output;
    };
    RouteRecognizer.prototype.recognize = function recognize(path) {
      var states = [this.rootState];
      var queryParams = {};
      var isSlashDropped = false;
      var normalizedPath = path;
      var queryStart = normalizedPath.indexOf('?');
      if (queryStart !== -1) {
        var queryString = normalizedPath.substr(queryStart + 1, normalizedPath.length);
        normalizedPath = normalizedPath.substr(0, queryStart);
        queryParams = _aureliaPath.parseQueryString(queryString);
      }
      normalizedPath = decodeURI(normalizedPath);
      if (normalizedPath.charAt(0) !== '/') {
        normalizedPath = '/' + normalizedPath;
      }
      var pathLen = normalizedPath.length;
      if (pathLen > 1 && normalizedPath.charAt(pathLen - 1) === '/') {
        normalizedPath = normalizedPath.substr(0, pathLen - 1);
        isSlashDropped = true;
      }
      for (var i = 0,
          l = normalizedPath.length; i < l; i++) {
        states = recognizeChar(states, normalizedPath.charAt(i));
        if (!states.length) {
          break;
        }
      }
      var solutions = [];
      for (var i = 0,
          l = states.length; i < l; i++) {
        if (states[i].handlers) {
          solutions.push(states[i]);
        }
      }
      states = sortSolutions(solutions);
      var state = solutions[0];
      if (state && state.handlers) {
        if (isSlashDropped && state.regex.source.slice(-5) === '(.+)$') {
          normalizedPath = normalizedPath + '/';
        }
        return findHandler(state, normalizedPath, queryParams);
      }
    };
    return RouteRecognizer;
  })();
  exports.RouteRecognizer = RouteRecognizer;
  var RecognizeResults = function RecognizeResults(queryParams) {
    _classCallCheck(this, RecognizeResults);
    this.splice = Array.prototype.splice;
    this.slice = Array.prototype.slice;
    this.push = Array.prototype.push;
    this.length = 0;
    this.queryParams = queryParams || {};
  };
  function parse(route, names, types) {
    var normalizedRoute = route;
    if (route.charAt(0) === '/') {
      normalizedRoute = route.substr(1);
    }
    var results = [];
    for (var _iterator3 = normalizedRoute.split('/'),
        _isArray3 = Array.isArray(_iterator3),
        _i3 = 0,
        _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
      var _ref3;
      if (_isArray3) {
        if (_i3 >= _iterator3.length)
          break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done)
          break;
        _ref3 = _i3.value;
      }
      var segment = _ref3;
      var match = segment.match(/^:([^\/]+)$/);
      if (match) {
        results.push(new DynamicSegment(match[1]));
        names.push(match[1]);
        types.dynamics++;
        continue;
      }
      match = segment.match(/^\*([^\/]+)$/);
      if (match) {
        results.push(new StarSegment(match[1]));
        names.push(match[1]);
        types.stars++;
      } else if (segment === '') {
        results.push(new EpsilonSegment());
      } else {
        results.push(new StaticSegment(segment));
        types.statics++;
      }
    }
    return results;
  }
  function sortSolutions(states) {
    return states.sort(function(a, b) {
      if (a.types.stars !== b.types.stars) {
        return a.types.stars - b.types.stars;
      }
      if (a.types.stars) {
        if (a.types.statics !== b.types.statics) {
          return b.types.statics - a.types.statics;
        }
        if (a.types.dynamics !== b.types.dynamics) {
          return b.types.dynamics - a.types.dynamics;
        }
      }
      if (a.types.dynamics !== b.types.dynamics) {
        return a.types.dynamics - b.types.dynamics;
      }
      if (a.types.statics !== b.types.statics) {
        return b.types.statics - a.types.statics;
      }
      return 0;
    });
  }
  function recognizeChar(states, ch) {
    var nextStates = [];
    for (var i = 0,
        l = states.length; i < l; i++) {
      var state = states[i];
      nextStates.push.apply(nextStates, state.match(ch));
    }
    return nextStates;
  }
  function findHandler(state, path, queryParams) {
    var handlers = state.handlers;
    var regex = state.regex;
    var captures = path.match(regex);
    var currentCapture = 1;
    var result = new RecognizeResults(queryParams);
    for (var i = 0,
        l = handlers.length; i < l; i++) {
      var _handler = handlers[i];
      var _names = _handler.names;
      var _params = {};
      for (var j = 0,
          m = _names.length; j < m; j++) {
        _params[_names[j]] = captures[currentCapture++];
      }
      result.push({
        handler: _handler.handler,
        params: _params,
        isDynamic: !!_names.length
      });
    }
    return result;
  }
  function addSegment(currentState, segment) {
    var state = currentState;
    segment.eachChar(function(ch) {
      state = state.put(ch);
    });
    return state;
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-route-recognizer@1.0.0-beta.1", ["npm:aurelia-route-recognizer@1.0.0-beta.1/aurelia-route-recognizer"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-event-aggregator@1.0.0-beta.1.1.1/aurelia-event-aggregator", ["exports", "npm:aurelia-logging@1.0.0-beta.1.1.1"], function(exports, _aureliaLogging) {
  'use strict';
  exports.__esModule = true;
  exports.includeEventsIn = includeEventsIn;
  exports.configure = configure;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var logger = _aureliaLogging.getLogger('event-aggregator');
  var Handler = (function() {
    function Handler(messageType, callback) {
      _classCallCheck(this, Handler);
      this.messageType = messageType;
      this.callback = callback;
    }
    Handler.prototype.handle = function handle(message) {
      if (message instanceof this.messageType) {
        this.callback.call(null, message);
      }
    };
    return Handler;
  })();
  var EventAggregator = (function() {
    function EventAggregator() {
      _classCallCheck(this, EventAggregator);
      this.eventLookup = {};
      this.messageHandlers = [];
    }
    EventAggregator.prototype.publish = function publish(event, data) {
      var subscribers = undefined;
      var i = undefined;
      if (!event) {
        throw new Error('Event was invalid.');
      }
      if (typeof event === 'string') {
        subscribers = this.eventLookup[event];
        if (subscribers) {
          subscribers = subscribers.slice();
          i = subscribers.length;
          try {
            while (i--) {
              subscribers[i](data, event);
            }
          } catch (e) {
            logger.error(e);
          }
        }
      } else {
        subscribers = this.messageHandlers.slice();
        i = subscribers.length;
        try {
          while (i--) {
            subscribers[i].handle(event);
          }
        } catch (e) {
          logger.error(e);
        }
      }
    };
    EventAggregator.prototype.subscribe = function subscribe(event, callback) {
      var handler = undefined;
      var subscribers = undefined;
      if (!event) {
        throw new Error('Event channel/type was invalid.');
      }
      if (typeof event === 'string') {
        handler = callback;
        subscribers = this.eventLookup[event] || (this.eventLookup[event] = []);
      } else {
        handler = new Handler(event, callback);
        subscribers = this.messageHandlers;
      }
      subscribers.push(handler);
      return {dispose: function dispose() {
          var idx = subscribers.indexOf(handler);
          if (idx !== -1) {
            subscribers.splice(idx, 1);
          }
        }};
    };
    EventAggregator.prototype.subscribeOnce = function subscribeOnce(event, callback) {
      var sub = this.subscribe(event, function(a, b) {
        sub.dispose();
        return callback(a, b);
      });
      return sub;
    };
    return EventAggregator;
  })();
  exports.EventAggregator = EventAggregator;
  function includeEventsIn(obj) {
    var ea = new EventAggregator();
    obj.subscribeOnce = function(event, callback) {
      return ea.subscribeOnce(event, callback);
    };
    obj.subscribe = function(event, callback) {
      return ea.subscribe(event, callback);
    };
    obj.publish = function(event, data) {
      ea.publish(event, data);
    };
    return ea;
  }
  function configure(config) {
    config.instance(EventAggregator, includeEventsIn(config.aurelia));
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-event-aggregator@1.0.0-beta.1.1.1", ["npm:aurelia-event-aggregator@1.0.0-beta.1.1.1/aurelia-event-aggregator"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-router@1.0.0-beta.1.0.1/aurelia-router", ["exports", "npm:core-js@1.2.6", "npm:aurelia-logging@1.0.0-beta.1.1.1", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-route-recognizer@1.0.0-beta.1", "npm:aurelia-history@1.0.0-beta.1", "npm:aurelia-event-aggregator@1.0.0-beta.1.1.1"], function(exports, _coreJs, _aureliaLogging, _aureliaDependencyInjection, _aureliaRouteRecognizer, _aureliaHistory, _aureliaEventAggregator) {
  'use strict';
  exports.__esModule = true;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports._normalizeAbsolutePath = _normalizeAbsolutePath;
  exports._createRootedPath = _createRootedPath;
  exports._resolveUrl = _resolveUrl;
  exports.createRouteFilterStep = createRouteFilterStep;
  exports.isNavigationCommand = isNavigationCommand;
  exports._buildNavigationPlan = _buildNavigationPlan;
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _normalizeAbsolutePath(path, hasPushState) {
    if (!hasPushState && path[0] !== '#') {
      path = '#' + path;
    }
    return path;
  }
  function _createRootedPath(fragment, baseUrl, hasPushState) {
    if (isAbsoluteUrl.test(fragment)) {
      return fragment;
    }
    var path = '';
    if (baseUrl.length && baseUrl[0] !== '/') {
      path += '/';
    }
    path += baseUrl;
    if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {
      path += '/';
    }
    if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {
      path = path.substring(0, path.length - 1);
    }
    return _normalizeAbsolutePath(path + fragment, hasPushState);
  }
  function _resolveUrl(fragment, baseUrl, hasPushState) {
    if (isRootedPath.test(fragment)) {
      return _normalizeAbsolutePath(fragment, hasPushState);
    }
    return _createRootedPath(fragment, baseUrl, hasPushState);
  }
  var isRootedPath = /^#?\//;
  var isAbsoluteUrl = /^([a-z][a-z0-9+\-.]*:)?\/\//i;
  var RouteFilterContainer = (function() {
    RouteFilterContainer.inject = function inject() {
      return [_aureliaDependencyInjection.Container];
    };
    function RouteFilterContainer(container) {
      _classCallCheck(this, RouteFilterContainer);
      this.container = container;
      this.filters = {};
      this.filterCache = {};
    }
    RouteFilterContainer.prototype.addStep = function addStep(name, step) {
      var index = arguments.length <= 2 || arguments[2] === undefined ? -1 : arguments[2];
      var filter = this.filters[name];
      if (!filter) {
        filter = this.filters[name] = [];
      }
      if (index === -1) {
        index = filter.length;
      }
      filter.splice(index, 0, step);
      this.filterCache = {};
    };
    RouteFilterContainer.prototype.getFilterSteps = function getFilterSteps(name) {
      if (this.filterCache[name]) {
        return this.filterCache[name];
      }
      var steps = [];
      var filter = this.filters[name];
      if (!filter) {
        return steps;
      }
      for (var i = 0,
          l = filter.length; i < l; i++) {
        if (typeof filter[i] === 'string') {
          steps.push.apply(steps, this.getFilterSteps(filter[i]));
        } else {
          steps.push(this.container.get(filter[i]));
        }
      }
      this.filterCache[name] = steps;
      return steps;
    };
    return RouteFilterContainer;
  })();
  exports.RouteFilterContainer = RouteFilterContainer;
  function createRouteFilterStep(name) {
    function create(routeFilterContainer) {
      return new RouteFilterStep(name, routeFilterContainer);
    }
    create.inject = function() {
      return [RouteFilterContainer];
    };
    return create;
  }
  var RouteFilterStep = (function() {
    function RouteFilterStep(name, routeFilterContainer) {
      _classCallCheck(this, RouteFilterStep);
      this.isMultiStep = true;
      this.name = name;
      this.routeFilterContainer = routeFilterContainer;
    }
    RouteFilterStep.prototype.getSteps = function getSteps() {
      return this.routeFilterContainer.getFilterSteps(this.name);
    };
    return RouteFilterStep;
  })();
  var pipelineStatus = {
    completed: 'completed',
    canceled: 'canceled',
    rejected: 'rejected',
    running: 'running'
  };
  exports.pipelineStatus = pipelineStatus;
  var Pipeline = (function() {
    function Pipeline() {
      _classCallCheck(this, Pipeline);
      this.steps = [];
    }
    Pipeline.prototype.addStep = function addStep(step) {
      var run = undefined;
      if (typeof step === 'function') {
        run = step;
      } else if (step.isMultiStep) {
        var steps = step.getSteps();
        for (var i = 0,
            l = steps.length; i < l; i++) {
          this.addStep(steps[i]);
        }
        return this;
      } else {
        run = step.run.bind(step);
      }
      this.steps.push(run);
      return this;
    };
    Pipeline.prototype.run = function run(instruction) {
      var index = -1;
      var steps = this.steps;
      function next() {
        index++;
        if (index < steps.length) {
          var currentStep = steps[index];
          try {
            return currentStep(instruction, next);
          } catch (e) {
            return next.reject(e);
          }
        } else {
          return next.complete();
        }
      }
      next.complete = createCompletionHandler(next, pipelineStatus.completed);
      next.cancel = createCompletionHandler(next, pipelineStatus.canceled);
      next.reject = createCompletionHandler(next, pipelineStatus.rejected);
      return next();
    };
    return Pipeline;
  })();
  exports.Pipeline = Pipeline;
  function createCompletionHandler(next, status) {
    return function(output) {
      return Promise.resolve({
        status: status,
        output: output,
        completed: status === pipelineStatus.completed
      });
    };
  }
  var CommitChangesStep = (function() {
    function CommitChangesStep() {
      _classCallCheck(this, CommitChangesStep);
    }
    CommitChangesStep.prototype.run = function run(navigationInstruction, next) {
      return navigationInstruction._commitChanges(true).then(function() {
        navigationInstruction._updateTitle();
        return next();
      });
    };
    return CommitChangesStep;
  })();
  exports.CommitChangesStep = CommitChangesStep;
  var NavigationInstruction = (function() {
    function NavigationInstruction(init) {
      _classCallCheck(this, NavigationInstruction);
      this.plan = null;
      Object.assign(this, init);
      this.params = this.params || {};
      this.viewPortInstructions = {};
      var ancestorParams = [];
      var current = this;
      do {
        var currentParams = Object.assign({}, current.params);
        if (current.config && current.config.hasChildRouter) {
          delete currentParams[current.getWildCardName()];
        }
        ancestorParams.unshift(currentParams);
        current = current.parentInstruction;
      } while (current);
      var allParams = Object.assign.apply(Object, [{}, this.queryParams].concat(ancestorParams));
      this.lifecycleArgs = [allParams, this.config, this];
    }
    NavigationInstruction.prototype.getAllInstructions = function getAllInstructions() {
      var instructions = [this];
      for (var key in this.viewPortInstructions) {
        var childInstruction = this.viewPortInstructions[key].childNavigationInstruction;
        if (childInstruction) {
          instructions.push.apply(instructions, childInstruction.getAllInstructions());
        }
      }
      return instructions;
    };
    NavigationInstruction.prototype.getAllPreviousInstructions = function getAllPreviousInstructions() {
      return this.getAllInstructions().map(function(c) {
        return c.previousInstruction;
      }).filter(function(c) {
        return c;
      });
    };
    NavigationInstruction.prototype.addViewPortInstruction = function addViewPortInstruction(viewPortName, strategy, moduleId, component) {
      var viewportInstruction = this.viewPortInstructions[viewPortName] = {
        name: viewPortName,
        strategy: strategy,
        moduleId: moduleId,
        component: component,
        childRouter: component.childRouter,
        lifecycleArgs: this.lifecycleArgs.slice()
      };
      return viewportInstruction;
    };
    NavigationInstruction.prototype.getWildCardName = function getWildCardName() {
      var wildcardIndex = this.config.route.lastIndexOf('*');
      return this.config.route.substr(wildcardIndex + 1);
    };
    NavigationInstruction.prototype.getWildcardPath = function getWildcardPath() {
      var wildcardName = this.getWildCardName();
      var path = this.params[wildcardName] || '';
      if (this.queryString) {
        path += '?' + this.queryString;
      }
      return path;
    };
    NavigationInstruction.prototype.getBaseUrl = function getBaseUrl() {
      if (!this.params) {
        return this.fragment;
      }
      var wildcardName = this.getWildCardName();
      var path = this.params[wildcardName] || '';
      if (!path) {
        return this.fragment;
      }
      return this.fragment.substr(0, this.fragment.lastIndexOf(path));
    };
    NavigationInstruction.prototype._commitChanges = function _commitChanges(waitToSwap) {
      var _this = this;
      var router = this.router;
      router.currentInstruction = this;
      if (this.previousInstruction) {
        this.previousInstruction.config.navModel.isActive = false;
      }
      this.config.navModel.isActive = true;
      router._refreshBaseUrl();
      router.refreshNavigation();
      var loads = [];
      var delaySwaps = [];
      var _loop = function(viewPortName) {
        var viewPortInstruction = _this.viewPortInstructions[viewPortName];
        var viewPort = router.viewPorts[viewPortName];
        if (!viewPort) {
          throw new Error('There was no router-view found in the view for ' + viewPortInstruction.moduleId + '.');
        }
        if (viewPortInstruction.strategy === activationStrategy.replace) {
          if (waitToSwap) {
            delaySwaps.push({
              viewPort: viewPort,
              viewPortInstruction: viewPortInstruction
            });
          }
          loads.push(viewPort.process(viewPortInstruction, waitToSwap).then(function(x) {
            if (viewPortInstruction.childNavigationInstruction) {
              return viewPortInstruction.childNavigationInstruction._commitChanges();
            }
          }));
        } else {
          if (viewPortInstruction.childNavigationInstruction) {
            loads.push(viewPortInstruction.childNavigationInstruction._commitChanges(waitToSwap));
          }
        }
      };
      for (var viewPortName in this.viewPortInstructions) {
        _loop(viewPortName);
      }
      return Promise.all(loads).then(function() {
        delaySwaps.forEach(function(x) {
          return x.viewPort.swap(x.viewPortInstruction);
        });
      }).then(function() {
        return prune(_this);
      });
    };
    NavigationInstruction.prototype._updateTitle = function _updateTitle() {
      var title = this._buildTitle();
      if (title) {
        this.router.history.setTitle(title);
      }
    };
    NavigationInstruction.prototype._buildTitle = function _buildTitle() {
      var separator = arguments.length <= 0 || arguments[0] === undefined ? ' | ' : arguments[0];
      var title = this.config.navModel.title || '';
      var childTitles = [];
      for (var viewPortName in this.viewPortInstructions) {
        var viewPortInstruction = this.viewPortInstructions[viewPortName];
        if (viewPortInstruction.childNavigationInstruction) {
          var childTitle = viewPortInstruction.childNavigationInstruction._buildTitle(separator);
          if (childTitle) {
            childTitles.push(childTitle);
          }
        }
      }
      if (childTitles.length) {
        title = childTitles.join(separator) + (title ? separator : '') + title;
      }
      if (this.router.title) {
        title += (title ? separator : '') + this.router.title;
      }
      return title;
    };
    return NavigationInstruction;
  })();
  exports.NavigationInstruction = NavigationInstruction;
  function prune(instruction) {
    instruction.previousInstruction = null;
    instruction.plan = null;
  }
  var NavModel = (function() {
    function NavModel(router, relativeHref) {
      _classCallCheck(this, NavModel);
      this.isActive = false;
      this.title = null;
      this.href = null;
      this.relativeHref = null;
      this.settings = {};
      this.config = null;
      this.router = router;
      this.relativeHref = relativeHref;
    }
    NavModel.prototype.setTitle = function setTitle(title) {
      this.title = title;
      if (this.isActive) {
        this.router.updateTitle();
      }
    };
    return NavModel;
  })();
  exports.NavModel = NavModel;
  function isNavigationCommand(obj) {
    return obj && typeof obj.navigate === 'function';
  }
  var Redirect = (function() {
    function Redirect(url) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      _classCallCheck(this, Redirect);
      this.url = url;
      this.options = Object.assign({
        trigger: true,
        replace: true
      }, options);
      this.shouldContinueProcessing = false;
    }
    Redirect.prototype.setRouter = function setRouter(router) {
      this.router = router;
    };
    Redirect.prototype.navigate = function navigate(appRouter) {
      var navigatingRouter = this.options.useAppRouter ? appRouter : this.router || appRouter;
      navigatingRouter.navigate(this.url, this.options);
    };
    return Redirect;
  })();
  exports.Redirect = Redirect;
  var RouterConfiguration = (function() {
    function RouterConfiguration() {
      _classCallCheck(this, RouterConfiguration);
      this.instructions = [];
      this.options = {};
      this.pipelineSteps = [];
    }
    RouterConfiguration.prototype.addPipelineStep = function addPipelineStep(name, step) {
      this.pipelineSteps.push({
        name: name,
        step: step
      });
      return this;
    };
    RouterConfiguration.prototype.map = function map(route) {
      if (Array.isArray(route)) {
        route.forEach(this.map.bind(this));
        return this;
      }
      return this.mapRoute(route);
    };
    RouterConfiguration.prototype.mapRoute = function mapRoute(config) {
      this.instructions.push(function(router) {
        var routeConfigs = [];
        if (Array.isArray(config.route)) {
          for (var i = 0,
              ii = config.route.length; i < ii; ++i) {
            var current = Object.assign({}, config);
            current.route = config.route[i];
            routeConfigs.push(current);
          }
        } else {
          routeConfigs.push(Object.assign({}, config));
        }
        var navModel = undefined;
        for (var i = 0,
            ii = routeConfigs.length; i < ii; ++i) {
          var routeConfig = routeConfigs[i];
          routeConfig.settings = routeConfig.settings || {};
          if (!navModel) {
            navModel = router.createNavModel(routeConfig);
          }
          router.addRoute(routeConfig, navModel);
        }
      });
      return this;
    };
    RouterConfiguration.prototype.mapUnknownRoutes = function mapUnknownRoutes(config) {
      this.unknownRouteConfig = config;
      return this;
    };
    RouterConfiguration.prototype.exportToRouter = function exportToRouter(router) {
      var instructions = this.instructions;
      for (var i = 0,
          ii = instructions.length; i < ii; ++i) {
        instructions[i](router);
      }
      if (this.title) {
        router.title = this.title;
      }
      if (this.unknownRouteConfig) {
        router.handleUnknownRoutes(this.unknownRouteConfig);
      }
      router.options = this.options;
      var pipelineSteps = this.pipelineSteps;
      if (pipelineSteps.length) {
        if (!router.isRoot) {
          throw new Error('Pipeline steps can only be added to the root router');
        }
        var filterContainer = router.container.get(RouteFilterContainer);
        for (var i = 0,
            ii = pipelineSteps.length; i < ii; ++i) {
          var _pipelineSteps$i = pipelineSteps[i];
          var _name = _pipelineSteps$i.name;
          var step = _pipelineSteps$i.step;
          filterContainer.addStep(_name, step);
        }
      }
    };
    return RouterConfiguration;
  })();
  exports.RouterConfiguration = RouterConfiguration;
  var activationStrategy = {
    noChange: 'no-change',
    invokeLifecycle: 'invoke-lifecycle',
    replace: 'replace'
  };
  exports.activationStrategy = activationStrategy;
  var BuildNavigationPlanStep = (function() {
    function BuildNavigationPlanStep() {
      _classCallCheck(this, BuildNavigationPlanStep);
    }
    BuildNavigationPlanStep.prototype.run = function run(navigationInstruction, next) {
      return _buildNavigationPlan(navigationInstruction).then(function(plan) {
        navigationInstruction.plan = plan;
        return next();
      })['catch'](next.cancel);
    };
    return BuildNavigationPlanStep;
  })();
  exports.BuildNavigationPlanStep = BuildNavigationPlanStep;
  function _buildNavigationPlan(instruction, forceLifecycleMinimum) {
    var prev = instruction.previousInstruction;
    var config = instruction.config;
    var plan = {};
    if ('redirect' in config) {
      var redirectLocation = _resolveUrl(config.redirect, getInstructionBaseUrl(instruction));
      if (instruction.queryString) {
        redirectLocation += '?' + instruction.queryString;
      }
      return Promise.reject(new Redirect(redirectLocation));
    }
    if (prev) {
      var newParams = hasDifferentParameterValues(prev, instruction);
      var pending = [];
      var _loop2 = function(viewPortName) {
        var prevViewPortInstruction = prev.viewPortInstructions[viewPortName];
        var nextViewPortConfig = config.viewPorts[viewPortName];
        var viewPortPlan = plan[viewPortName] = {
          name: viewPortName,
          config: nextViewPortConfig,
          prevComponent: prevViewPortInstruction.component,
          prevModuleId: prevViewPortInstruction.moduleId
        };
        if (prevViewPortInstruction.moduleId !== nextViewPortConfig.moduleId) {
          viewPortPlan.strategy = activationStrategy.replace;
        } else if ('determineActivationStrategy' in prevViewPortInstruction.component.viewModel) {
          var _prevViewPortInstruction$component$viewModel;
          viewPortPlan.strategy = (_prevViewPortInstruction$component$viewModel = prevViewPortInstruction.component.viewModel).determineActivationStrategy.apply(_prevViewPortInstruction$component$viewModel, instruction.lifecycleArgs);
        } else if (config.activationStrategy) {
          viewPortPlan.strategy = config.activationStrategy;
        } else if (newParams || forceLifecycleMinimum) {
          viewPortPlan.strategy = activationStrategy.invokeLifecycle;
        } else {
          viewPortPlan.strategy = activationStrategy.noChange;
        }
        if (viewPortPlan.strategy !== activationStrategy.replace && prevViewPortInstruction.childRouter) {
          var path = instruction.getWildcardPath();
          var task = prevViewPortInstruction.childRouter._createNavigationInstruction(path, instruction).then(function(childInstruction) {
            viewPortPlan.childNavigationInstruction = childInstruction;
            return _buildNavigationPlan(childInstruction, viewPortPlan.strategy === activationStrategy.invokeLifecycle).then(function(childPlan) {
              childInstruction.plan = childPlan;
            });
          });
          pending.push(task);
        }
      };
      for (var viewPortName in prev.viewPortInstructions) {
        _loop2(viewPortName);
      }
      return Promise.all(pending).then(function() {
        return plan;
      });
    }
    for (var viewPortName in config.viewPorts) {
      plan[viewPortName] = {
        name: viewPortName,
        strategy: activationStrategy.replace,
        config: instruction.config.viewPorts[viewPortName]
      };
    }
    return Promise.resolve(plan);
  }
  function hasDifferentParameterValues(prev, next) {
    var prevParams = prev.params;
    var nextParams = next.params;
    var nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;
    for (var key in nextParams) {
      if (key === nextWildCardName) {
        continue;
      }
      if (prevParams[key] !== nextParams[key]) {
        return true;
      }
    }
    for (var key in prevParams) {
      if (key === nextWildCardName) {
        continue;
      }
      if (prevParams[key] !== nextParams[key]) {
        return true;
      }
    }
    return false;
  }
  function getInstructionBaseUrl(instruction) {
    var instructionBaseUrlParts = [];
    instruction = instruction.parentInstruction;
    while (instruction) {
      instructionBaseUrlParts.unshift(instruction.getBaseUrl());
      instruction = instruction.parentInstruction;
    }
    instructionBaseUrlParts.unshift('/');
    return instructionBaseUrlParts.join('');
  }
  var Router = (function() {
    function Router(container, history) {
      _classCallCheck(this, Router);
      this.parent = null;
      this.container = container;
      this.history = history;
      this.reset();
    }
    Router.prototype.reset = function reset() {
      var _this2 = this;
      this.viewPorts = {};
      this.routes = [];
      this.baseUrl = '';
      this.isConfigured = false;
      this.isNavigating = false;
      this.navigation = [];
      this.currentInstruction = null;
      this._fallbackOrder = 100;
      this._recognizer = new _aureliaRouteRecognizer.RouteRecognizer();
      this._childRecognizer = new _aureliaRouteRecognizer.RouteRecognizer();
      this._configuredPromise = new Promise(function(resolve) {
        _this2._resolveConfiguredPromise = resolve;
      });
    };
    Router.prototype.registerViewPort = function registerViewPort(viewPort, name) {
      name = name || 'default';
      this.viewPorts[name] = viewPort;
    };
    Router.prototype.ensureConfigured = function ensureConfigured() {
      return this._configuredPromise;
    };
    Router.prototype.configure = function configure(callbackOrConfig) {
      var _this3 = this;
      this.isConfigured = true;
      var result = callbackOrConfig;
      var config = undefined;
      if (typeof callbackOrConfig === 'function') {
        config = new RouterConfiguration();
        result = callbackOrConfig(config);
      }
      return Promise.resolve(result).then(function(c) {
        if (c && c.exportToRouter) {
          config = c;
        }
        config.exportToRouter(_this3);
        _this3.isConfigured = true;
        _this3._resolveConfiguredPromise();
      });
    };
    Router.prototype.navigate = function navigate(fragment, options) {
      if (!this.isConfigured && this.parent) {
        return this.parent.navigate(fragment, options);
      }
      return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);
    };
    Router.prototype.navigateToRoute = function navigateToRoute(route, params, options) {
      var path = this.generate(route, params);
      return this.navigate(path, options);
    };
    Router.prototype.navigateBack = function navigateBack() {
      this.history.navigateBack();
    };
    Router.prototype.createChild = function createChild(container) {
      var childRouter = new Router(container || this.container.createChild(), this.history);
      childRouter.parent = this;
      return childRouter;
    };
    Router.prototype.generate = function generate(name, params) {
      var hasRoute = this._recognizer.hasRoute(name);
      if ((!this.isConfigured || !hasRoute) && this.parent) {
        return this.parent.generate(name, params);
      }
      if (!hasRoute) {
        throw new Error('A route with name \'' + name + '\' could not be found. Check that `name: \'' + name + '\'` was specified in the route\'s config.');
      }
      var path = this._recognizer.generate(name, params);
      return _createRootedPath(path, this.baseUrl, this.history._hasPushState);
    };
    Router.prototype.createNavModel = function createNavModel(config) {
      var navModel = new NavModel(this, 'href' in config ? config.href : config.route);
      navModel.title = config.title;
      navModel.order = config.nav;
      navModel.href = config.href;
      navModel.settings = config.settings;
      navModel.config = config;
      return navModel;
    };
    Router.prototype.addRoute = function addRoute(config, navModel) {
      validateRouteConfig(config);
      if (!('viewPorts' in config) && !config.navigationStrategy) {
        config.viewPorts = {'default': {
            moduleId: config.moduleId,
            view: config.view
          }};
      }
      if (!navModel) {
        navModel = this.createNavModel(config);
      }
      this.routes.push(config);
      var path = config.route;
      if (path.charAt(0) === '/') {
        path = path.substr(1);
      }
      var state = this._recognizer.add({
        path: path,
        handler: config
      });
      if (path) {
        var _settings = config.settings;
        delete config.settings;
        var withChild = JSON.parse(JSON.stringify(config));
        config.settings = _settings;
        withChild.route = path + '/*childRoute';
        withChild.hasChildRouter = true;
        this._childRecognizer.add({
          path: withChild.route,
          handler: withChild
        });
        withChild.navModel = navModel;
        withChild.settings = config.settings;
      }
      config.navModel = navModel;
      if ((navModel.order || navModel.order === 0) && this.navigation.indexOf(navModel) === -1) {
        if (!navModel.href && navModel.href !== '' && (state.types.dynamics || state.types.stars)) {
          throw new Error('Invalid route config: dynamic routes must specify an href to be included in the navigation model.');
        }
        if (typeof navModel.order !== 'number') {
          navModel.order = ++this._fallbackOrder;
        }
        this.navigation.push(navModel);
        this.navigation = this.navigation.sort(function(a, b) {
          return a.order - b.order;
        });
      }
    };
    Router.prototype.hasRoute = function hasRoute(name) {
      return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));
    };
    Router.prototype.hasOwnRoute = function hasOwnRoute(name) {
      return this._recognizer.hasRoute(name);
    };
    Router.prototype.handleUnknownRoutes = function handleUnknownRoutes(config) {
      var _this4 = this;
      if (!config) {
        throw new Error('Invalid unknown route handler');
      }
      this.catchAllHandler = function(instruction) {
        return _this4._createRouteConfig(config, instruction).then(function(c) {
          instruction.config = c;
          return instruction;
        });
      };
    };
    Router.prototype.updateTitle = function updateTitle() {
      if (this.parent) {
        return this.parent.updateTitle();
      }
      this.currentInstruction._updateTitle();
    };
    Router.prototype.refreshNavigation = function refreshNavigation() {
      var nav = this.navigation;
      for (var i = 0,
          _length = nav.length; i < _length; i++) {
        var current = nav[i];
        if (!current.href) {
          current.href = _createRootedPath(current.relativeHref, this.baseUrl, this.history._hasPushState);
        }
      }
    };
    Router.prototype._refreshBaseUrl = function _refreshBaseUrl() {
      if (this.parent) {
        var baseUrl = this.parent.currentInstruction.getBaseUrl();
        this.baseUrl = this.parent.baseUrl + baseUrl;
      }
    };
    Router.prototype._createNavigationInstruction = function _createNavigationInstruction() {
      var url = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
      var parentInstruction = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      var fragment = url;
      var queryString = '';
      var queryIndex = url.indexOf('?');
      if (queryIndex !== -1) {
        fragment = url.substr(0, queryIndex);
        queryString = url.substr(queryIndex + 1);
      }
      var results = this._recognizer.recognize(url);
      if (!results || !results.length) {
        results = this._childRecognizer.recognize(url);
      }
      var instructionInit = {
        fragment: fragment,
        queryString: queryString,
        config: null,
        parentInstruction: parentInstruction,
        previousInstruction: this.currentInstruction,
        router: this
      };
      if (results && results.length) {
        var first = results[0];
        var _instruction = new NavigationInstruction(Object.assign({}, instructionInit, {
          params: first.params,
          queryParams: first.queryParams || results.queryParams,
          config: first.config || first.handler
        }));
        if (typeof first.handler === 'function') {
          return evaluateNavigationStrategy(_instruction, first.handler, first);
        } else if (first.handler && 'navigationStrategy' in first.handler) {
          return evaluateNavigationStrategy(_instruction, first.handler.navigationStrategy, first.handler);
        }
        return Promise.resolve(_instruction);
      } else if (this.catchAllHandler) {
        var _instruction2 = new NavigationInstruction(Object.assign({}, instructionInit, {
          params: {path: fragment},
          queryParams: results && results.queryParams,
          config: null
        }));
        return evaluateNavigationStrategy(_instruction2, this.catchAllHandler);
      }
      return Promise.reject(new Error('Route not found: ' + url));
    };
    Router.prototype._createRouteConfig = function _createRouteConfig(config, instruction) {
      var _this5 = this;
      return Promise.resolve(config).then(function(c) {
        if (typeof c === 'string') {
          return {moduleId: c};
        } else if (typeof c === 'function') {
          return c(instruction);
        }
        return c;
      }).then(function(c) {
        return typeof c === 'string' ? {moduleId: c} : c;
      }).then(function(c) {
        c.route = instruction.params.path;
        validateRouteConfig(c);
        if (!c.navModel) {
          c.navModel = _this5.createNavModel(c);
        }
        return c;
      });
    };
    _createClass(Router, [{
      key: 'isRoot',
      get: function get() {
        return !this.parent;
      }
    }]);
    return Router;
  })();
  exports.Router = Router;
  function validateRouteConfig(config) {
    if (typeof config !== 'object') {
      throw new Error('Invalid Route Config');
    }
    if (typeof config.route !== 'string') {
      throw new Error('Invalid Route Config: You must specify a route pattern.');
    }
    if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {
      throw new Error('Invalid Route Config: You must specify a moduleId, redirect, navigationStrategy, or viewPorts.');
    }
  }
  function evaluateNavigationStrategy(instruction, evaluator, context) {
    return Promise.resolve(evaluator.call(context, instruction)).then(function() {
      if (!('viewPorts' in instruction.config)) {
        instruction.config.viewPorts = {'default': {moduleId: instruction.config.moduleId}};
      }
      return instruction;
    });
  }
  var CanDeactivatePreviousStep = (function() {
    function CanDeactivatePreviousStep() {
      _classCallCheck(this, CanDeactivatePreviousStep);
    }
    CanDeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
      return processDeactivatable(navigationInstruction.plan, 'canDeactivate', next);
    };
    return CanDeactivatePreviousStep;
  })();
  exports.CanDeactivatePreviousStep = CanDeactivatePreviousStep;
  var CanActivateNextStep = (function() {
    function CanActivateNextStep() {
      _classCallCheck(this, CanActivateNextStep);
    }
    CanActivateNextStep.prototype.run = function run(navigationInstruction, next) {
      return processActivatable(navigationInstruction, 'canActivate', next);
    };
    return CanActivateNextStep;
  })();
  exports.CanActivateNextStep = CanActivateNextStep;
  var DeactivatePreviousStep = (function() {
    function DeactivatePreviousStep() {
      _classCallCheck(this, DeactivatePreviousStep);
    }
    DeactivatePreviousStep.prototype.run = function run(navigationInstruction, next) {
      return processDeactivatable(navigationInstruction.plan, 'deactivate', next, true);
    };
    return DeactivatePreviousStep;
  })();
  exports.DeactivatePreviousStep = DeactivatePreviousStep;
  var ActivateNextStep = (function() {
    function ActivateNextStep() {
      _classCallCheck(this, ActivateNextStep);
    }
    ActivateNextStep.prototype.run = function run(navigationInstruction, next) {
      return processActivatable(navigationInstruction, 'activate', next, true);
    };
    return ActivateNextStep;
  })();
  exports.ActivateNextStep = ActivateNextStep;
  function processDeactivatable(plan, callbackName, next, ignoreResult) {
    var infos = findDeactivatable(plan, callbackName);
    var i = infos.length;
    function inspect(val) {
      if (ignoreResult || shouldContinue(val)) {
        return iterate();
      }
      return next.cancel(val);
    }
    function iterate() {
      if (i--) {
        try {
          var viewModel = infos[i];
          var _result = viewModel[callbackName]();
          return processPotential(_result, inspect, next.cancel);
        } catch (error) {
          return next.cancel(error);
        }
      }
      return next();
    }
    return iterate();
  }
  function findDeactivatable(plan, callbackName) {
    var list = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
    for (var viewPortName in plan) {
      var viewPortPlan = plan[viewPortName];
      var prevComponent = viewPortPlan.prevComponent;
      if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace) && prevComponent) {
        var viewModel = prevComponent.viewModel;
        if (callbackName in viewModel) {
          list.push(viewModel);
        }
      }
      if (viewPortPlan.childNavigationInstruction) {
        findDeactivatable(viewPortPlan.childNavigationInstruction.plan, callbackName, list);
      } else if (prevComponent) {
        addPreviousDeactivatable(prevComponent, callbackName, list);
      }
    }
    return list;
  }
  function addPreviousDeactivatable(component, callbackName, list) {
    var childRouter = component.childRouter;
    if (childRouter && childRouter.currentInstruction) {
      var viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;
      for (var viewPortName in viewPortInstructions) {
        var viewPortInstruction = viewPortInstructions[viewPortName];
        var prevComponent = viewPortInstruction.component;
        var prevViewModel = prevComponent.viewModel;
        if (callbackName in prevViewModel) {
          list.push(prevViewModel);
        }
        addPreviousDeactivatable(prevComponent, callbackName, list);
      }
    }
  }
  function processActivatable(navigationInstruction, callbackName, next, ignoreResult) {
    var infos = findActivatable(navigationInstruction, callbackName);
    var length = infos.length;
    var i = -1;
    function inspect(val, router) {
      if (ignoreResult || shouldContinue(val, router)) {
        return iterate();
      }
      return next.cancel(val);
    }
    function iterate() {
      i++;
      if (i < length) {
        try {
          var _ret3 = (function() {
            var _current$viewModel;
            var current = infos[i];
            var result = (_current$viewModel = current.viewModel)[callbackName].apply(_current$viewModel, current.lifecycleArgs);
            return {v: processPotential(result, function(val) {
                return inspect(val, current.router);
              }, next.cancel)};
          })();
          if (typeof _ret3 === 'object')
            return _ret3.v;
        } catch (error) {
          return next.cancel(error);
        }
      }
      return next();
    }
    return iterate();
  }
  function findActivatable(navigationInstruction, callbackName, list, router) {
    if (list === undefined)
      list = [];
    var plan = navigationInstruction.plan;
    Object.keys(plan).filter(function(viewPortName) {
      var viewPortPlan = plan[viewPortName];
      var viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];
      var viewModel = viewPortInstruction.component.viewModel;
      if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace) && callbackName in viewModel) {
        list.push({
          viewModel: viewModel,
          lifecycleArgs: viewPortInstruction.lifecycleArgs,
          router: router
        });
      }
      if (viewPortPlan.childNavigationInstruction) {
        findActivatable(viewPortPlan.childNavigationInstruction, callbackName, list, viewPortInstruction.component.childRouter || router);
      }
    });
    return list;
  }
  function shouldContinue(output, router) {
    if (output instanceof Error) {
      return false;
    }
    if (isNavigationCommand(output)) {
      if (typeof output.setRouter === 'function') {
        output.setRouter(router);
      }
      return !!output.shouldContinueProcessing;
    }
    if (output === undefined) {
      return true;
    }
    return output;
  }
  function processPotential(obj, resolve, reject) {
    if (obj && typeof obj.then === 'function') {
      return Promise.resolve(obj).then(resolve)['catch'](reject);
    }
    try {
      return resolve(obj);
    } catch (error) {
      return reject(error);
    }
  }
  var RouteLoader = (function() {
    function RouteLoader() {
      _classCallCheck(this, RouteLoader);
    }
    RouteLoader.prototype.loadRoute = function loadRoute(router, config, navigationInstruction) {
      throw Error('Route loaders must implement "loadRoute(router, config, navigationInstruction)".');
    };
    return RouteLoader;
  })();
  exports.RouteLoader = RouteLoader;
  var LoadRouteStep = (function() {
    LoadRouteStep.inject = function inject() {
      return [RouteLoader];
    };
    function LoadRouteStep(routeLoader) {
      _classCallCheck(this, LoadRouteStep);
      this.routeLoader = routeLoader;
    }
    LoadRouteStep.prototype.run = function run(navigationInstruction, next) {
      return loadNewRoute(this.routeLoader, navigationInstruction).then(next)['catch'](next.cancel);
    };
    return LoadRouteStep;
  })();
  exports.LoadRouteStep = LoadRouteStep;
  function loadNewRoute(routeLoader, navigationInstruction) {
    var toLoad = determineWhatToLoad(navigationInstruction);
    var loadPromises = toLoad.map(function(current) {
      return loadRoute(routeLoader, current.navigationInstruction, current.viewPortPlan);
    });
    return Promise.all(loadPromises);
  }
  function determineWhatToLoad(navigationInstruction) {
    var toLoad = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
    var plan = navigationInstruction.plan;
    for (var viewPortName in plan) {
      var viewPortPlan = plan[viewPortName];
      if (viewPortPlan.strategy === activationStrategy.replace) {
        toLoad.push({
          viewPortPlan: viewPortPlan,
          navigationInstruction: navigationInstruction
        });
        if (viewPortPlan.childNavigationInstruction) {
          determineWhatToLoad(viewPortPlan.childNavigationInstruction, toLoad);
        }
      } else {
        var viewPortInstruction = navigationInstruction.addViewPortInstruction(viewPortName, viewPortPlan.strategy, viewPortPlan.prevModuleId, viewPortPlan.prevComponent);
        if (viewPortPlan.childNavigationInstruction) {
          viewPortInstruction.childNavigationInstruction = viewPortPlan.childNavigationInstruction;
          determineWhatToLoad(viewPortPlan.childNavigationInstruction, toLoad);
        }
      }
    }
    return toLoad;
  }
  function loadRoute(routeLoader, navigationInstruction, viewPortPlan) {
    var moduleId = viewPortPlan.config.moduleId;
    return loadComponent(routeLoader, navigationInstruction, viewPortPlan.config).then(function(component) {
      var viewPortInstruction = navigationInstruction.addViewPortInstruction(viewPortPlan.name, viewPortPlan.strategy, moduleId, component);
      var childRouter = component.childRouter;
      if (childRouter) {
        var path = navigationInstruction.getWildcardPath();
        return childRouter._createNavigationInstruction(path, navigationInstruction).then(function(childInstruction) {
          viewPortPlan.childNavigationInstruction = childInstruction;
          return _buildNavigationPlan(childInstruction).then(function(childPlan) {
            childInstruction.plan = childPlan;
            viewPortInstruction.childNavigationInstruction = childInstruction;
            return loadNewRoute(routeLoader, childInstruction);
          });
        });
      }
    });
  }
  function loadComponent(routeLoader, navigationInstruction, config) {
    var router = navigationInstruction.router;
    var lifecycleArgs = navigationInstruction.lifecycleArgs;
    return routeLoader.loadRoute(router, config, navigationInstruction).then(function(component) {
      var viewModel = component.viewModel;
      var childContainer = component.childContainer;
      component.router = router;
      component.config = config;
      if ('configureRouter' in viewModel) {
        var _ret4 = (function() {
          var childRouter = childContainer.getChildRouter();
          component.childRouter = childRouter;
          return {v: childRouter.configure(function(c) {
              return viewModel.configureRouter.apply(viewModel, [c, childRouter].concat(lifecycleArgs));
            }).then(function() {
              return component;
            })};
        })();
        if (typeof _ret4 === 'object')
          return _ret4.v;
      }
      return component;
    });
  }
  var PipelineProvider = (function() {
    PipelineProvider.inject = function inject() {
      return [_aureliaDependencyInjection.Container];
    };
    function PipelineProvider(container) {
      _classCallCheck(this, PipelineProvider);
      this.container = container;
      this.steps = [BuildNavigationPlanStep, CanDeactivatePreviousStep, LoadRouteStep, createRouteFilterStep('authorize'), createRouteFilterStep('modelbind'), CanActivateNextStep, DeactivatePreviousStep, ActivateNextStep, createRouteFilterStep('precommit'), CommitChangesStep, createRouteFilterStep('postcomplete')];
    }
    PipelineProvider.prototype.createPipeline = function createPipeline() {
      var _this6 = this;
      var pipeline = new Pipeline();
      this.steps.forEach(function(step) {
        return pipeline.addStep(_this6.container.get(step));
      });
      return pipeline;
    };
    return PipelineProvider;
  })();
  exports.PipelineProvider = PipelineProvider;
  var logger = _aureliaLogging.getLogger('app-router');
  var AppRouter = (function(_Router) {
    _inherits(AppRouter, _Router);
    AppRouter.inject = function inject() {
      return [_aureliaDependencyInjection.Container, _aureliaHistory.History, PipelineProvider, _aureliaEventAggregator.EventAggregator];
    };
    function AppRouter(container, history, pipelineProvider, events) {
      _classCallCheck(this, AppRouter);
      _Router.call(this, container, history);
      this.pipelineProvider = pipelineProvider;
      this.events = events;
    }
    AppRouter.prototype.reset = function reset() {
      _Router.prototype.reset.call(this);
      this.maxInstructionCount = 10;
      if (!this._queue) {
        this._queue = [];
      } else {
        this._queue.length = 0;
      }
    };
    AppRouter.prototype.loadUrl = function loadUrl(url) {
      var _this7 = this;
      return this._createNavigationInstruction(url).then(function(instruction) {
        return _this7._queueInstruction(instruction);
      })['catch'](function(error) {
        logger.error(error);
        restorePreviousLocation(_this7);
      });
    };
    AppRouter.prototype.registerViewPort = function registerViewPort(viewPort, name) {
      var _this8 = this;
      _Router.prototype.registerViewPort.call(this, viewPort, name);
      if (!this.isActive) {
        var _ret5 = (function() {
          var viewModel = _this8._findViewModel(viewPort);
          if ('configureRouter' in viewModel) {
            if (!_this8.isConfigured) {
              var _ret6 = (function() {
                var resolveConfiguredPromise = _this8._resolveConfiguredPromise;
                _this8._resolveConfiguredPromise = function() {};
                return {v: {v: _this8.configure(function(config) {
                      return viewModel.configureRouter(config, _this8);
                    }).then(function() {
                      _this8.activate();
                      resolveConfiguredPromise();
                    })}};
              })();
              if (typeof _ret6 === 'object')
                return _ret6.v;
            }
          } else {
            _this8.activate();
          }
        })();
        if (typeof _ret5 === 'object')
          return _ret5.v;
      } else {
        this._dequeueInstruction();
      }
      return Promise.resolve();
    };
    AppRouter.prototype.activate = function activate(options) {
      if (this.isActive) {
        return;
      }
      this.isActive = true;
      this.options = Object.assign({routeHandler: this.loadUrl.bind(this)}, this.options, options);
      this.history.activate(this.options);
      this._dequeueInstruction();
    };
    AppRouter.prototype.deactivate = function deactivate() {
      this.isActive = false;
      this.history.deactivate();
    };
    AppRouter.prototype._queueInstruction = function _queueInstruction(instruction) {
      var _this9 = this;
      return new Promise(function(resolve) {
        instruction.resolve = resolve;
        _this9._queue.unshift(instruction);
        _this9._dequeueInstruction();
      });
    };
    AppRouter.prototype._dequeueInstruction = function _dequeueInstruction() {
      var _this10 = this;
      var instructionCount = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
      return Promise.resolve().then(function() {
        if (_this10.isNavigating && !instructionCount) {
          return undefined;
        }
        var instruction = _this10._queue.shift();
        _this10._queue.length = 0;
        if (!instruction) {
          return undefined;
        }
        _this10.isNavigating = true;
        instruction.previousInstruction = _this10.currentInstruction;
        if (!instructionCount) {
          _this10.events.publish('router:navigation:processing', {instruction: instruction});
        } else if (instructionCount === _this10.maxInstructionCount - 1) {
          logger.error(instructionCount + 1 + ' navigation instructions have been attempted without success. Restoring last known good location.');
          restorePreviousLocation(_this10);
          return _this10._dequeueInstruction(instructionCount + 1);
        } else if (instructionCount > _this10.maxInstructionCount) {
          throw new Error('Maximum navigation attempts exceeded. Giving up.');
        }
        var pipeline = _this10.pipelineProvider.createPipeline();
        return pipeline.run(instruction).then(function(result) {
          return processResult(instruction, result, instructionCount, _this10);
        })['catch'](function(error) {
          return {output: error instanceof Error ? error : new Error(error)};
        }).then(function(result) {
          return resolveInstruction(instruction, result, !!instructionCount, _this10);
        });
      });
    };
    AppRouter.prototype._findViewModel = function _findViewModel(viewPort) {
      if (this.container.viewModel) {
        return this.container.viewModel;
      }
      if (viewPort.container) {
        var container = viewPort.container;
        while (container) {
          if (container.viewModel) {
            this.container.viewModel = container.viewModel;
            return container.viewModel;
          }
          container = container.parent;
        }
      }
    };
    return AppRouter;
  })(Router);
  exports.AppRouter = AppRouter;
  function processResult(instruction, result, instructionCount, router) {
    if (!(result && 'completed' in result && 'output' in result)) {
      result = result || {};
      result.output = new Error('Expected router pipeline to return a navigation result, but got [' + JSON.stringify(result) + '] instead.');
    }
    var finalResult = null;
    if (isNavigationCommand(result.output)) {
      result.output.navigate(router);
    } else {
      finalResult = result;
      if (!result.completed) {
        if (result.output instanceof Error) {
          logger.error(result.output);
        }
        restorePreviousLocation(router);
      }
    }
    return router._dequeueInstruction(instructionCount + 1).then(function(innerResult) {
      return finalResult || innerResult || result;
    });
  }
  function resolveInstruction(instruction, result, isInnerInstruction, router) {
    instruction.resolve(result);
    if (!isInnerInstruction) {
      router.isNavigating = false;
      var eventArgs = {
        instruction: instruction,
        result: result
      };
      var eventName = undefined;
      if (result.output instanceof Error) {
        eventName = 'error';
      } else if (!result.completed) {
        eventName = 'canceled';
      } else {
        var _queryString = instruction.queryString ? '?' + instruction.queryString : '';
        router.history.previousLocation = instruction.fragment + _queryString;
        eventName = 'success';
      }
      router.events.publish('router:navigation:' + eventName, eventArgs);
      router.events.publish('router:navigation:complete', eventArgs);
    }
    return result;
  }
  function restorePreviousLocation(router) {
    var previousLocation = router.history.previousLocation;
    if (previousLocation) {
      router.navigate(router.history.previousLocation, {
        trigger: false,
        replace: true
      });
    } else {
      logger.error('Router navigation failed, and no previous location could be restored.');
    }
  }
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-router@1.0.0-beta.1.0.1", ["npm:aurelia-router@1.0.0-beta.1.0.1/aurelia-router"], function(main) {
  return main;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-router@1.0.0-beta.1.0.5/route-loader", ["exports", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-router@1.0.0-beta.1.0.1", "npm:aurelia-path@1.0.0-beta.1", "npm:aurelia-metadata@1.0.0-beta.1"], function(exports, _aureliaDependencyInjection, _aureliaTemplating, _aureliaRouter, _aureliaPath, _aureliaMetadata) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== 'function' && superClass !== null) {
      throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  }
  var TemplatingRouteLoader = (function(_RouteLoader) {
    _inherits(TemplatingRouteLoader, _RouteLoader);
    function TemplatingRouteLoader(compositionEngine) {
      _classCallCheck(this, _TemplatingRouteLoader);
      _RouteLoader.call(this);
      this.compositionEngine = compositionEngine;
    }
    TemplatingRouteLoader.prototype.loadRoute = function loadRoute(router, config) {
      var childContainer = router.container.createChild();
      var instruction = {
        viewModel: _aureliaPath.relativeToFile(config.moduleId, _aureliaMetadata.Origin.get(router.container.viewModel.constructor).moduleId),
        childContainer: childContainer,
        view: config.view || config.viewStrategy,
        router: router
      };
      childContainer.getChildRouter = function() {
        var childRouter = undefined;
        childContainer.registerHandler(_aureliaRouter.Router, function(c) {
          return childRouter || (childRouter = router.createChild(childContainer));
        });
        return childContainer.get(_aureliaRouter.Router);
      };
      return this.compositionEngine.ensureViewModel(instruction);
    };
    var _TemplatingRouteLoader = TemplatingRouteLoader;
    TemplatingRouteLoader = _aureliaDependencyInjection.inject(_aureliaTemplating.CompositionEngine)(TemplatingRouteLoader) || TemplatingRouteLoader;
    return TemplatingRouteLoader;
  })(_aureliaRouter.RouteLoader);
  exports.TemplatingRouteLoader = TemplatingRouteLoader;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-router@1.0.0-beta.1.0.5/router-view", ["exports", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-router@1.0.0-beta.1.0.1", "npm:aurelia-metadata@1.0.0-beta.1", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(exports, _aureliaDependencyInjection, _aureliaTemplating, _aureliaRouter, _aureliaMetadata, _aureliaPal) {
  'use strict';
  exports.__esModule = true;
  var _createDecoratedClass = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === 'function') {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        Object.defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  function _defineDecoratedPropertyDescriptor(target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor)
      return;
    var descriptor = {};
    for (var _key in _descriptor)
      descriptor[_key] = _descriptor[_key];
    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var SwapStrategies = (function() {
    function SwapStrategies() {
      _classCallCheck(this, SwapStrategies);
    }
    SwapStrategies.prototype.before = function before(viewSlot, previousView, callback) {
      var promise = Promise.resolve(callback());
      if (previousView !== undefined) {
        return promise.then(function() {
          return viewSlot.remove(previousView, true);
        });
      }
      return promise;
    };
    SwapStrategies.prototype['with'] = function _with(viewSlot, previousView, callback) {
      var promise = Promise.resolve(callback());
      if (previousView !== undefined) {
        return Promise.all([viewSlot.remove(previousView, true), promise]);
      }
      return promise;
    };
    SwapStrategies.prototype.after = function after(viewSlot, previousView, callback) {
      return Promise.resolve(viewSlot.removeAll(true)).then(callback);
    };
    return SwapStrategies;
  })();
  var swapStrategies = new SwapStrategies();
  var RouterView = (function() {
    var _instanceInitializers = {};
    _createDecoratedClass(RouterView, [{
      key: 'swapOrder',
      decorators: [_aureliaTemplating.bindable],
      initializer: null,
      enumerable: true
    }], null, _instanceInitializers);
    function RouterView(element, container, viewSlot, router, viewLocator) {
      _classCallCheck(this, _RouterView);
      _defineDecoratedPropertyDescriptor(this, 'swapOrder', _instanceInitializers);
      this.element = element;
      this.container = container;
      this.viewSlot = viewSlot;
      this.router = router;
      this.viewLocator = viewLocator;
      this.router.registerViewPort(this, this.element.getAttribute('name'));
    }
    RouterView.prototype.created = function created(owningView) {
      this.owningView = owningView;
    };
    RouterView.prototype.bind = function bind(bindingContext, overrideContext) {
      this.container.viewModel = bindingContext;
      this.overrideContext = overrideContext;
    };
    RouterView.prototype.process = function process(viewPortInstruction, waitToSwap) {
      var _this = this;
      var component = viewPortInstruction.component;
      var childContainer = component.childContainer;
      var viewModel = component.viewModel;
      var viewModelResource = component.viewModelResource;
      var metadata = viewModelResource.metadata;
      var viewStrategy = this.viewLocator.getViewStrategy(component.view || viewModel);
      if (viewStrategy) {
        viewStrategy.makeRelativeTo(_aureliaMetadata.Origin.get(component.router.container.viewModel.constructor).moduleId);
      }
      return metadata.load(childContainer, viewModelResource.value, null, viewStrategy, true).then(function(viewFactory) {
        viewPortInstruction.controller = metadata.create(childContainer, _aureliaTemplating.BehaviorInstruction.dynamic(_this.element, viewModel, viewFactory));
        if (waitToSwap) {
          return;
        }
        _this.swap(viewPortInstruction);
      });
    };
    RouterView.prototype.swap = function swap(viewPortInstruction) {
      var _this2 = this;
      var previousView = this.view;
      var viewSlot = this.viewSlot;
      var swapStrategy = undefined;
      swapStrategy = this.swapOrder in swapStrategies ? swapStrategies[this.swapOrder] : swapStrategies.after;
      swapStrategy(viewSlot, previousView, function() {
        viewPortInstruction.controller.automate(_this2.overrideContext, _this2.owningView);
        return viewSlot.add(viewPortInstruction.controller.view);
      });
      this.view = viewPortInstruction.controller.view;
    };
    var _RouterView = RouterView;
    RouterView = _aureliaDependencyInjection.inject(_aureliaPal.DOM.Element, _aureliaDependencyInjection.Container, _aureliaTemplating.ViewSlot, _aureliaRouter.Router, _aureliaTemplating.ViewLocator)(RouterView) || RouterView;
    RouterView = _aureliaTemplating.noView(RouterView) || RouterView;
    RouterView = _aureliaTemplating.customElement('router-view')(RouterView) || RouterView;
    return RouterView;
  })();
  exports.RouterView = RouterView;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-router@1.0.0-beta.1.0.5/route-href", ["exports", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-router@1.0.0-beta.1.0.1", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-logging@1.0.0-beta.1.1.1"], function(exports, _aureliaTemplating, _aureliaDependencyInjection, _aureliaRouter, _aureliaPal, _aureliaLogging) {
  'use strict';
  exports.__esModule = true;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var logger = _aureliaLogging.getLogger('route-href');
  var RouteHref = (function() {
    function RouteHref(router, element) {
      _classCallCheck(this, _RouteHref);
      this.router = router;
      this.element = element;
    }
    RouteHref.prototype.bind = function bind() {
      this.isActive = true;
      this.processChange();
    };
    RouteHref.prototype.unbind = function unbind() {
      this.isActive = false;
    };
    RouteHref.prototype.attributeChanged = function attributeChanged(value, previous) {
      if (previous) {
        this.element.removeAttribute(previous);
      }
      this.processChange();
    };
    RouteHref.prototype.processChange = function processChange() {
      var _this = this;
      return this.router.ensureConfigured().then(function() {
        if (!_this.isActive) {
          return;
        }
        var href = _this.router.generate(_this.route, _this.params);
        _this.element.setAttribute(_this.attribute, href);
      })['catch'](function(reason) {
        logger.error(reason);
      });
    };
    var _RouteHref = RouteHref;
    RouteHref = _aureliaDependencyInjection.inject(_aureliaRouter.Router, _aureliaPal.DOM.Element)(RouteHref) || RouteHref;
    RouteHref = _aureliaTemplating.bindable({
      name: 'attribute',
      defaultValue: 'href'
    })(RouteHref) || RouteHref;
    RouteHref = _aureliaTemplating.bindable({
      name: 'params',
      changeHandler: 'processChange'
    })(RouteHref) || RouteHref;
    RouteHref = _aureliaTemplating.bindable({
      name: 'route',
      changeHandler: 'processChange'
    })(RouteHref) || RouteHref;
    RouteHref = _aureliaTemplating.customAttribute('route-href')(RouteHref) || RouteHref;
    return RouteHref;
  })();
  exports.RouteHref = RouteHref;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-router@1.0.0-beta.1.0.5/aurelia-templating-router", ["exports", "npm:aurelia-router@1.0.0-beta.1.0.1", "npm:aurelia-templating-router@1.0.0-beta.1.0.5/route-loader", "npm:aurelia-templating-router@1.0.0-beta.1.0.5/router-view", "npm:aurelia-templating-router@1.0.0-beta.1.0.5/route-href"], function(exports, _aureliaRouter, _routeLoader, _routerView, _routeHref) {
  'use strict';
  exports.__esModule = true;
  function configure(config) {
    config.singleton(_aureliaRouter.RouteLoader, _routeLoader.TemplatingRouteLoader).singleton(_aureliaRouter.Router, _aureliaRouter.AppRouter).globalResources('./router-view', './route-href');
    config.container.registerAlias(_aureliaRouter.Router, _aureliaRouter.AppRouter);
  }
  exports.TemplatingRouteLoader = _routeLoader.TemplatingRouteLoader;
  exports.RouterView = _routerView.RouterView;
  exports.RouteHref = _routeHref.RouteHref;
  exports.configure = configure;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-templating-router@1.0.0-beta.1.0.5", ["npm:aurelia-templating-router@1.0.0-beta.1.0.5/aurelia-templating-router"], function(main) {
  return main;
});

_removeDefine();
})();
System.registerDynamic("github:ajaxorg/ace-builds@1.2.3/ace", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, "ace", null);
  (function() {
    "format global";
    "exports ace";
    (function() {
      var ACE_NAMESPACE = "ace";
      var global = (function() {
        return this;
      })();
      if (!global && typeof window != "undefined")
        global = window;
      if (!ACE_NAMESPACE && typeof requirejs !== "undefined")
        return;
      var define = function(module, deps, payload) {
        if (typeof module !== "string") {
          if (define.original)
            define.original.apply(this, arguments);
          else {
            console.error("dropping module because define wasn\'t a string.");
            console.trace();
          }
          return;
        }
        if (arguments.length == 2)
          payload = deps;
        if (!define.modules[module]) {
          define.payloads[module] = payload;
          define.modules[module] = null;
        }
      };
      define.modules = {};
      define.payloads = {};
      var _require = function(parentId, module, callback) {
        if (typeof module === "string") {
          var payload = lookup(parentId, module);
          if (payload != undefined) {
            callback && callback();
            return payload;
          }
        } else if (Object.prototype.toString.call(module) === "[object Array]") {
          var params = [];
          for (var i = 0,
              l = module.length; i < l; ++i) {
            var dep = lookup(parentId, module[i]);
            if (dep == undefined && require.original)
              return;
            params.push(dep);
          }
          return callback && callback.apply(null, params) || true;
        }
      };
      var require = function(module, callback) {
        var packagedModule = _require("", module, callback);
        if (packagedModule == undefined && require.original)
          return require.original.apply(this, arguments);
        return packagedModule;
      };
      var normalizeModule = function(parentId, moduleName) {
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };
      var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module = define.modules[moduleName];
        if (!module) {
          module = define.payloads[moduleName];
          if (typeof module === 'function') {
            var exports = {};
            var mod = {
              id: moduleName,
              uri: '',
              exports: exports,
              packaged: true
            };
            var req = function(module, callback) {
              return _require(moduleName, module, callback);
            };
            var returnValue = module(req, exports, mod);
            exports = returnValue || mod.exports;
            define.modules[moduleName] = exports;
            delete define.payloads[moduleName];
          }
          module = define.modules[moduleName] = exports || module;
        }
        return module;
      };
      function exportAce(ns) {
        var root = global;
        if (ns) {
          if (!global[ns])
            global[ns] = {};
          root = global[ns];
        }
        if (!root.define || !root.define.packaged) {
          define.original = root.define;
          root.define = define;
          root.define.packaged = true;
        }
        if (!root.require || !root.require.packaged) {
          require.original = root.require;
          root.require = require;
          root.require.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/regexp", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var real = {
        exec: RegExp.prototype.exec,
        test: RegExp.prototype.test,
        match: String.prototype.match,
        replace: String.prototype.replace,
        split: String.prototype.split
      },
          compliantExecNpcg = real.exec.call(/()??/, "")[1] === undefined,
          compliantLastIndexIncrement = function() {
            var x = /^/g;
            real.test.call(x, "");
            return !x.lastIndex;
          }();
      if (compliantLastIndexIncrement && compliantExecNpcg)
        return;
      RegExp.prototype.exec = function(str) {
        var match = real.exec.apply(this, arguments),
            name,
            r2;
        if (typeof(str) == 'string' && match) {
          if (!compliantExecNpcg && match.length > 1 && indexOf(match, "") > -1) {
            r2 = RegExp(this.source, real.replace.call(getNativeFlags(this), "g", ""));
            real.replace.call(str.slice(match.index), r2, function() {
              for (var i = 1; i < arguments.length - 2; i++) {
                if (arguments[i] === undefined)
                  match[i] = undefined;
              }
            });
          }
          if (this._xregexp && this._xregexp.captureNames) {
            for (var i = 1; i < match.length; i++) {
              name = this._xregexp.captureNames[i - 1];
              if (name)
                match[name] = match[i];
            }
          }
          if (!compliantLastIndexIncrement && this.global && !match[0].length && (this.lastIndex > match.index))
            this.lastIndex--;
        }
        return match;
      };
      if (!compliantLastIndexIncrement) {
        RegExp.prototype.test = function(str) {
          var match = real.exec.call(this, str);
          if (match && this.global && !match[0].length && (this.lastIndex > match.index))
            this.lastIndex--;
          return !!match;
        };
      }
      function getNativeFlags(regex) {
        return (regex.global ? "g" : "") + (regex.ignoreCase ? "i" : "") + (regex.multiline ? "m" : "") + (regex.extended ? "x" : "") + (regex.sticky ? "y" : "");
      }
      function indexOf(array, item, from) {
        if (Array.prototype.indexOf)
          return array.indexOf(item, from);
        for (var i = from || 0; i < array.length; i++) {
          if (array[i] === item)
            return i;
        }
        return -1;
      }
    });
    ace.define("ace/lib/es5-shim", ["require", "exports", "module"], function(require, exports, module) {
      function Empty() {}
      if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {
          var target = this;
          if (typeof target != "function") {
            throw new TypeError("Function.prototype.bind called on incompatible " + target);
          }
          var args = slice.call(arguments, 1);
          var bound = function() {
            if (this instanceof bound) {
              var result = target.apply(this, args.concat(slice.call(arguments)));
              if (Object(result) === result) {
                return result;
              }
              return this;
            } else {
              return target.apply(that, args.concat(slice.call(arguments)));
            }
          };
          if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            Empty.prototype = null;
          }
          return bound;
        };
      }
      var call = Function.prototype.call;
      var prototypeOfArray = Array.prototype;
      var prototypeOfObject = Object.prototype;
      var slice = prototypeOfArray.slice;
      var _toString = call.bind(prototypeOfObject.toString);
      var owns = call.bind(prototypeOfObject.hasOwnProperty);
      var defineGetter;
      var defineSetter;
      var lookupGetter;
      var lookupSetter;
      var supportsAccessors;
      if ((supportsAccessors = owns(prototypeOfObject, "__defineGetter__"))) {
        defineGetter = call.bind(prototypeOfObject.__defineGetter__);
        defineSetter = call.bind(prototypeOfObject.__defineSetter__);
        lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
        lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
      }
      if ([1, 2].splice(0).length != 2) {
        if (function() {
          function makeArray(l) {
            var a = new Array(l + 2);
            a[0] = a[1] = 0;
            return a;
          }
          var array = [],
              lengthBefore;
          array.splice.apply(array, makeArray(20));
          array.splice.apply(array, makeArray(26));
          lengthBefore = array.length;
          array.splice(5, 0, "XXX");
          lengthBefore + 1 == array.length;
          if (lengthBefore + 1 == array.length) {
            return true;
          }
        }()) {
          var array_splice = Array.prototype.splice;
          Array.prototype.splice = function(start, deleteCount) {
            if (!arguments.length) {
              return [];
            } else {
              return array_splice.apply(this, [start === void 0 ? 0 : start, deleteCount === void 0 ? (this.length - start) : deleteCount].concat(slice.call(arguments, 2)));
            }
          };
        } else {
          Array.prototype.splice = function(pos, removeCount) {
            var length = this.length;
            if (pos > 0) {
              if (pos > length)
                pos = length;
            } else if (pos == void 0) {
              pos = 0;
            } else if (pos < 0) {
              pos = Math.max(length + pos, 0);
            }
            if (!(pos + removeCount < length))
              removeCount = length - pos;
            var removed = this.slice(pos, pos + removeCount);
            var insert = slice.call(arguments, 2);
            var add = insert.length;
            if (pos === length) {
              if (add) {
                this.push.apply(this, insert);
              }
            } else {
              var remove = Math.min(removeCount, length - pos);
              var tailOldPos = pos + remove;
              var tailNewPos = tailOldPos + add - remove;
              var tailCount = length - tailOldPos;
              var lengthAfterRemove = length - remove;
              if (tailNewPos < tailOldPos) {
                for (var i = 0; i < tailCount; ++i) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              } else if (tailNewPos > tailOldPos) {
                for (i = tailCount; i--; ) {
                  this[tailNewPos + i] = this[tailOldPos + i];
                }
              }
              if (add && pos === lengthAfterRemove) {
                this.length = lengthAfterRemove;
                this.push.apply(this, insert);
              } else {
                this.length = lengthAfterRemove + add;
                for (i = 0; i < add; ++i) {
                  this[pos + i] = insert[i];
                }
              }
            }
            return removed;
          };
        }
      }
      if (!Array.isArray) {
        Array.isArray = function isArray(obj) {
          return _toString(obj) == "[object Array]";
        };
      }
      var boxedString = Object("a"),
          splitString = boxedString[0] != "a" || !(0 in boxedString);
      if (!Array.prototype.forEach) {
        Array.prototype.forEach = function forEach(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              thisp = arguments[1],
              i = -1,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError();
          }
          while (++i < length) {
            if (i in self) {
              fun.call(thisp, self[i], i, object);
            }
          }
        };
      }
      if (!Array.prototype.map) {
        Array.prototype.map = function map(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              result = Array(length),
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self)
              result[i] = fun.call(thisp, self[i], i, object);
          }
          return result;
        };
      }
      if (!Array.prototype.filter) {
        Array.prototype.filter = function filter(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              result = [],
              value,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self) {
              value = self[i];
              if (fun.call(thisp, value, i, object)) {
                result.push(value);
              }
            }
          }
          return result;
        };
      }
      if (!Array.prototype.every) {
        Array.prototype.every = function every(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self && !fun.call(thisp, self[i], i, object)) {
              return false;
            }
          }
          return true;
        };
      }
      if (!Array.prototype.some) {
        Array.prototype.some = function some(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0,
              thisp = arguments[1];
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          for (var i = 0; i < length; i++) {
            if (i in self && fun.call(thisp, self[i], i, object)) {
              return true;
            }
          }
          return false;
        };
      }
      if (!Array.prototype.reduce) {
        Array.prototype.reduce = function reduce(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduce of empty array with no initial value");
          }
          var i = 0;
          var result;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i++];
                break;
              }
              if (++i >= length) {
                throw new TypeError("reduce of empty array with no initial value");
              }
            } while (true);
          }
          for (; i < length; i++) {
            if (i in self) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          }
          return result;
        };
      }
      if (!Array.prototype.reduceRight) {
        Array.prototype.reduceRight = function reduceRight(fun) {
          var object = toObject(this),
              self = splitString && _toString(this) == "[object String]" ? this.split("") : object,
              length = self.length >>> 0;
          if (_toString(fun) != "[object Function]") {
            throw new TypeError(fun + " is not a function");
          }
          if (!length && arguments.length == 1) {
            throw new TypeError("reduceRight of empty array with no initial value");
          }
          var result,
              i = length - 1;
          if (arguments.length >= 2) {
            result = arguments[1];
          } else {
            do {
              if (i in self) {
                result = self[i--];
                break;
              }
              if (--i < 0) {
                throw new TypeError("reduceRight of empty array with no initial value");
              }
            } while (true);
          }
          do {
            if (i in this) {
              result = fun.call(void 0, result, self[i], i, object);
            }
          } while (i--);
          return result;
        };
      }
      if (!Array.prototype.indexOf || ([0, 1].indexOf(1, 2) != -1)) {
        Array.prototype.indexOf = function indexOf(sought) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
              length = self.length >>> 0;
          if (!length) {
            return -1;
          }
          var i = 0;
          if (arguments.length > 1) {
            i = toInteger(arguments[1]);
          }
          i = i >= 0 ? i : Math.max(0, length + i);
          for (; i < length; i++) {
            if (i in self && self[i] === sought) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Array.prototype.lastIndexOf || ([0, 1].lastIndexOf(0, -3) != -1)) {
        Array.prototype.lastIndexOf = function lastIndexOf(sought) {
          var self = splitString && _toString(this) == "[object String]" ? this.split("") : toObject(this),
              length = self.length >>> 0;
          if (!length) {
            return -1;
          }
          var i = length - 1;
          if (arguments.length > 1) {
            i = Math.min(i, toInteger(arguments[1]));
          }
          i = i >= 0 ? i : length - Math.abs(i);
          for (; i >= 0; i--) {
            if (i in self && sought === self[i]) {
              return i;
            }
          }
          return -1;
        };
      }
      if (!Object.getPrototypeOf) {
        Object.getPrototypeOf = function getPrototypeOf(object) {
          return object.__proto__ || (object.constructor ? object.constructor.prototype : prototypeOfObject);
        };
      }
      if (!Object.getOwnPropertyDescriptor) {
        var ERR_NON_OBJECT = "Object.getOwnPropertyDescriptor called on a " + "non-object: ";
        Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {
          if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT + object);
          if (!owns(object, property))
            return;
          var descriptor,
              getter,
              setter;
          descriptor = {
            enumerable: true,
            configurable: true
          };
          if (supportsAccessors) {
            var prototype = object.__proto__;
            object.__proto__ = prototypeOfObject;
            var getter = lookupGetter(object, property);
            var setter = lookupSetter(object, property);
            object.__proto__ = prototype;
            if (getter || setter) {
              if (getter)
                descriptor.get = getter;
              if (setter)
                descriptor.set = setter;
              return descriptor;
            }
          }
          descriptor.value = object[property];
          return descriptor;
        };
      }
      if (!Object.getOwnPropertyNames) {
        Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
          return Object.keys(object);
        };
      }
      if (!Object.create) {
        var createEmpty;
        if (Object.prototype.__proto__ === null) {
          createEmpty = function() {
            return {"__proto__": null};
          };
        } else {
          createEmpty = function() {
            var empty = {};
            for (var i in empty)
              empty[i] = null;
            empty.constructor = empty.hasOwnProperty = empty.propertyIsEnumerable = empty.isPrototypeOf = empty.toLocaleString = empty.toString = empty.valueOf = empty.__proto__ = null;
            return empty;
          };
        }
        Object.create = function create(prototype, properties) {
          var object;
          if (prototype === null) {
            object = createEmpty();
          } else {
            if (typeof prototype != "object")
              throw new TypeError("typeof prototype[" + (typeof prototype) + "] != 'object'");
            var Type = function() {};
            Type.prototype = prototype;
            object = new Type();
            object.__proto__ = prototype;
          }
          if (properties !== void 0)
            Object.defineProperties(object, properties);
          return object;
        };
      }
      function doesDefinePropertyWork(object) {
        try {
          Object.defineProperty(object, "sentinel", {});
          return "sentinel" in object;
        } catch (exception) {}
      }
      if (Object.defineProperty) {
        var definePropertyWorksOnObject = doesDefinePropertyWork({});
        var definePropertyWorksOnDom = typeof document == "undefined" || doesDefinePropertyWork(document.createElement("div"));
        if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {
          var definePropertyFallback = Object.defineProperty;
        }
      }
      if (!Object.defineProperty || definePropertyFallback) {
        var ERR_NON_OBJECT_DESCRIPTOR = "Property description must be an object: ";
        var ERR_NON_OBJECT_TARGET = "Object.defineProperty called on non-object: ";
        var ERR_ACCESSORS_NOT_SUPPORTED = "getters & setters can not be defined " + "on this javascript engine";
        Object.defineProperty = function defineProperty(object, property, descriptor) {
          if ((typeof object != "object" && typeof object != "function") || object === null)
            throw new TypeError(ERR_NON_OBJECT_TARGET + object);
          if ((typeof descriptor != "object" && typeof descriptor != "function") || descriptor === null)
            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);
          if (definePropertyFallback) {
            try {
              return definePropertyFallback.call(Object, object, property, descriptor);
            } catch (exception) {}
          }
          if (owns(descriptor, "value")) {
            if (supportsAccessors && (lookupGetter(object, property) || lookupSetter(object, property))) {
              var prototype = object.__proto__;
              object.__proto__ = prototypeOfObject;
              delete object[property];
              object[property] = descriptor.value;
              object.__proto__ = prototype;
            } else {
              object[property] = descriptor.value;
            }
          } else {
            if (!supportsAccessors)
              throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);
            if (owns(descriptor, "get"))
              defineGetter(object, property, descriptor.get);
            if (owns(descriptor, "set"))
              defineSetter(object, property, descriptor.set);
          }
          return object;
        };
      }
      if (!Object.defineProperties) {
        Object.defineProperties = function defineProperties(object, properties) {
          for (var property in properties) {
            if (owns(properties, property))
              Object.defineProperty(object, property, properties[property]);
          }
          return object;
        };
      }
      if (!Object.seal) {
        Object.seal = function seal(object) {
          return object;
        };
      }
      if (!Object.freeze) {
        Object.freeze = function freeze(object) {
          return object;
        };
      }
      try {
        Object.freeze(function() {});
      } catch (exception) {
        Object.freeze = (function freeze(freezeObject) {
          return function freeze(object) {
            if (typeof object == "function") {
              return object;
            } else {
              return freezeObject(object);
            }
          };
        })(Object.freeze);
      }
      if (!Object.preventExtensions) {
        Object.preventExtensions = function preventExtensions(object) {
          return object;
        };
      }
      if (!Object.isSealed) {
        Object.isSealed = function isSealed(object) {
          return false;
        };
      }
      if (!Object.isFrozen) {
        Object.isFrozen = function isFrozen(object) {
          return false;
        };
      }
      if (!Object.isExtensible) {
        Object.isExtensible = function isExtensible(object) {
          if (Object(object) === object) {
            throw new TypeError();
          }
          var name = '';
          while (owns(object, name)) {
            name += '?';
          }
          object[name] = true;
          var returnValue = owns(object, name);
          delete object[name];
          return returnValue;
        };
      }
      if (!Object.keys) {
        var hasDontEnumBug = true,
            dontEnums = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
            dontEnumsLength = dontEnums.length;
        for (var key in {"toString": null}) {
          hasDontEnumBug = false;
        }
        Object.keys = function keys(object) {
          if ((typeof object != "object" && typeof object != "function") || object === null) {
            throw new TypeError("Object.keys called on a non-object");
          }
          var keys = [];
          for (var name in object) {
            if (owns(object, name)) {
              keys.push(name);
            }
          }
          if (hasDontEnumBug) {
            for (var i = 0,
                ii = dontEnumsLength; i < ii; i++) {
              var dontEnum = dontEnums[i];
              if (owns(object, dontEnum)) {
                keys.push(dontEnum);
              }
            }
          }
          return keys;
        };
      }
      if (!Date.now) {
        Date.now = function now() {
          return new Date().getTime();
        };
      }
      var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" + "\u2029\uFEFF";
      if (!String.prototype.trim || ws.trim()) {
        ws = "[" + ws + "]";
        var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
            trimEndRegexp = new RegExp(ws + ws + "*$");
        String.prototype.trim = function trim() {
          return String(this).replace(trimBeginRegexp, "").replace(trimEndRegexp, "");
        };
      }
      function toInteger(n) {
        n = +n;
        if (n !== n) {
          n = 0;
        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
        return n;
      }
      function isPrimitive(input) {
        var type = typeof input;
        return (input === null || type === "undefined" || type === "boolean" || type === "number" || type === "string");
      }
      function toPrimitive(input) {
        var val,
            valueOf,
            toString;
        if (isPrimitive(input)) {
          return input;
        }
        valueOf = input.valueOf;
        if (typeof valueOf === "function") {
          val = valueOf.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        toString = input.toString;
        if (typeof toString === "function") {
          val = toString.call(input);
          if (isPrimitive(val)) {
            return val;
          }
        }
        throw new TypeError();
      }
      var toObject = function(o) {
        if (o == null) {
          throw new TypeError("can't convert " + o + " to object");
        }
        return Object(o);
      };
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/regexp", "ace/lib/es5-shim"], function(require, exports, module) {
      "use strict";
      require("./regexp");
      require("./es5-shim");
    });
    ace.define("ace/lib/dom", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports.getDocumentHead = function(doc) {
        if (!doc)
          doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports.createElement = function(tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
      };
      exports.hasCssClass = function(el, name) {
        var classes = (el.className || "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports.addCssClass = function(el, name) {
        if (!exports.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g),
            add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add)
          classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports.setCssClass = function(node, className, include) {
        if (include) {
          exports.addCssClass(node, className);
        } else {
          exports.removeCssClass(node, className);
        }
      };
      exports.hasCssString = function(id, doc) {
        var index = 0,
            sheets;
        doc = doc || document;
        if (doc.createStyleSheet && (sheets = doc.styleSheets)) {
          while (index < sheets.length)
            if (sheets[index++].owningElement.id === id)
              return true;
        } else if ((sheets = doc.getElementsByTagName("style"))) {
          while (index < sheets.length)
            if (sheets[index++].id === id)
              return true;
        }
        return false;
      };
      exports.importCssString = function importCssString(cssText, id, doc) {
        doc = doc || document;
        if (id && exports.hasCssString(id, doc))
          return null;
        var style;
        if (id)
          cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        if (doc.createStyleSheet) {
          style = doc.createStyleSheet();
          style.cssText = cssText;
          if (id)
            style.owningElement.id = id;
        } else {
          style = exports.createElement("style");
          style.appendChild(doc.createTextNode(cssText));
          if (id)
            style.id = id;
          exports.getDocumentHead(doc).appendChild(style);
        }
      };
      exports.importCssStylsheet = function(uri, doc) {
        if (doc.createStyleSheet) {
          doc.createStyleSheet(uri);
        } else {
          var link = exports.createElement('link');
          link.rel = 'stylesheet';
          link.href = uri;
          exports.getDocumentHead(doc).appendChild(link);
        }
      };
      exports.getInnerWidth = function(element) {
        return (parseInt(exports.computedStyle(element, "paddingLeft"), 10) + parseInt(exports.computedStyle(element, "paddingRight"), 10) + element.clientWidth);
      };
      exports.getInnerHeight = function(element) {
        return (parseInt(exports.computedStyle(element, "paddingTop"), 10) + parseInt(exports.computedStyle(element, "paddingBottom"), 10) + element.clientHeight);
      };
      exports.scrollbarWidth = function(document) {
        var inner = exports.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = document.documentElement;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar == withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      if (typeof document == "undefined") {
        exports.importCssString = function() {};
        return;
      }
      if (window.pageYOffset !== undefined) {
        exports.getPageScrollTop = function() {
          return window.pageYOffset;
        };
        exports.getPageScrollLeft = function() {
          return window.pageXOffset;
        };
      } else {
        exports.getPageScrollTop = function() {
          return document.body.scrollTop;
        };
        exports.getPageScrollLeft = function() {
          return document.body.scrollLeft;
        };
      }
      if (window.getComputedStyle)
        exports.computedStyle = function(element, style) {
          if (style)
            return (window.getComputedStyle(element, "") || {})[style] || "";
          return window.getComputedStyle(element, "") || {};
        };
      else
        exports.computedStyle = function(element, style) {
          if (style)
            return element.currentStyle[style];
          return element.currentStyle;
        };
      exports.setInnerHtml = function(el, innerHtml) {
        var element = el.cloneNode(false);
        element.innerHTML = innerHtml;
        el.parentNode.replaceChild(element, el);
        return element;
      };
      if ("textContent" in document.documentElement) {
        exports.setInnerText = function(el, innerText) {
          el.textContent = innerText;
        };
        exports.getInnerText = function(el) {
          return el.textContent;
        };
      } else {
        exports.setInnerText = function(el, innerText) {
          el.innerText = innerText;
        };
        exports.getInnerText = function(el) {
          return el.innerText;
        };
      }
      exports.getParentWindow = function(document) {
        return document.defaultView || document.parentWindow;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      exports.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }});
      };
      exports.mixin = function(obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports.implement = function(proto, mixin) {
        exports.mixin(proto, mixin);
      };
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop"], function(require, exports, module) {
      "use strict";
      require("./fixoldbrowsers");
      var oop = require("./oop");
      var Keys = (function() {
        var ret = {
          MODIFIER_KEYS: {
            16: 'Shift',
            17: 'Ctrl',
            18: 'Alt',
            224: 'Meta'
          },
          KEY_MODS: {
            "ctrl": 1,
            "alt": 2,
            "option": 2,
            "shift": 4,
            "super": 8,
            "meta": 8,
            "command": 8,
            "cmd": 8
          },
          FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            96: "Numpad0",
            97: "Numpad1",
            98: "Numpad2",
            99: "Numpad3",
            100: "Numpad4",
            101: "Numpad5",
            102: "Numpad6",
            103: "Numpad7",
            104: "Numpad8",
            105: "Numpad9",
            '-13': "NumpadEnter",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "Numlock",
            145: "Scrolllock"
          },
          PRINTABLE_KEYS: {
            32: ' ',
            48: '0',
            49: '1',
            50: '2',
            51: '3',
            52: '4',
            53: '5',
            54: '6',
            55: '7',
            56: '8',
            57: '9',
            59: ';',
            61: '=',
            65: 'a',
            66: 'b',
            67: 'c',
            68: 'd',
            69: 'e',
            70: 'f',
            71: 'g',
            72: 'h',
            73: 'i',
            74: 'j',
            75: 'k',
            76: 'l',
            77: 'm',
            78: 'n',
            79: 'o',
            80: 'p',
            81: 'q',
            82: 'r',
            83: 's',
            84: 't',
            85: 'u',
            86: 'v',
            87: 'w',
            88: 'x',
            89: 'y',
            90: 'z',
            107: '+',
            109: '-',
            110: '.',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: "'",
            111: '/',
            106: '*'
          }
        };
        var name,
            i;
        for (i in ret.FUNCTION_KEYS) {
          name = ret.FUNCTION_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        for (i in ret.PRINTABLE_KEYS) {
          name = ret.PRINTABLE_KEYS[i].toLowerCase();
          ret[name] = parseInt(i, 10);
        }
        oop.mixin(ret, ret.MODIFIER_KEYS);
        oop.mixin(ret, ret.PRINTABLE_KEYS);
        oop.mixin(ret, ret.FUNCTION_KEYS);
        ret.enter = ret["return"];
        ret.escape = ret.esc;
        ret.del = ret["delete"];
        ret[173] = '-';
        (function() {
          var mods = ["cmd", "ctrl", "alt", "shift"];
          for (var i = Math.pow(2, mods.length); i--; ) {
            ret.KEY_MODS[i] = mods.filter(function(x) {
              return i & ret.KEY_MODS[x];
            }).join("-") + "-";
          }
        })();
        ret.KEY_MODS[0] = "";
        ret.KEY_MODS[-1] = "input-";
        return ret;
      })();
      oop.mixin(exports, Keys);
      exports.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
          keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      exports.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports.getOS = function() {
        if (exports.isMac) {
          return exports.OS.MAC;
        } else if (exports.isLinux) {
          return exports.OS.LINUX;
        } else {
          return exports.OS.WINDOWS;
        }
      };
      if (typeof navigator != "object")
        return;
      var os = (navigator.platform.match(/mac|win|linux/i) || ["other"])[0].toLowerCase();
      var ua = navigator.userAgent;
      exports.isWin = (os == "win");
      exports.isMac = (os == "mac");
      exports.isLinux = (os == "linux");
      exports.isIE = (navigator.appName == "Microsoft Internet Explorer" || navigator.appName.indexOf("MSAppHost") >= 0) ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
      exports.isOldIE = exports.isIE && exports.isIE < 9;
      exports.isGecko = exports.isMozilla = (window.Controllers || window.controllers) && window.navigator.product === "Gecko";
      exports.isOldGecko = exports.isGecko && parseInt((ua.match(/rv\:(\d+)/) || [])[1], 10) < 4;
      exports.isOpera = window.opera && Object.prototype.toString.call(window.opera) == "[object Opera]";
      exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
      exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
      exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports.isIPad = ua.indexOf("iPad") >= 0;
      exports.isTouchPad = ua.indexOf("TouchPad") >= 0;
      exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require, exports, module) {
      "use strict";
      var keys = require("./keys");
      var useragent = require("./useragent");
      var pressedKeys = null;
      var ts = 0;
      exports.addListener = function(elem, type, callback) {
        if (elem.addEventListener) {
          return elem.addEventListener(type, callback, false);
        }
        if (elem.attachEvent) {
          var wrapper = function() {
            callback.call(elem, window.event);
          };
          callback._wrapper = wrapper;
          elem.attachEvent("on" + type, wrapper);
        }
      };
      exports.removeListener = function(elem, type, callback) {
        if (elem.removeEventListener) {
          return elem.removeEventListener(type, callback, false);
        }
        if (elem.detachEvent) {
          elem.detachEvent("on" + type, callback._wrapper || callback);
        }
      };
      exports.stopEvent = function(e) {
        exports.stopPropagation(e);
        exports.preventDefault(e);
        return false;
      };
      exports.stopPropagation = function(e) {
        if (e.stopPropagation)
          e.stopPropagation();
        else
          e.cancelBubble = true;
      };
      exports.preventDefault = function(e) {
        if (e.preventDefault)
          e.preventDefault();
        else
          e.returnValue = false;
      };
      exports.getButton = function(e) {
        if (e.type == "dblclick")
          return 0;
        if (e.type == "contextmenu" || (useragent.isMac && (e.ctrlKey && !e.altKey && !e.shiftKey)))
          return 2;
        if (e.preventDefault) {
          return e.button;
        } else {
          return {
            1: 0,
            2: 2,
            4: 1
          }[e.button];
        }
      };
      exports.capture = function(el, eventHandler, releaseCaptureHandler) {
        function onMouseUp(e) {
          eventHandler && eventHandler(e);
          releaseCaptureHandler && releaseCaptureHandler(e);
          exports.removeListener(document, "mousemove", eventHandler, true);
          exports.removeListener(document, "mouseup", onMouseUp, true);
          exports.removeListener(document, "dragstart", onMouseUp, true);
        }
        exports.addListener(document, "mousemove", eventHandler, true);
        exports.addListener(document, "mouseup", onMouseUp, true);
        exports.addListener(document, "dragstart", onMouseUp, true);
        return onMouseUp;
      };
      exports.addTouchMoveListener = function(el, callback) {
        if ("ontouchmove" in el) {
          var startx,
              starty;
          exports.addListener(el, "touchstart", function(e) {
            var touchObj = e.changedTouches[0];
            startx = touchObj.clientX;
            starty = touchObj.clientY;
          });
          exports.addListener(el, "touchmove", function(e) {
            var factor = 1,
                touchObj = e.changedTouches[0];
            e.wheelX = -(touchObj.clientX - startx) / factor;
            e.wheelY = -(touchObj.clientY - starty) / factor;
            startx = touchObj.clientX;
            starty = touchObj.clientY;
            callback(e);
          });
        }
      };
      exports.addMouseWheelListener = function(el, callback) {
        if ("onmousewheel" in el) {
          exports.addListener(el, "mousewheel", function(e) {
            var factor = 8;
            if (e.wheelDeltaX !== undefined) {
              e.wheelX = -e.wheelDeltaX / factor;
              e.wheelY = -e.wheelDeltaY / factor;
            } else {
              e.wheelX = 0;
              e.wheelY = -e.wheelDelta / factor;
            }
            callback(e);
          });
        } else if ("onwheel" in el) {
          exports.addListener(el, "wheel", function(e) {
            var factor = 0.35;
            switch (e.deltaMode) {
              case e.DOM_DELTA_PIXEL:
                e.wheelX = e.deltaX * factor || 0;
                e.wheelY = e.deltaY * factor || 0;
                break;
              case e.DOM_DELTA_LINE:
              case e.DOM_DELTA_PAGE:
                e.wheelX = (e.deltaX || 0) * 5;
                e.wheelY = (e.deltaY || 0) * 5;
                break;
            }
            callback(e);
          });
        } else {
          exports.addListener(el, "DOMMouseScroll", function(e) {
            if (e.axis && e.axis == e.HORIZONTAL_AXIS) {
              e.wheelX = (e.detail || 0) * 5;
              e.wheelY = 0;
            } else {
              e.wheelX = 0;
              e.wheelY = (e.detail || 0) * 5;
            }
            callback(e);
          });
        }
      };
      exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName) {
        var clicks = 0;
        var startX,
            startY,
            timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        function onMousedown(e) {
          if (exports.getButton(e) !== 0) {
            clicks = 0;
          } else if (e.detail > 1) {
            clicks++;
            if (clicks > 4)
              clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
            if (!timer || isNewClick)
              clicks = 1;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e.clientX;
              startY = e.clientY;
            }
          }
          e._clicks = clicks;
          eventHandler[callbackName]("mousedown", e);
          if (clicks > 4)
            clicks = 0;
          else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e);
        }
        function onDblclick(e) {
          clicks = 2;
          if (timer)
            clearTimeout(timer);
          timer = setTimeout(function() {
            timer = null;
          }, timeouts[clicks - 1] || 600);
          eventHandler[callbackName]("mousedown", e);
          eventHandler[callbackName](eventNames[clicks], e);
        }
        if (!Array.isArray(elements))
          elements = [elements];
        elements.forEach(function(el) {
          exports.addListener(el, "mousedown", onMousedown);
          if (useragent.isOldIE)
            exports.addListener(el, "dblclick", onDblclick);
        });
      };
      var getModifierHash = useragent.isMac && useragent.isOpera && !("KeyboardEvent" in window) ? function(e) {
        return 0 | (e.metaKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.ctrlKey ? 8 : 0);
      } : function(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
      };
      exports.getModifierString = function(e) {
        return keys.KEY_MODS[getModifierHash(e)];
      };
      function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);
        if (!useragent.isMac && pressedKeys) {
          if (pressedKeys.OSKey)
            hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
              pressedKeys.altGr = 0;
            else
              return;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location = "location" in e ? e.location : e.keyLocation;
            if (keyCode === 17 && location === 1) {
              if (pressedKeys[keyCode] == 1)
                ts = e.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location === 2) {
              var dt = e.timeStamp - ts;
              if (dt < 50)
                pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          keyCode = -1;
        }
        if (hashId & 8 && (keyCode >= 91 && keyCode <= 93)) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          var location = "location" in e ? e.location : e.keyLocation;
          if (location === 3) {
            callback(e, hashId, -keyCode);
            if (e.defaultPrevented)
              return;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e, hashId, keyCode);
          if (e.defaultPrevented)
            return;
          else
            hashId &= ~8;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e, hashId, keyCode);
      }
      exports.addCommandKeyListener = function(el, callback) {
        var addListener = exports.addListener;
        if (useragent.isOldGecko || (useragent.isOpera && !("KeyboardEvent" in window))) {
          var lastKeyDownKeyCode = null;
          addListener(el, "keydown", function(e) {
            lastKeyDownKeyCode = e.keyCode;
          });
          addListener(el, "keypress", function(e) {
            return normalizeCommandKeys(callback, e, lastKeyDownKeyCode);
          });
        } else {
          var lastDefaultPrevented = null;
          addListener(el, "keydown", function(e) {
            var keyCode = e.keyCode;
            pressedKeys[keyCode] = (pressedKeys[keyCode] || 0) + 1;
            if (keyCode == 91 || keyCode == 92) {
              pressedKeys.OSKey = true;
            } else if (pressedKeys.OSKey) {
              if (e.timeStamp - pressedKeys.lastT > 200 && pressedKeys.count == 1)
                resetPressedKeys();
            }
            if (pressedKeys[keyCode] == 1)
              pressedKeys.count++;
            pressedKeys.lastT = e.timeStamp;
            var result = normalizeCommandKeys(callback, e, keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
          });
          addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
              exports.stopEvent(e);
              lastDefaultPrevented = null;
            }
          });
          addListener(el, "keyup", function(e) {
            var keyCode = e.keyCode;
            if (!pressedKeys[keyCode]) {
              resetPressedKeys();
            } else {
              pressedKeys.count = Math.max(pressedKeys.count - 1, 0);
            }
            if (keyCode == 91 || keyCode == 92) {
              pressedKeys.OSKey = false;
            }
            pressedKeys[keyCode] = null;
          });
          if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
          }
        }
      };
      function resetPressedKeys() {
        pressedKeys = Object.create(null);
        pressedKeys.count = 0;
        pressedKeys.lastT = 0;
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports.nextTick = function(callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId;
          exports.addListener(win, "message", function listener(e) {
            if (e.data == messageName) {
              exports.stopPropagation(e);
              exports.removeListener(win, "message", listener);
              callback();
            }
          });
          win.postMessage(messageName, "*");
        };
      }
      exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame);
      if (exports.nextFrame)
        exports.nextFrame = exports.nextFrame.bind(window);
      else
        exports.nextFrame = function(callback) {
          setTimeout(callback, 17);
        };
    });
    ace.define("ace/lib/lang", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      exports.last = function(a) {
        return a[a.length - 1];
      };
      exports.stringReverse = function(string) {
        return string.split("").reverse().join("");
      };
      exports.stringRepeat = function(string, count) {
        var result = '';
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, '');
      };
      exports.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, '');
      };
      exports.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports.copyArray = function(array) {
        var copy = [];
        for (var i = 0,
            l = array.length; i < l; i++) {
          if (array[i] && typeof array[i] == "object")
            copy[i] = this.copyObject(array[i]);
          else
            copy[i] = array[i];
        }
        return copy;
      };
      exports.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
          return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        var cons = obj.constructor;
        if (cons === RegExp)
          return obj;
        copy = cons();
        for (var key in obj) {
          copy[key] = deepCopy(obj[key]);
        }
        return copy;
      };
      exports.arrayToMap = function(arr) {
        var map = {};
        for (var i = 0; i < arr.length; i++) {
          map[arr[i]] = 1;
        }
        return map;
      };
      exports.createMap = function(props) {
        var map = Object.create(null);
        for (var i in props) {
          map[i] = props[i];
        }
        return map;
      };
      exports.arrayRemove = function(array, value) {
        for (var i = 0; i <= array.length; i++) {
          if (value === array[i]) {
            array.splice(i, 1);
          }
        }
      };
      exports.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, '\\$1');
      };
      exports.escapeHTML = function(str) {
        return str.replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports.getMatchOffsets = function(string, regExp) {
        var matches = [];
        string.replace(regExp, function(str) {
          matches.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches;
      };
      exports.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var deferred = function(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function() {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function() {
          return timer;
        };
        return deferred;
      };
      exports.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var _self = function(timeout) {
          if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
          this.cancel();
          fcn();
        };
        _self.cancel = function() {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function() {
          return timer;
        };
        return _self;
      };
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang"], function(require, exports, module) {
      "use strict";
      var event = require("../lib/event");
      var useragent = require("../lib/useragent");
      var dom = require("../lib/dom");
      var lang = require("../lib/lang");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        if (useragent.isTouchPad)
          text.setAttribute("x-palm-disable-auto-cap", true);
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", false);
        text.style.opacity = "0";
        if (useragent.isOldIE)
          text.style.top = "-1000px";
        parentNode.insertBefore(text, parentNode.firstChild);
        var PLACEHOLDER = "\x01\x01";
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var tempStyle = '';
        var isSelectionEmpty = true;
        try {
          var isFocused = document.activeElement === text;
        } catch (e) {}
        event.addListener(text, "blur", function(e) {
          host.onBlur(e);
          isFocused = false;
        });
        event.addListener(text, "focus", function(e) {
          isFocused = true;
          host.onFocus(e);
          resetSelection();
        });
        this.focus = function() {
          if (tempStyle)
            return text.focus();
          var top = text.style.top;
          text.style.position = "fixed";
          text.style.top = "0px";
          text.focus();
          setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
              text.style.top = top;
          }, 0);
        };
        this.blur = function() {
          text.blur();
        };
        this.isFocused = function() {
          return isFocused;
        };
        var syncSelection = lang.delayedCall(function() {
          isFocused && resetSelection(isSelectionEmpty);
        });
        var syncValue = lang.delayedCall(function() {
          if (!inComposition) {
            text.value = PLACEHOLDER;
            isFocused && resetSelection();
          }
        });
        function resetSelection(isEmpty) {
          if (inComposition)
            return;
          inComposition = true;
          if (inputHandler) {
            selectionStart = 0;
            selectionEnd = isEmpty ? 0 : text.value.length - 1;
          } else {
            var selectionStart = isEmpty ? 2 : 1;
            var selectionEnd = 2;
          }
          try {
            text.setSelectionRange(selectionStart, selectionEnd);
          } catch (e) {}
          inComposition = false;
        }
        function resetValue() {
          if (inComposition)
            return;
          text.value = PLACEHOLDER;
          if (useragent.isWebKit)
            syncValue.schedule();
        }
        useragent.isWebKit || host.addEventListener('changeSelection', function() {
          if (host.selection.isEmpty() != isSelectionEmpty) {
            isSelectionEmpty = !isSelectionEmpty;
            syncSelection.schedule();
          }
        });
        resetValue();
        if (isFocused)
          host.onFocus();
        var isAllSelected = function(text) {
          return text.selectionStart === 0 && text.selectionEnd === text.value.length;
        };
        if (!text.setSelectionRange && text.createTextRange) {
          text.setSelectionRange = function(selectionStart, selectionEnd) {
            var range = this.createTextRange();
            range.collapse(true);
            range.moveStart('character', selectionStart);
            range.moveEnd('character', selectionEnd);
            range.select();
          };
          isAllSelected = function(text) {
            try {
              var range = text.ownerDocument.selection.createRange();
            } catch (e) {}
            if (!range || range.parentElement() != text)
              return false;
            return range.text == text.value;
          };
        }
        if (useragent.isOldIE) {
          var inPropertyChange = false;
          var onPropertyChange = function(e) {
            if (inPropertyChange)
              return;
            var data = text.value;
            if (inComposition || !data || data == PLACEHOLDER)
              return;
            if (e && data == PLACEHOLDER[0])
              return syncProperty.schedule();
            sendText(data);
            inPropertyChange = true;
            resetValue();
            inPropertyChange = false;
          };
          var syncProperty = lang.delayedCall(onPropertyChange);
          event.addListener(text, "propertychange", onPropertyChange);
          var keytable = {
            13: 1,
            27: 1
          };
          event.addListener(text, "keyup", function(e) {
            if (inComposition && (!text.value || keytable[e.keyCode]))
              setTimeout(onCompositionEnd, 0);
            if ((text.value.charCodeAt(0) || 0) < 129) {
              return syncProperty.call();
            }
            inComposition ? onCompositionUpdate() : onCompositionStart();
          });
          event.addListener(text, "keydown", function(e) {
            syncProperty.schedule(50);
          });
        }
        var onSelect = function(e) {
          if (copied) {
            copied = false;
          } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (inputHandler) {
            resetSelection(host.selection.isEmpty());
          }
        };
        var inputHandler = null;
        this.setInputHandler = function(cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function() {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function(data) {
          if (inputHandler) {
            data = inputHandler(data);
            inputHandler = null;
          }
          if (pasted) {
            resetSelection();
            if (data)
              host.onPaste(data);
            pasted = false;
          } else if (data == PLACEHOLDER.charAt(0)) {
            if (afterContextMenu)
              host.execCommand("del", {source: "ace"});
            else
              host.execCommand("backspace", {source: "ace"});
          } else {
            if (data.substring(0, 2) == PLACEHOLDER)
              data = data.substr(2);
            else if (data.charAt(0) == PLACEHOLDER.charAt(0))
              data = data.substr(1);
            else if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
              data = data.slice(0, -1);
            if (data.charAt(data.length - 1) == PLACEHOLDER.charAt(0))
              data = data.slice(0, -1);
            if (data)
              host.onTextInput(data);
          }
          if (afterContextMenu)
            afterContextMenu = false;
        };
        var onInput = function(e) {
          if (inComposition)
            return;
          var data = text.value;
          sendText(data);
          resetValue();
        };
        var handleClipboardData = function(e, data) {
          var clipboardData = e.clipboardData || window.clipboardData;
          if (!clipboardData || BROKEN_SETDATA)
            return;
          var mime = USE_IE_MIME_TYPE ? "Text" : "text/plain";
          if (data) {
            return clipboardData.setData(mime, data) !== false;
          } else {
            return clipboardData.getData(mime);
          }
        };
        var doCopy = function(e, isCut) {
          var data = host.getCopyText();
          if (!data)
            return event.preventDefault(e);
          if (handleClipboardData(e, data)) {
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function() {
              copied = false;
              resetValue();
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function(e) {
          doCopy(e, true);
        };
        var onCopy = function(e) {
          doCopy(e, false);
        };
        var onPaste = function(e) {
          var data = handleClipboardData(e);
          if (typeof data == "string") {
            if (data)
              host.onPaste(data, e);
            if (useragent.isIE)
              setTimeout(resetSelection);
            event.preventDefault(e);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, host.onCommandKey.bind(host));
        event.addListener(text, "select", onSelect);
        event.addListener(text, "input", onInput);
        event.addListener(text, "cut", onCut);
        event.addListener(text, "copy", onCopy);
        event.addListener(text, "paste", onPaste);
        if (!('oncut' in text) || !('oncopy' in text) || !('onpaste' in text)) {
          event.addListener(parentNode, "keydown", function(e) {
            if ((useragent.isMac && !e.metaKey) || !e.ctrlKey)
              return;
            switch (e.keyCode) {
              case 67:
                onCopy(e);
                break;
              case 86:
                onPaste(e);
                break;
              case 88:
                onCut(e);
                break;
            }
          });
        }
        var onCompositionStart = function(e) {
          if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
          inComposition = {};
          host.onCompositionStart();
          setTimeout(onCompositionUpdate, 0);
          host.on("mousedown", onCompositionEnd);
          if (!host.selection.isEmpty()) {
            host.insert("");
            host.session.markUndoGroup();
            host.selection.clearSelection();
          }
          host.session.markUndoGroup();
        };
        var onCompositionUpdate = function() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
          var val = text.value.replace(/\x01/g, "");
          if (inComposition.lastValue === val)
            return;
          host.onCompositionUpdate(val);
          if (inComposition.lastValue)
            host.undo();
          inComposition.lastValue = val;
          if (inComposition.lastValue) {
            var r = host.selection.getRange();
            host.insert(inComposition.lastValue);
            host.session.markUndoGroup();
            inComposition.range = host.selection.getRange();
            host.selection.setRange(r);
            host.selection.clearSelection();
          }
        };
        var onCompositionEnd = function(e) {
          if (!host.onCompositionEnd || host.$readOnly)
            return;
          var c = inComposition;
          inComposition = false;
          var timer = setTimeout(function() {
            timer = null;
            var str = text.value.replace(/\x01/g, "");
            if (inComposition)
              return;
            else if (str == c.lastValue)
              resetValue();
            else if (!c.lastValue && str) {
              resetValue();
              sendText(str);
            }
          });
          inputHandler = function compositionInputHandler(str) {
            if (timer)
              clearTimeout(timer);
            str = str.replace(/\x01/g, "");
            if (str == c.lastValue)
              return "";
            if (c.lastValue && timer)
              host.undo();
            return str;
          };
          host.onCompositionEnd();
          host.removeListener("mousedown", onCompositionEnd);
          if (e.type == "compositionend" && c.range) {
            host.selection.setRange(c.range);
          }
        };
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50);
        event.addListener(text, "compositionstart", onCompositionStart);
        if (useragent.isGecko) {
          event.addListener(text, "text", function() {
            syncComposition.schedule();
          });
        } else {
          event.addListener(text, "keyup", function() {
            syncComposition.schedule();
          });
          event.addListener(text, "keydown", function() {
            syncComposition.schedule();
          });
        }
        event.addListener(text, "compositionend", onCompositionEnd);
        this.getElement = function() {
          return text;
        };
        this.setReadOnly = function(readOnly) {
          text.readOnly = readOnly;
        };
        this.onContextMenu = function(e) {
          afterContextMenu = true;
          resetSelection(host.selection.isEmpty());
          host._emit("nativecontextmenu", {
            target: host,
            domEvent: e
          });
          this.moveToMouse(e, true);
        };
        this.moveToMouse = function(e, bringToFront) {
          if (!bringToFront && useragent.isOldIE)
            return;
          if (!tempStyle)
            tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + "height:" + text.style.height + ";" + (useragent.isIE ? "opacity:0.1;" : "");
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(rect.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function(e) {
            text.style.left = e.clientX - left - 2 + "px";
            text.style.top = Math.min(e.clientY - top - 2, maxTop) + "px";
          };
          move(e);
          if (e.type != "mousedown")
            return;
          if (host.renderer.$keepTextAreaAtCursor)
            host.renderer.$keepTextAreaAtCursor = null;
          clearTimeout(closeTimeout);
          if (useragent.isWin && !useragent.isOldIE)
            event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function() {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = '';
            }
            if (host.renderer.$keepTextAreaAtCursor == null) {
              host.renderer.$keepTextAreaAtCursor = true;
              host.renderer.$moveTextAreaToCursor();
            }
          }, useragent.isOldIE ? 200 : 0);
        }
        var onContextMenu = function(e) {
          host.textInput.onContextMenu(e);
          onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu);
        event.addListener(text, "mousedown", function(e) {
          e.preventDefault();
          onContextMenuClose();
        });
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu);
        event.addListener(text, "contextmenu", onContextMenu);
      };
      exports.TextInput = TextInput;
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require, exports, module) {
      "use strict";
      var dom = require("../lib/dom");
      var event = require("../lib/event");
      var useragent = require("../lib/useragent");
      var DRAG_OFFSET = 0;
      function DefaultHandlers(mouseHandler) {
        mouseHandler.$clickSelection = null;
        var editor = mouseHandler.editor;
        editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
        editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
        editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
        editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
        editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
        editor.setDefaultHandler("touchmove", this.onTouchMove.bind(mouseHandler));
        var exports = ["select", "startSelect", "selectEnd", "selectAllEnd", "selectByWordsEnd", "selectByLinesEnd", "dragWait", "dragWaitEnd", "focusWait"];
        exports.forEach(function(x) {
          mouseHandler[x] = this[x];
        }, this);
        mouseHandler.selectByLines = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
        mouseHandler.selectByWords = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
      }
      (function() {
        this.onMouseDown = function(ev) {
          var inSelection = ev.inSelection();
          var pos = ev.getDocumentPosition();
          this.mousedownEvent = ev;
          var editor = this.editor;
          var button = ev.getButton();
          if (button !== 0) {
            var selectionRange = editor.getSelectionRange();
            var selectionEmpty = selectionRange.isEmpty();
            editor.$blockScrolling++;
            if (selectionEmpty || button == 1)
              editor.selection.moveToPosition(pos);
            editor.$blockScrolling--;
            if (button == 2)
              editor.textInput.onContextMenu(ev.domEvent);
            return;
          }
          this.mousedownEvent.time = Date.now();
          if (inSelection && !editor.isFocused()) {
            editor.focus();
            if (this.$focusTimout && !this.$clickSelection && !editor.inMultiSelectMode) {
              this.setState("focusWait");
              this.captureMouse(ev);
              return;
            }
          }
          this.captureMouse(ev);
          this.startSelect(pos, ev.domEvent._clicks > 1);
          return ev.preventDefault();
        };
        this.startSelect = function(pos, waitForClickSelection) {
          pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
          var editor = this.editor;
          editor.$blockScrolling++;
          if (this.mousedownEvent.getShiftKey())
            editor.selection.selectToPosition(pos);
          else if (!waitForClickSelection)
            editor.selection.moveToPosition(pos);
          if (!waitForClickSelection)
            this.select();
          if (editor.renderer.scroller.setCapture) {
            editor.renderer.scroller.setCapture();
          }
          editor.setStyle("ace_selecting");
          this.setState("select");
          editor.$blockScrolling--;
        };
        this.select = function() {
          var anchor,
              editor = this.editor;
          var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
          editor.$blockScrolling++;
          if (this.$clickSelection) {
            var cmp = this.$clickSelection.comparePoint(cursor);
            if (cmp == -1) {
              anchor = this.$clickSelection.end;
            } else if (cmp == 1) {
              anchor = this.$clickSelection.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor.selection.selectToPosition(cursor);
          editor.$blockScrolling--;
          editor.renderer.scrollCursorIntoView();
        };
        this.extendSelectionBy = function(unitName) {
          var anchor,
              editor = this.editor;
          var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
          var range = editor.selection[unitName](cursor.row, cursor.column);
          editor.$blockScrolling++;
          if (this.$clickSelection) {
            var cmpStart = this.$clickSelection.comparePoint(range.start);
            var cmpEnd = this.$clickSelection.comparePoint(range.end);
            if (cmpStart == -1 && cmpEnd <= 0) {
              anchor = this.$clickSelection.end;
              if (range.end.row != cursor.row || range.end.column != cursor.column)
                cursor = range.start;
            } else if (cmpEnd == 1 && cmpStart >= 0) {
              anchor = this.$clickSelection.start;
              if (range.start.row != cursor.row || range.start.column != cursor.column)
                cursor = range.end;
            } else if (cmpStart == -1 && cmpEnd == 1) {
              cursor = range.end;
              anchor = range.start;
            } else {
              var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
              cursor = orientedRange.cursor;
              anchor = orientedRange.anchor;
            }
            editor.selection.setSelectionAnchor(anchor.row, anchor.column);
          }
          editor.selection.selectToPosition(cursor);
          editor.$blockScrolling--;
          editor.renderer.scrollCursorIntoView();
        };
        this.selectEnd = this.selectAllEnd = this.selectByWordsEnd = this.selectByLinesEnd = function() {
          this.$clickSelection = null;
          this.editor.unsetStyle("ace_selecting");
          if (this.editor.renderer.scroller.releaseCapture) {
            this.editor.renderer.scroller.releaseCapture();
          }
        };
        this.focusWait = function() {
          var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          var time = Date.now();
          if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimout)
            this.startSelect(this.mousedownEvent.getDocumentPosition());
        };
        this.onDoubleClick = function(ev) {
          var pos = ev.getDocumentPosition();
          var editor = this.editor;
          var session = editor.session;
          var range = session.getBracketRange(pos);
          if (range) {
            if (range.isEmpty()) {
              range.start.column--;
              range.end.column++;
            }
            this.setState("select");
          } else {
            range = editor.selection.getWordRange(pos.row, pos.column);
            this.setState("selectByWords");
          }
          this.$clickSelection = range;
          this.select();
        };
        this.onTripleClick = function(ev) {
          var pos = ev.getDocumentPosition();
          var editor = this.editor;
          this.setState("selectByLines");
          var range = editor.getSelectionRange();
          if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
            this.$clickSelection = editor.selection.getLineRange(range.start.row);
            this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
          } else {
            this.$clickSelection = editor.selection.getLineRange(pos.row);
          }
          this.select();
        };
        this.onQuadClick = function(ev) {
          var editor = this.editor;
          editor.selectAll();
          this.$clickSelection = editor.getSelectionRange();
          this.setState("selectAll");
        };
        this.onMouseWheel = function(ev) {
          if (ev.getAccelKey())
            return;
          if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
            ev.wheelX = ev.wheelY;
            ev.wheelY = 0;
          }
          var t = ev.domEvent.timeStamp;
          var dt = t - (this.$lastScrollTime || 0);
          var editor = this.editor;
          var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
          if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
          }
        };
        this.onTouchMove = function(ev) {
          var t = ev.domEvent.timeStamp;
          var dt = t - (this.$lastScrollTime || 0);
          var editor = this.editor;
          var isScrolable = editor.renderer.isScrollableBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
          if (isScrolable || dt < 200) {
            this.$lastScrollTime = t;
            editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
            return ev.stop();
          }
        };
      }).call(DefaultHandlers.prototype);
      exports.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
          var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
          var cmp = cursor.column - 4;
        else
          var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0)
          return {
            cursor: range.start,
            anchor: range.end
          };
        else
          return {
            cursor: range.end,
            anchor: range.start
          };
      }
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var dom = require("./lib/dom");
      function Tooltip(parentNode) {
        this.isOpen = false;
        this.$element = null;
        this.$parentNode = parentNode;
      }
      (function() {
        this.$init = function() {
          this.$element = dom.createElement("div");
          this.$element.className = "ace_tooltip";
          this.$element.style.display = "none";
          this.$parentNode.appendChild(this.$element);
          return this.$element;
        };
        this.getElement = function() {
          return this.$element || this.$init();
        };
        this.setText = function(text) {
          dom.setInnerText(this.getElement(), text);
        };
        this.setHtml = function(html) {
          this.getElement().innerHTML = html;
        };
        this.setPosition = function(x, y) {
          this.getElement().style.left = x + "px";
          this.getElement().style.top = y + "px";
        };
        this.setClassName = function(className) {
          dom.addCssClass(this.getElement(), className);
        };
        this.show = function(text, x, y) {
          if (text != null)
            this.setText(text);
          if (x != null && y != null)
            this.setPosition(x, y);
          if (!this.isOpen) {
            this.getElement().style.display = "block";
            this.isOpen = true;
          }
        };
        this.hide = function() {
          if (this.isOpen) {
            this.getElement().style.display = "none";
            this.isOpen = false;
          }
        };
        this.getHeight = function() {
          return this.getElement().offsetHeight;
        };
        this.getWidth = function() {
          return this.getElement().offsetWidth;
        };
      }).call(Tooltip.prototype);
      exports.Tooltip = Tooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event", "ace/tooltip"], function(require, exports, module) {
      "use strict";
      var dom = require("../lib/dom");
      var oop = require("../lib/oop");
      var event = require("../lib/event");
      var Tooltip = require("../tooltip").Tooltip;
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor.container);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
          if (!editor.isFocused() || e.getButton() != 0)
            return;
          var gutterRegion = gutter.getRegion(e);
          if (gutterRegion == "foldWidgets")
            return;
          var row = e.getDocumentPosition().row;
          var selection = editor.session.selection;
          if (e.getShiftKey())
            selection.selectTo(row, 0);
          else {
            if (e.domEvent.detail == 2) {
              editor.selectAll();
              return e.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e);
          return e.preventDefault();
        });
        var tooltipTimeout,
            mouseEvent,
            tooltipAnnotation;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var annotation = gutter.$annotations[row];
          if (!annotation)
            return hideTooltip();
          var maxRow = editor.session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
              return hideTooltip();
          }
          if (tooltipAnnotation == annotation)
            return;
          tooltipAnnotation = annotation.text.join("<br/>");
          tooltip.setHtml(tooltipAnnotation);
          tooltip.show();
          editor.on("mousewheel", hideTooltip);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterElement = mouseEvent.domEvent.target;
            var rect = gutterElement.getBoundingClientRect();
            var style = tooltip.getElement().style;
            style.left = rect.right + "px";
            style.top = rect.bottom + "px";
          }
        }
        function hideTooltip() {
          if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltipAnnotation) {
            tooltip.hide();
            tooltipAnnotation = null;
            editor.removeEventListener("mousewheel", hideTooltip);
          }
        }
        function moveTooltip(e) {
          tooltip.setPosition(e.x, e.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
          var target = e.domEvent.target || e.domEvent.srcElement;
          if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();
          if (tooltipAnnotation && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e);
          mouseEvent = e;
          if (tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
            else
              hideTooltip();
          }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
          mouseEvent = null;
          if (!tooltipAnnotation || tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip();
          }, 50);
        });
        editor.on("changeSession", hideTooltip);
      }
      function GutterTooltip(parentNode) {
        Tooltip.call(this, parentNode);
      }
      oop.inherits(GutterTooltip, Tooltip);
      (function() {
        this.setPosition = function(x, y) {
          var windowWidth = window.innerWidth || document.documentElement.clientWidth;
          var windowHeight = window.innerHeight || document.documentElement.clientHeight;
          var width = this.getWidth();
          var height = this.getHeight();
          x += 15;
          y += 15;
          if (x + width > windowWidth) {
            x -= (x + width) - windowWidth;
          }
          if (y + height > windowHeight) {
            y -= 20 + height;
          }
          Tooltip.prototype.setPosition.call(this, x, y);
        };
      }).call(GutterTooltip.prototype);
      exports.GutterHandler = GutterHandler;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require, exports, module) {
      "use strict";
      var event = require("../lib/event");
      var useragent = require("../lib/useragent");
      var MouseEvent = exports.MouseEvent = function(domEvent, editor) {
        this.domEvent = domEvent;
        this.editor = editor;
        this.x = this.clientX = domEvent.clientX;
        this.y = this.clientY = domEvent.clientY;
        this.$pos = null;
        this.$inSelection = null;
        this.propagationStopped = false;
        this.defaultPrevented = false;
      };
      (function() {
        this.stopPropagation = function() {
          event.stopPropagation(this.domEvent);
          this.propagationStopped = true;
        };
        this.preventDefault = function() {
          event.preventDefault(this.domEvent);
          this.defaultPrevented = true;
        };
        this.stop = function() {
          this.stopPropagation();
          this.preventDefault();
        };
        this.getDocumentPosition = function() {
          if (this.$pos)
            return this.$pos;
          this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
          return this.$pos;
        };
        this.inSelection = function() {
          if (this.$inSelection !== null)
            return this.$inSelection;
          var editor = this.editor;
          var selectionRange = editor.getSelectionRange();
          if (selectionRange.isEmpty())
            this.$inSelection = false;
          else {
            var pos = this.getDocumentPosition();
            this.$inSelection = selectionRange.contains(pos.row, pos.column);
          }
          return this.$inSelection;
        };
        this.getButton = function() {
          return event.getButton(this.domEvent);
        };
        this.getShiftKey = function() {
          return this.domEvent.shiftKey;
        };
        this.getAccelKey = useragent.isMac ? function() {
          return this.domEvent.metaKey;
        } : function() {
          return this.domEvent.ctrlKey;
        };
      }).call(MouseEvent.prototype);
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require, exports, module) {
      "use strict";
      var dom = require("../lib/dom");
      var event = require("../lib/event");
      var useragent = require("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var blankImage = dom.createElement("img");
        blankImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (useragent.isOpera)
          blankImage.style.cssText = "width:1px;height:1px;position:fixed;top:0;left:0;z-index:2147483647;opacity:0;";
        var exports = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports.forEach(function(x) {
          mouseHandler[x] = this[x];
        }, this);
        editor.addEventListener("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker,
            x,
            y;
        var timerId,
            range;
        var dragCursor,
            counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self = this;
            setTimeout(function() {
              self.startSelect();
              self.captureMouse(e);
            }, 0);
            return e.preventDefault();
          }
          range = editor.getSelectionRange();
          var dataTransfer = e.dataTransfer;
          dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
          if (useragent.isOpera) {
            editor.container.appendChild(blankImage);
            blankImage.scrollTop = 0;
          }
          dataTransfer.setDragImage && dataTransfer.setDragImage(blankImage, 0, 0);
          if (useragent.isOpera) {
            editor.container.removeChild(blankImage);
          }
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function(e) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor.getReadOnly()) {
            var dropEffect = e.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
              editor.session.remove(editor.getSelectionRange());
            editor.renderer.$cursorLayer.setBlinking(true);
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker)
            addDragMarker();
          counter++;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragOver = function(e) {
          if (editor.getReadOnly() || !canAccept(e.dataTransfer))
            return;
          x = e.clientX;
          y = e.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
          e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
          return event.preventDefault(e);
        };
        this.onDragLeave = function(e) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e);
          }
        };
        this.onDrop = function(e) {
          if (!dragCursor)
            return;
          var dataTransfer = e.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData('Text');
            range = {
              start: dragCursor,
              end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler));
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler));
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler));
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler));
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler));
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler));
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor.$blockScrolling += 1;
            editor.moveCursorToPosition(cursor);
            editor.$blockScrolling -= 1;
            cursorMovedTime = now;
            cursorPointOnCaretMoved = {
              x: x,
              y: y
            };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor.renderer.layerConfig.lineHeight;
          var characterWidth = editor.renderer.layerConfig.characterWidth;
          var editorRect = editor.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x - editorRect.left,
              right: editorRect.right - x
            },
            y: {
              top: y - editorRect.top,
              bottom: editorRect.bottom - y
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = {
            row: cursor.row,
            column: cursor.column
          };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += (offsets.x.left < offsets.x.right ? -3 : +2);
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += (offsets.y.top < offsets.y.bottom ? -1 : +1);
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || (hScroll && !vMovement)) {
            if (!autoScrollStartTime)
              autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
              editor.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor.renderer.screenToTextCoordinates(x, y);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor.selection.toOrientedRange();
          dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
          editor.clearSelection();
          if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor.$blockScrolling += 1;
          editor.selection.fromOrientedRange(range);
          editor.$blockScrolling -= 1;
          if (editor.isFocused() && !isInternal)
            editor.renderer.$cursorLayer.setBlinking(!editor.getReadOnly());
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
              if (onMouseMoveTimer != null && dragSelectionMarker)
                clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function(type) {
            return type == 'text/plain' || type == 'Text';
          });
        }
        function getDropEffect(e) {
          var copyAllowed = ['copy', 'copymove', 'all', 'uninitialized'];
          var moveAllowed = ['move', 'copymove', 'linkmove', 'all', 'uninitialized'];
          var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
          } catch (e) {}
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
          else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          return dropEffect;
        }
      }
      (function() {
        this.dragWait = function() {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay())
            this.startDrag();
        };
        this.dragWaitEnd = function() {
          var target = this.editor.container;
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function(e) {
          this.editor.renderer.$cursorLayer.setBlinking(!this.editor.getReadOnly());
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function() {
          this.cancelDrag = false;
          var editor = this.editor;
          var target = editor.container;
          target.draggable = true;
          editor.renderer.$cursorLayer.setBlinking(false);
          editor.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function(e) {
          var target = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
              target.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function(e) {
          if (!this.$dragEnabled)
            return;
          this.mousedownEvent = e;
          var editor = this.editor;
          var inSelection = e.inSelection();
          var button = e.getButton();
          var clickCount = e.domEvent.detail || 1;
          if (clickCount === 1 && button === 0 && inSelection) {
            if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey()))
              return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e.domEvent.target || e.domEvent.srcElement;
            if ("unselectable" in eventTarget)
              eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e, this.onMouseDrag.bind(this));
            e.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require, exports, module) {
      "use strict";
      var dom = require("./dom");
      exports.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement('script');
        s.src = path;
        head.appendChild(s);
        s.onload = s.onreadystatechange = function(_, isAbort) {
          if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
            s = s.onload = s.onreadystatechange = null;
            if (!isAbort)
              callback();
          }
        };
      };
      exports.qualifyURL = function(url) {
        var a = document.createElement('a');
        a.href = url;
        return a.href;
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var EventEmitter = {};
      var stopPropagation = function() {
        this.propagationStopped = true;
      };
      var preventDefault = function() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return;
        if (typeof e != "object" || !e)
          e = {};
        if (!e.type)
          e.type = eventName;
        if (!e.stopPropagation)
          e.stopPropagation = stopPropagation;
        if (!e.preventDefault)
          e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++) {
          listeners[i](e, this);
          if (e.propagationStopped)
            break;
        }
        if (defaultHandler && !e.defaultPrevented)
          return defaultHandler(e, this);
      };
      EventEmitter._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
          return;
        listeners = listeners.slice();
        for (var i = 0; i < listeners.length; i++)
          listeners[i](e, this);
      };
      EventEmitter.once = function(eventName, callback) {
        var _self = this;
        callback && this.addEventListener(eventName, function newCallback() {
          _self.removeEventListener(eventName, newCallback);
          callback.apply(null, arguments);
        });
      };
      EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          handlers = this._defaultHandlers = {_disabled_: {}};
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          var old = handlers[eventName];
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i = disabled.indexOf(callback);
          if (i != -1)
            disabled.splice(i, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
          listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;
        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function(eventName) {
        if (this._eventRegistry)
          this._eventRegistry[eventName] = [];
      };
      exports.EventEmitter = EventEmitter;
    });
    ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require, exports, module) {
      "no use strict";
      var oop = require("./oop");
      var EventEmitter = require("./event_emitter").EventEmitter;
      var optionsProvider = {
        setOptions: function(optList) {
          Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function(optionNames) {
          var result = {};
          if (!optionNames) {
            optionNames = Object.keys(this.$options);
          } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
          }
          optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function(name, value) {
          if (this["$" + name] === value)
            return;
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet)
            this["$" + name] = value;
          if (opt && opt.set)
            opt.set.call(this, value);
        },
        getOption: function(name) {
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      function warn(message) {
        if (typeof console != "undefined" && console.warn)
          console.warn.apply(console, arguments);
      }
      function reportError(msg, data) {
        var e = new Error(msg);
        e.data = data;
        if (typeof console == "object" && console.error)
          console.error(e);
        setTimeout(function() {
          throw e;
        });
      }
      var AppConfig = function() {
        this.$defaultOptions = {};
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.defineOptions = function(obj, path, options) {
          if (!obj.$options)
            this.$defaultOptions[path] = obj.$options = {};
          Object.keys(options).forEach(function(key) {
            var opt = options[key];
            if (typeof opt == "string")
              opt = {forwardTo: opt};
            opt.name || (opt.name = key);
            obj.$options[opt.name] = opt;
            if ("initialValue" in opt)
              obj["$" + opt.name] = opt.initialValue;
          });
          oop.implement(obj, optionsProvider);
          return this;
        };
        this.resetOptions = function(obj) {
          Object.keys(obj.$options).forEach(function(key) {
            var opt = obj.$options[key];
            if ("value" in opt)
              obj.setOption(key, opt.value);
          });
        };
        this.setDefaultValue = function(path, name, value) {
          var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
          if (opts[name]) {
            if (opts.forwardTo)
              this.setDefaultValue(opts.forwardTo, name, value);
            else
              opts[name].value = value;
          }
        };
        this.setDefaultValues = function(path, optionHash) {
          Object.keys(optionHash).forEach(function(key) {
            this.setDefaultValue(path, key, optionHash[key]);
          }, this);
        };
        this.warn = warn;
        this.reportError = reportError;
      }).call(AppConfig.prototype);
      exports.AppConfig = AppConfig;
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/lib/net", "ace/lib/app_config"], function(require, exports, module) {
      "no use strict";
      var lang = require("./lib/lang");
      var oop = require("./lib/oop");
      var net = require("./lib/net");
      var AppConfig = require("./lib/app_config").AppConfig;
      module.exports = exports = new AppConfig();
      var global = (function() {
        return this || typeof window != "undefined" && window;
      })();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {}
      };
      exports.get = function(key) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports.set = function(key, value) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        options[key] = value;
      };
      exports.all = function() {
        return lang.copyObject(options);
      };
      exports.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
          return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re, "");
        }
        if ((!base || base == component) && parts.length > 1)
          base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
          path = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path && path.slice(-1) != "/")
          path += "/";
        return path + component + sep + base + this.get("suffix");
      };
      exports.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      exports.$loading = {};
      exports.loadModule = function(moduleName, onLoad) {
        var module,
            moduleType;
        if (Array.isArray(moduleName)) {
          moduleType = moduleName[0];
          moduleName = moduleName[1];
        }
        try {
          module = require(moduleName);
        } catch (e) {}
        if (module && !exports.$loading[moduleName])
          return onLoad && onLoad(module);
        if (!exports.$loading[moduleName])
          exports.$loading[moduleName] = [];
        exports.$loading[moduleName].push(onLoad);
        if (exports.$loading[moduleName].length > 1)
          return;
        var afterLoad = function() {
          require([moduleName], function(module) {
            exports._emit("load.module", {
              name: moduleName,
              module: module
            });
            var listeners = exports.$loading[moduleName];
            exports.$loading[moduleName] = null;
            listeners.forEach(function(onLoad) {
              onLoad && onLoad(module);
            });
          });
        };
        if (!exports.get("packaged"))
          return afterLoad();
        net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
      };
      init(true);
      function init(packaged) {
        if (!global || !global.document)
          return;
        options.packaged = packaged || require.packaged || module.packaged || (global.define && define.packaged);
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = (document.currentScript || document._currentScript);
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
          var script = scripts[i];
          var src = script.src || script.getAttribute("src");
          if (!src)
            continue;
          var attributes = script.attributes;
          for (var j = 0,
              l = attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m = src.match(/^(.*)\/ace(\-\w+)?\.js(\?|$)/);
          if (m)
            scriptUrl = m[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions)
          if (typeof scriptOptions[key] !== "undefined")
            exports.set(key, scriptOptions[key]);
      }
      exports.init = init;
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) {
          return m1.toUpperCase();
        });
      }
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/config"], function(require, exports, module) {
      "use strict";
      var event = require("../lib/event");
      var useragent = require("../lib/useragent");
      var DefaultHandlers = require("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
      var MouseEvent = require("./mouse_event").MouseEvent;
      var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
      var config = require("../config");
      var MouseHandler = function(editor) {
        var _self = this;
        this.editor = editor;
        new DefaultHandlers(this);
        new DefaultGutterHandler(this);
        new DragdropHandler(this);
        var focusEditor = function(e) {
          var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
          if (windowBlurred)
            window.focus();
          editor.focus();
        };
        var mouseTarget = editor.renderer.getMouseEventTarget();
        event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"));
        event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"));
        event.addMultiMouseDownListener([mouseTarget, editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner, editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner, editor.textInput && editor.textInput.getElement()].filter(Boolean), [400, 300, 250], this, "onMouseEvent");
        event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"));
        event.addTouchMoveListener(editor.container, this.onTouchMove.bind(this, "touchmove"));
        var gutterEl = editor.renderer.$gutter;
        event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"));
        event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"));
        event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"));
        event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"));
        event.addListener(mouseTarget, "mousedown", focusEditor);
        event.addListener(gutterEl, "mousedown", focusEditor);
        if (useragent.isIE && editor.renderer.scrollBarV) {
          event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor);
          event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor);
        }
        editor.on("mousemove", function(e) {
          if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
            return;
          var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
          var range = editor.session.selection.getRange();
          var renderer = editor.renderer;
          if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
            renderer.setCursorStyle("default");
          } else {
            renderer.setCursorStyle("");
          }
        });
      };
      (function() {
        this.onMouseEvent = function(name, e) {
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        this.onMouseMove = function(name, e) {
          var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
          if (!listeners || !listeners.length)
            return;
          this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        this.onMouseWheel = function(name, e) {
          var mouseEvent = new MouseEvent(e, this.editor);
          mouseEvent.speed = this.$scrollSpeed * 2;
          mouseEvent.wheelX = e.wheelX;
          mouseEvent.wheelY = e.wheelY;
          this.editor._emit(name, mouseEvent);
        };
        this.onTouchMove = function(name, e) {
          var mouseEvent = new MouseEvent(e, this.editor);
          mouseEvent.speed = 1;
          mouseEvent.wheelX = e.wheelX;
          mouseEvent.wheelY = e.wheelY;
          this.editor._emit(name, mouseEvent);
        };
        this.setState = function(state) {
          this.state = state;
        };
        this.captureMouse = function(ev, mouseMoveHandler) {
          this.x = ev.x;
          this.y = ev.y;
          this.isMousePressed = true;
          var renderer = this.editor.renderer;
          if (renderer.$keepTextAreaAtCursor)
            renderer.$keepTextAreaAtCursor = null;
          var self = this;
          var onMouseMove = function(e) {
            if (!e)
              return;
            if (useragent.isWebKit && !e.which && self.releaseMouse)
              return self.releaseMouse();
            self.x = e.clientX;
            self.y = e.clientY;
            mouseMoveHandler && mouseMoveHandler(e);
            self.mouseEvent = new MouseEvent(e, self.editor);
            self.$mouseMoved = true;
          };
          var onCaptureEnd = function(e) {
            clearInterval(timerId);
            onCaptureInterval();
            self[self.state + "End"] && self[self.state + "End"](e);
            self.state = "";
            if (renderer.$keepTextAreaAtCursor == null) {
              renderer.$keepTextAreaAtCursor = true;
              renderer.$moveTextAreaToCursor();
            }
            self.isMousePressed = false;
            self.$onCaptureMouseMove = self.releaseMouse = null;
            e && self.onMouseEvent("mouseup", e);
          };
          var onCaptureInterval = function() {
            self[self.state] && self[self.state]();
            self.$mouseMoved = false;
          };
          if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
            return setTimeout(function() {
              onCaptureEnd(ev);
            });
          }
          self.$onCaptureMouseMove = onMouseMove;
          self.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
          var timerId = setInterval(onCaptureInterval, 20);
        };
        this.releaseMouse = null;
        this.cancelContextMenu = function() {
          var stop = function(e) {
            if (e && e.domEvent && e.domEvent.type != "contextmenu")
              return;
            this.editor.off("nativecontextmenu", stop);
            if (e && e.domEvent)
              event.stopEvent(e.domEvent);
          }.bind(this);
          setTimeout(stop, 10);
          this.editor.on("nativecontextmenu", stop);
        };
      }).call(MouseHandler.prototype);
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: {initialValue: 2},
        dragDelay: {initialValue: (useragent.isMac ? 150 : 0)},
        dragEnabled: {initialValue: true},
        focusTimout: {initialValue: 0},
        tooltipFollowsMouse: {initialValue: true}
      });
      exports.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      function FoldHandler(editor) {
        editor.on("click", function(e) {
          var position = e.getDocumentPosition();
          var session = editor.session;
          var fold = session.getFoldAt(position.row, position.column, 1);
          if (fold) {
            if (e.getAccelKey())
              session.removeFold(fold);
            else
              session.expandFold(fold);
            e.stop();
          }
        });
        editor.on("gutterclick", function(e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            if (session.foldWidgets && session.foldWidgets[row])
              editor.session.onFoldWidgetClick(row, e);
            if (!editor.isFocused())
              editor.focus();
            e.stop();
          }
        });
        editor.on("gutterdblclick", function(e) {
          var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
          if (gutterRegion == "foldWidgets") {
            var row = e.getDocumentPosition().row;
            var session = editor.session;
            var data = session.getParentFoldRangeData(row, true);
            var range = data.range || data.firstRange;
            if (range) {
              row = range.start.row;
              var fold = session.getFoldAt(row, session.getLine(row).length, 1);
              if (fold) {
                session.removeFold(fold);
              } else {
                session.addFold("...", range);
                editor.renderer.scrollCursorIntoView({
                  row: range.start.row,
                  column: 0
                });
              }
            }
            e.stop();
          }
        });
      }
      exports.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require, exports, module) {
      "use strict";
      var keyUtil = require("../lib/keys");
      var event = require("../lib/event");
      var KeyBinding = function(editor) {
        this.$editor = editor;
        this.$data = {editor: editor};
        this.$handlers = [];
        this.setDefaultHandler(editor.commands);
      };
      (function() {
        this.setDefaultHandler = function(kb) {
          this.removeKeyboardHandler(this.$defaultHandler);
          this.$defaultHandler = kb;
          this.addKeyboardHandler(kb, 0);
        };
        this.setKeyboardHandler = function(kb) {
          var h = this.$handlers;
          if (h[h.length - 1] == kb)
            return;
          while (h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)
            this.removeKeyboardHandler(h[h.length - 1]);
          this.addKeyboardHandler(kb, 1);
        };
        this.addKeyboardHandler = function(kb, pos) {
          if (!kb)
            return;
          if (typeof kb == "function" && !kb.handleKeyboard)
            kb.handleKeyboard = kb;
          var i = this.$handlers.indexOf(kb);
          if (i != -1)
            this.$handlers.splice(i, 1);
          if (pos == undefined)
            this.$handlers.push(kb);
          else
            this.$handlers.splice(pos, 0, kb);
          if (i == -1 && kb.attach)
            kb.attach(this.$editor);
        };
        this.removeKeyboardHandler = function(kb) {
          var i = this.$handlers.indexOf(kb);
          if (i == -1)
            return false;
          this.$handlers.splice(i, 1);
          kb.detach && kb.detach(this.$editor);
          return true;
        };
        this.getKeyboardHandler = function() {
          return this.$handlers[this.$handlers.length - 1];
        };
        this.getStatusText = function() {
          var data = this.$data;
          var editor = data.editor;
          return this.$handlers.map(function(h) {
            return h.getStatusText && h.getStatusText(editor, data) || "";
          }).filter(Boolean).join(" ");
        };
        this.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
          var toExecute;
          var success = false;
          var commands = this.$editor.commands;
          for (var i = this.$handlers.length; i--; ) {
            toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
            if (!toExecute || !toExecute.command)
              continue;
            if (toExecute.command == "null") {
              success = true;
            } else {
              success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
            }
            if (success && e && hashId != -1 && toExecute.passEvent != true && toExecute.command.passEvent != true) {
              event.stopEvent(e);
            }
            if (success)
              break;
          }
          if (!success && hashId == -1) {
            toExecute = {command: "insertstring"};
            success = commands.exec("insertstring", this.$editor, keyString);
          }
          if (success)
            this.$editor._signal("keyboardActivity", toExecute);
          return success;
        };
        this.onCommandKey = function(e, hashId, keyCode) {
          var keyString = keyUtil.keyCodeToString(keyCode);
          this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
        };
        this.onTextInput = function(text) {
          this.$callKeyboardHandlers(-1, text);
        };
      }).call(KeyBinding.prototype);
      exports.KeyBinding = KeyBinding;
    });
    ace.define("ace/range", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      var Range = function(startRow, startColumn, endRow, endColumn) {
        this.start = {
          row: startRow,
          column: startColumn
        };
        this.end = {
          row: endRow,
          column: endColumn
        };
      };
      (function() {
        this.isEqual = function(range) {
          return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
        };
        this.toString = function() {
          return ("Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]");
        };
        this.contains = function(row, column) {
          return this.compare(row, column) == 0;
        };
        this.compareRange = function(range) {
          var cmp,
              end = range.end,
              start = range.start;
          cmp = this.compare(end.row, end.column);
          if (cmp == 1) {
            cmp = this.compare(start.row, start.column);
            if (cmp == 1) {
              return 2;
            } else if (cmp == 0) {
              return 1;
            } else {
              return 0;
            }
          } else if (cmp == -1) {
            return -2;
          } else {
            cmp = this.compare(start.row, start.column);
            if (cmp == -1) {
              return -1;
            } else if (cmp == 1) {
              return 42;
            } else {
              return 0;
            }
          }
        };
        this.comparePoint = function(p) {
          return this.compare(p.row, p.column);
        };
        this.containsRange = function(range) {
          return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        this.intersects = function(range) {
          var cmp = this.compareRange(range);
          return (cmp == -1 || cmp == 0 || cmp == 1);
        };
        this.isEnd = function(row, column) {
          return this.end.row == row && this.end.column == column;
        };
        this.isStart = function(row, column) {
          return this.start.row == row && this.start.column == column;
        };
        this.setStart = function(row, column) {
          if (typeof row == "object") {
            this.start.column = row.column;
            this.start.row = row.row;
          } else {
            this.start.row = row;
            this.start.column = column;
          }
        };
        this.setEnd = function(row, column) {
          if (typeof row == "object") {
            this.end.column = row.column;
            this.end.row = row.row;
          } else {
            this.end.row = row;
            this.end.column = column;
          }
        };
        this.inside = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column) || this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideStart = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isEnd(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.insideEnd = function(row, column) {
          if (this.compare(row, column) == 0) {
            if (this.isStart(row, column)) {
              return false;
            } else {
              return true;
            }
          }
          return false;
        };
        this.compare = function(row, column) {
          if (!this.isMultiLine()) {
            if (row === this.start.row) {
              return column < this.start.column ? -1 : (column > this.end.column ? 1 : 0);
            }
          }
          if (row < this.start.row)
            return -1;
          if (row > this.end.row)
            return 1;
          if (this.start.row === row)
            return column >= this.start.column ? 0 : -1;
          if (this.end.row === row)
            return column <= this.end.column ? 0 : 1;
          return 0;
        };
        this.compareStart = function(row, column) {
          if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareEnd = function(row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else {
            return this.compare(row, column);
          }
        };
        this.compareInside = function(row, column) {
          if (this.end.row == row && this.end.column == column) {
            return 1;
          } else if (this.start.row == row && this.start.column == column) {
            return -1;
          } else {
            return this.compare(row, column);
          }
        };
        this.clipRows = function(firstRow, lastRow) {
          if (this.end.row > lastRow)
            var end = {
              row: lastRow + 1,
              column: 0
            };
          else if (this.end.row < firstRow)
            var end = {
              row: firstRow,
              column: 0
            };
          if (this.start.row > lastRow)
            var start = {
              row: lastRow + 1,
              column: 0
            };
          else if (this.start.row < firstRow)
            var start = {
              row: firstRow,
              column: 0
            };
          return Range.fromPoints(start || this.start, end || this.end);
        };
        this.extend = function(row, column) {
          var cmp = this.compare(row, column);
          if (cmp == 0)
            return this;
          else if (cmp == -1)
            var start = {
              row: row,
              column: column
            };
          else
            var end = {
              row: row,
              column: column
            };
          return Range.fromPoints(start || this.start, end || this.end);
        };
        this.isEmpty = function() {
          return (this.start.row === this.end.row && this.start.column === this.end.column);
        };
        this.isMultiLine = function() {
          return (this.start.row !== this.end.row);
        };
        this.clone = function() {
          return Range.fromPoints(this.start, this.end);
        };
        this.collapseRows = function() {
          if (this.end.column == 0)
            return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
          else
            return new Range(this.start.row, 0, this.end.row, 0);
        };
        this.toScreenRange = function(session) {
          var screenPosStart = session.documentToScreenPosition(this.start);
          var screenPosEnd = session.documentToScreenPosition(this.end);
          return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
        };
        this.moveBy = function(row, column) {
          this.start.row += row;
          this.start.column += column;
          this.end.row += row;
          this.end.column += column;
        };
      }).call(Range.prototype);
      Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = comparePoints;
      Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports.Range = Range;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var lang = require("./lib/lang");
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var Range = require("./range").Range;
      var Selection = function(session) {
        this.session = session;
        this.doc = session.getDocument();
        this.clearSelection();
        this.lead = this.selectionLead = this.doc.createAnchor(0, 0);
        this.anchor = this.selectionAnchor = this.doc.createAnchor(0, 0);
        var self = this;
        this.lead.on("change", function(e) {
          self._emit("changeCursor");
          if (!self.$isEmpty)
            self._emit("changeSelection");
          if (!self.$keepDesiredColumnOnChange && e.old.column != e.value.column)
            self.$desiredColumn = null;
        });
        this.selectionAnchor.on("change", function() {
          if (!self.$isEmpty)
            self._emit("changeSelection");
        });
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.isEmpty = function() {
          return (this.$isEmpty || (this.anchor.row == this.lead.row && this.anchor.column == this.lead.column));
        };
        this.isMultiLine = function() {
          if (this.isEmpty()) {
            return false;
          }
          return this.getRange().isMultiLine();
        };
        this.getCursor = function() {
          return this.lead.getPosition();
        };
        this.setSelectionAnchor = function(row, column) {
          this.anchor.setPosition(row, column);
          if (this.$isEmpty) {
            this.$isEmpty = false;
            this._emit("changeSelection");
          }
        };
        this.getSelectionAnchor = function() {
          if (this.$isEmpty)
            return this.getSelectionLead();
          else
            return this.anchor.getPosition();
        };
        this.getSelectionLead = function() {
          return this.lead.getPosition();
        };
        this.shiftSelection = function(columns) {
          if (this.$isEmpty) {
            this.moveCursorTo(this.lead.row, this.lead.column + columns);
            return;
          }
          var anchor = this.getSelectionAnchor();
          var lead = this.getSelectionLead();
          var isBackwards = this.isBackwards();
          if (!isBackwards || anchor.column !== 0)
            this.setSelectionAnchor(anchor.row, anchor.column + columns);
          if (isBackwards || lead.column !== 0) {
            this.$moveSelection(function() {
              this.moveCursorTo(lead.row, lead.column + columns);
            });
          }
        };
        this.isBackwards = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          return (anchor.row > lead.row || (anchor.row == lead.row && anchor.column > lead.column));
        };
        this.getRange = function() {
          var anchor = this.anchor;
          var lead = this.lead;
          if (this.isEmpty())
            return Range.fromPoints(lead, lead);
          if (this.isBackwards()) {
            return Range.fromPoints(lead, anchor);
          } else {
            return Range.fromPoints(anchor, lead);
          }
        };
        this.clearSelection = function() {
          if (!this.$isEmpty) {
            this.$isEmpty = true;
            this._emit("changeSelection");
          }
        };
        this.selectAll = function() {
          var lastRow = this.doc.getLength() - 1;
          this.setSelectionAnchor(0, 0);
          this.moveCursorTo(lastRow, this.doc.getLine(lastRow).length);
        };
        this.setRange = this.setSelectionRange = function(range, reverse) {
          if (reverse) {
            this.setSelectionAnchor(range.end.row, range.end.column);
            this.selectTo(range.start.row, range.start.column);
          } else {
            this.setSelectionAnchor(range.start.row, range.start.column);
            this.selectTo(range.end.row, range.end.column);
          }
          if (this.getRange().isEmpty())
            this.$isEmpty = true;
          this.$desiredColumn = null;
        };
        this.$moveSelection = function(mover) {
          var lead = this.lead;
          if (this.$isEmpty)
            this.setSelectionAnchor(lead.row, lead.column);
          mover.call(this);
        };
        this.selectTo = function(row, column) {
          this.$moveSelection(function() {
            this.moveCursorTo(row, column);
          });
        };
        this.selectToPosition = function(pos) {
          this.$moveSelection(function() {
            this.moveCursorToPosition(pos);
          });
        };
        this.moveTo = function(row, column) {
          this.clearSelection();
          this.moveCursorTo(row, column);
        };
        this.moveToPosition = function(pos) {
          this.clearSelection();
          this.moveCursorToPosition(pos);
        };
        this.selectUp = function() {
          this.$moveSelection(this.moveCursorUp);
        };
        this.selectDown = function() {
          this.$moveSelection(this.moveCursorDown);
        };
        this.selectRight = function() {
          this.$moveSelection(this.moveCursorRight);
        };
        this.selectLeft = function() {
          this.$moveSelection(this.moveCursorLeft);
        };
        this.selectLineStart = function() {
          this.$moveSelection(this.moveCursorLineStart);
        };
        this.selectLineEnd = function() {
          this.$moveSelection(this.moveCursorLineEnd);
        };
        this.selectFileEnd = function() {
          this.$moveSelection(this.moveCursorFileEnd);
        };
        this.selectFileStart = function() {
          this.$moveSelection(this.moveCursorFileStart);
        };
        this.selectWordRight = function() {
          this.$moveSelection(this.moveCursorWordRight);
        };
        this.selectWordLeft = function() {
          this.$moveSelection(this.moveCursorWordLeft);
        };
        this.getWordRange = function(row, column) {
          if (typeof column == "undefined") {
            var cursor = row || this.lead;
            row = cursor.row;
            column = cursor.column;
          }
          return this.session.getWordRange(row, column);
        };
        this.selectWord = function() {
          this.setSelectionRange(this.getWordRange());
        };
        this.selectAWord = function() {
          var cursor = this.getCursor();
          var range = this.session.getAWordRange(cursor.row, cursor.column);
          this.setSelectionRange(range);
        };
        this.getLineRange = function(row, excludeLastChar) {
          var rowStart = typeof row == "number" ? row : this.lead.row;
          var rowEnd;
          var foldLine = this.session.getFoldLine(rowStart);
          if (foldLine) {
            rowStart = foldLine.start.row;
            rowEnd = foldLine.end.row;
          } else {
            rowEnd = rowStart;
          }
          if (excludeLastChar === true)
            return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
          else
            return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        this.selectLine = function() {
          this.setSelectionRange(this.getLineRange());
        };
        this.moveCursorUp = function() {
          this.moveCursorBy(-1, 0);
        };
        this.moveCursorDown = function() {
          this.moveCursorBy(1, 0);
        };
        this.moveCursorLeft = function() {
          var cursor = this.lead.getPosition(),
              fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
          } else if (cursor.column === 0) {
            if (cursor.row > 0) {
              this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            }
          } else {
            var tabSize = this.session.getTabSize();
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column - tabSize, cursor.column).split(" ").length - 1 == tabSize)
              this.moveCursorBy(0, -tabSize);
            else
              this.moveCursorBy(0, -1);
          }
        };
        this.moveCursorRight = function() {
          var cursor = this.lead.getPosition(),
              fold;
          if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
            this.moveCursorTo(fold.end.row, fold.end.column);
          } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
            if (this.lead.row < this.doc.getLength() - 1) {
              this.moveCursorTo(this.lead.row + 1, 0);
            }
          } else {
            var tabSize = this.session.getTabSize();
            var cursor = this.lead;
            if (this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(cursor.column, cursor.column + tabSize).split(" ").length - 1 == tabSize)
              this.moveCursorBy(0, tabSize);
            else
              this.moveCursorBy(0, 1);
          }
        };
        this.moveCursorLineStart = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var screenRow = this.session.documentToScreenRow(row, column);
          var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
          var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
          var leadingSpace = beforeCursor.match(/^\s*/);
          if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
            firstColumnPosition.column += leadingSpace[0].length;
          this.moveCursorToPosition(firstColumnPosition);
        };
        this.moveCursorLineEnd = function() {
          var lead = this.lead;
          var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
          if (this.lead.column == lineEnd.column) {
            var line = this.session.getLine(lineEnd.row);
            if (lineEnd.column == line.length) {
              var textEnd = line.search(/\s+$/);
              if (textEnd > 0)
                lineEnd.column = textEnd;
            }
          }
          this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        this.moveCursorFileEnd = function() {
          var row = this.doc.getLength() - 1;
          var column = this.doc.getLine(row).length;
          this.moveCursorTo(row, column);
        };
        this.moveCursorFileStart = function() {
          this.moveCursorTo(0, 0);
        };
        this.moveCursorLongWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var match;
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            this.moveCursorTo(fold.end.row, fold.end.column);
            return;
          }
          if (match = this.session.nonTokenRe.exec(rightOfCursor)) {
            column += this.session.nonTokenRe.lastIndex;
            this.session.nonTokenRe.lastIndex = 0;
            rightOfCursor = line.substring(column);
          }
          if (column >= line.length) {
            this.moveCursorTo(row, line.length);
            this.moveCursorRight();
            if (row < this.doc.getLength() - 1)
              this.moveCursorWordRight();
            return;
          }
          if (match = this.session.tokenRe.exec(rightOfCursor)) {
            column += this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.moveCursorLongWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1)) {
            this.moveCursorTo(fold.start.row, fold.start.column);
            return;
          }
          var str = this.session.getFoldStringAt(row, column, -1);
          if (str == null) {
            str = this.doc.getLine(row).substring(0, column);
          }
          var leftOfCursor = lang.stringReverse(str);
          var match;
          this.session.nonTokenRe.lastIndex = 0;
          this.session.tokenRe.lastIndex = 0;
          if (match = this.session.nonTokenRe.exec(leftOfCursor)) {
            column -= this.session.nonTokenRe.lastIndex;
            leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
            this.session.nonTokenRe.lastIndex = 0;
          }
          if (column <= 0) {
            this.moveCursorTo(row, 0);
            this.moveCursorLeft();
            if (row > 0)
              this.moveCursorWordLeft();
            return;
          }
          if (match = this.session.tokenRe.exec(leftOfCursor)) {
            column -= this.session.tokenRe.lastIndex;
            this.session.tokenRe.lastIndex = 0;
          }
          this.moveCursorTo(row, column);
        };
        this.$shortWordEndIndex = function(rightOfCursor) {
          var match,
              index = 0,
              ch;
          var whitespaceRe = /\s/;
          var tokenRe = this.session.tokenRe;
          tokenRe.lastIndex = 0;
          if (match = this.session.tokenRe.exec(rightOfCursor)) {
            index = this.session.tokenRe.lastIndex;
          } else {
            while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
              index++;
            if (index < 1) {
              tokenRe.lastIndex = 0;
              while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                tokenRe.lastIndex = 0;
                index++;
                if (whitespaceRe.test(ch)) {
                  if (index > 2) {
                    index--;
                    break;
                  } else {
                    while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                      index++;
                    if (index > 2)
                      break;
                  }
                }
              }
            }
          }
          tokenRe.lastIndex = 0;
          return index;
        };
        this.moveCursorShortWordRight = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var line = this.doc.getLine(row);
          var rightOfCursor = line.substring(column);
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold)
            return this.moveCursorTo(fold.end.row, fold.end.column);
          if (column == line.length) {
            var l = this.doc.getLength();
            do {
              row++;
              rightOfCursor = this.doc.getLine(row);
            } while (row < l && /^\s*$/.test(rightOfCursor));
            if (!/^\s+/.test(rightOfCursor))
              rightOfCursor = "";
            column = 0;
          }
          var index = this.$shortWordEndIndex(rightOfCursor);
          this.moveCursorTo(row, column + index);
        };
        this.moveCursorShortWordLeft = function() {
          var row = this.lead.row;
          var column = this.lead.column;
          var fold;
          if (fold = this.session.getFoldAt(row, column, -1))
            return this.moveCursorTo(fold.start.row, fold.start.column);
          var line = this.session.getLine(row).substring(0, column);
          if (column === 0) {
            do {
              row--;
              line = this.doc.getLine(row);
            } while (row > 0 && /^\s*$/.test(line));
            column = line.length;
            if (!/\s+$/.test(line))
              line = "";
          }
          var leftOfCursor = lang.stringReverse(line);
          var index = this.$shortWordEndIndex(leftOfCursor);
          return this.moveCursorTo(row, column - index);
        };
        this.moveCursorWordRight = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordRight();
          else
            this.moveCursorShortWordRight();
        };
        this.moveCursorWordLeft = function() {
          if (this.session.$selectLongWords)
            this.moveCursorLongWordLeft();
          else
            this.moveCursorShortWordLeft();
        };
        this.moveCursorBy = function(rows, chars) {
          var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
          if (chars === 0) {
            if (this.$desiredColumn)
              screenPos.column = this.$desiredColumn;
            else
              this.$desiredColumn = screenPos.column;
          }
          var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column);
          if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) {
            if (this.session.lineWidgets && this.session.lineWidgets[docPos.row]) {
              if (docPos.row > 0 || rows > 0)
                docPos.row++;
            }
          }
          this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        this.moveCursorToPosition = function(position) {
          this.moveCursorTo(position.row, position.column);
        };
        this.moveCursorTo = function(row, column, keepDesiredColumn) {
          var fold = this.session.getFoldAt(row, column, 1);
          if (fold) {
            row = fold.start.row;
            column = fold.start.column;
          }
          this.$keepDesiredColumnOnChange = true;
          this.lead.setPosition(row, column);
          this.$keepDesiredColumnOnChange = false;
          if (!keepDesiredColumn)
            this.$desiredColumn = null;
        };
        this.moveCursorToScreen = function(row, column, keepDesiredColumn) {
          var pos = this.session.screenToDocumentPosition(row, column);
          this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        this.detach = function() {
          this.lead.detach();
          this.anchor.detach();
          this.session = this.doc = null;
        };
        this.fromOrientedRange = function(range) {
          this.setSelectionRange(range, range.cursor == range.start);
          this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };
        this.toOrientedRange = function(range) {
          var r = this.getRange();
          if (range) {
            range.start.column = r.start.column;
            range.start.row = r.start.row;
            range.end.column = r.end.column;
            range.end.row = r.end.row;
          } else {
            range = r;
          }
          range.cursor = this.isBackwards() ? range.start : range.end;
          range.desiredColumn = this.$desiredColumn;
          return range;
        };
        this.getRangeOfMovements = function(func) {
          var start = this.getCursor();
          try {
            func(this);
            var end = this.getCursor();
            return Range.fromPoints(start, end);
          } catch (e) {
            return Range.fromPoints(start, start);
          } finally {
            this.moveCursorToPosition(start);
          }
        };
        this.toJSON = function() {
          if (this.rangeCount) {
            var data = this.ranges.map(function(r) {
              var r1 = r.clone();
              r1.isBackwards = r.cursor == r.start;
              return r1;
            });
          } else {
            var data = this.getRange();
            data.isBackwards = this.isBackwards();
          }
          return data;
        };
        this.fromJSON = function(data) {
          if (data.start == undefined) {
            if (this.rangeList) {
              this.toSingleRange(data[0]);
              for (var i = data.length; i--; ) {
                var r = Range.fromPoints(data[i].start, data[i].end);
                if (data[i].isBackwards)
                  r.cursor = r.start;
                this.addRange(r, true);
              }
              return;
            } else
              data = data[0];
          }
          if (this.rangeList)
            this.toSingleRange(data);
          this.setSelectionRange(data, data.isBackwards);
        };
        this.isEqual = function(data) {
          if ((data.length || this.rangeCount) && data.length != this.rangeCount)
            return false;
          if (!data.length || !this.ranges)
            return this.getRange().isEqual(data);
          for (var i = this.ranges.length; i--; ) {
            if (!this.ranges[i].isEqual(data[i]))
              return false;
          }
          return true;
        };
      }).call(Selection.prototype);
      exports.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module", "ace/config"], function(require, exports, module) {
      "use strict";
      var config = require("./config");
      var MAX_TOKEN_COUNT = 2000;
      var Tokenizer = function(rules) {
        this.states = rules;
        this.regExps = {};
        this.matchMappings = {};
        for (var key in this.states) {
          var state = this.states[key];
          var ruleRegExps = [];
          var matchTotal = 0;
          var mapping = this.matchMappings[key] = {defaultToken: "text"};
          var flag = "g";
          var splitterRurles = [];
          for (var i = 0; i < state.length; i++) {
            var rule = state[i];
            if (rule.defaultToken)
              mapping.defaultToken = rule.defaultToken;
            if (rule.caseInsensitive)
              flag = "gi";
            if (rule.regex == null)
              continue;
            if (rule.regex instanceof RegExp)
              rule.regex = rule.regex.toString().slice(1, -1);
            var adjustedregex = rule.regex;
            var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
            if (Array.isArray(rule.token)) {
              if (rule.token.length == 1 || matchcount == 1) {
                rule.token = rule.token[0];
              } else if (matchcount - 1 != rule.token.length) {
                this.reportError("number of classes and regexp groups doesn't match", {
                  rule: rule,
                  groupCount: matchcount - 1
                });
                rule.token = rule.token[0];
              } else {
                rule.tokenArray = rule.token;
                rule.token = null;
                rule.onMatch = this.$arrayTokens;
              }
            } else if (typeof rule.token == "function" && !rule.onMatch) {
              if (matchcount > 1)
                rule.onMatch = this.$applyToken;
              else
                rule.onMatch = rule.token;
            }
            if (matchcount > 1) {
              if (/\\\d/.test(rule.regex)) {
                adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                  return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                });
              } else {
                matchcount = 1;
                adjustedregex = this.removeCapturingGroups(rule.regex);
              }
              if (!rule.splitRegex && typeof rule.token != "string")
                splitterRurles.push(rule);
            }
            mapping[matchTotal] = i;
            matchTotal += matchcount;
            ruleRegExps.push(adjustedregex);
            if (!rule.onMatch)
              rule.onMatch = null;
          }
          if (!ruleRegExps.length) {
            mapping[0] = 0;
            ruleRegExps.push("$");
          }
          splitterRurles.forEach(function(rule) {
            rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
          }, this);
          this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
        }
      };
      (function() {
        this.$setMaxTokenCount = function(m) {
          MAX_TOKEN_COUNT = m | 0;
        };
        this.$applyToken = function(str) {
          var values = this.splitRegex.exec(str).slice(1);
          var types = this.token.apply(this, values);
          if (typeof types === "string")
            return [{
              type: types,
              value: str
            }];
          var tokens = [];
          for (var i = 0,
              l = types.length; i < l; i++) {
            if (values[i])
              tokens[tokens.length] = {
                type: types[i],
                value: values[i]
              };
          }
          return tokens;
        };
        this.$arrayTokens = function(str) {
          if (!str)
            return [];
          var values = this.splitRegex.exec(str);
          if (!values)
            return "text";
          var tokens = [];
          var types = this.tokenArray;
          for (var i = 0,
              l = types.length; i < l; i++) {
            if (values[i + 1])
              tokens[tokens.length] = {
                type: types[i],
                value: values[i + 1]
              };
          }
          return tokens;
        };
        this.removeCapturingGroups = function(src) {
          var r = src.replace(/\[(?:\\.|[^\]])*?\]|\\.|\(\?[:=!]|(\()/g, function(x, y) {
            return y ? "(?:" : x;
          });
          return r;
        };
        this.createSplitterRegexp = function(src, flag) {
          if (src.indexOf("(?=") != -1) {
            var stack = 0;
            var inChClass = false;
            var lastCapture = {};
            src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
              if (inChClass) {
                inChClass = square != "]";
              } else if (square) {
                inChClass = true;
              } else if (parenClose) {
                if (stack == lastCapture.stack) {
                  lastCapture.end = index + 1;
                  lastCapture.stack = -1;
                }
                stack--;
              } else if (parenOpen) {
                stack++;
                if (parenOpen.length != 1) {
                  lastCapture.stack = stack;
                  lastCapture.start = index;
                }
              }
              return m;
            });
            if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
              src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
          }
          if (src.charAt(0) != "^")
            src = "^" + src;
          if (src.charAt(src.length - 1) != "$")
            src += "$";
          return new RegExp(src, (flag || "").replace("g", ""));
        };
        this.getLineTokens = function(line, startState) {
          if (startState && typeof startState != "string") {
            var stack = startState.slice(0);
            startState = stack[0];
            if (startState === "#tmp") {
              stack.shift();
              startState = stack.shift();
            }
          } else
            var stack = [];
          var currentState = startState || "start";
          var state = this.states[currentState];
          if (!state) {
            currentState = "start";
            state = this.states[currentState];
          }
          var mapping = this.matchMappings[currentState];
          var re = this.regExps[currentState];
          re.lastIndex = 0;
          var match,
              tokens = [];
          var lastIndex = 0;
          var matchAttempts = 0;
          var token = {
            type: null,
            value: ""
          };
          while (match = re.exec(line)) {
            var type = mapping.defaultToken;
            var rule = null;
            var value = match[0];
            var index = re.lastIndex;
            if (index - value.length > lastIndex) {
              var skipped = line.substring(lastIndex, index - value.length);
              if (token.type == type) {
                token.value += skipped;
              } else {
                if (token.type)
                  tokens.push(token);
                token = {
                  type: type,
                  value: skipped
                };
              }
            }
            for (var i = 0; i < match.length - 2; i++) {
              if (match[i + 1] === undefined)
                continue;
              rule = state[mapping[i]];
              if (rule.onMatch)
                type = rule.onMatch(value, currentState, stack);
              else
                type = rule.token;
              if (rule.next) {
                if (typeof rule.next == "string") {
                  currentState = rule.next;
                } else {
                  currentState = rule.next(currentState, stack);
                }
                state = this.states[currentState];
                if (!state) {
                  this.reportError("state doesn't exist", currentState);
                  currentState = "start";
                  state = this.states[currentState];
                }
                mapping = this.matchMappings[currentState];
                lastIndex = index;
                re = this.regExps[currentState];
                re.lastIndex = index;
              }
              break;
            }
            if (value) {
              if (typeof type === "string") {
                if ((!rule || rule.merge !== false) && token.type === type) {
                  token.value += value;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = {
                    type: type,
                    value: value
                  };
                }
              } else if (type) {
                if (token.type)
                  tokens.push(token);
                token = {
                  type: null,
                  value: ""
                };
                for (var i = 0; i < type.length; i++)
                  tokens.push(type[i]);
              }
            }
            if (lastIndex == line.length)
              break;
            lastIndex = index;
            if (matchAttempts++ > MAX_TOKEN_COUNT) {
              if (matchAttempts > 2 * line.length) {
                this.reportError("infinite loop with in ace tokenizer", {
                  startState: startState,
                  line: line
                });
              }
              while (lastIndex < line.length) {
                if (token.type)
                  tokens.push(token);
                token = {
                  value: line.substring(lastIndex, lastIndex += 2000),
                  type: "overflow"
                };
              }
              currentState = "start";
              stack = [];
              break;
            }
          }
          if (token.type)
            tokens.push(token);
          if (stack.length > 1) {
            if (stack[0] !== currentState)
              stack.unshift("#tmp", currentState);
          }
          return {
            tokens: tokens,
            state: stack.length ? stack : currentState
          };
        };
        this.reportError = config.reportError;
      }).call(Tokenizer.prototype);
      exports.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/lang"], function(require, exports, module) {
      "use strict";
      var lang = require("../lib/lang");
      var TextHighlightRules = function() {
        this.$rules = {"start": [{
            token: "empty_line",
            regex: '^$'
          }, {defaultToken: "text"}]};
      };
      (function() {
        this.addRules = function(rules, prefix) {
          if (!prefix) {
            for (var key in rules)
              this.$rules[key] = rules[key];
            return;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next == "string") {
                  if (rule.next.indexOf(prefix) !== 0)
                    rule.next = prefix + rule.next;
                }
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                  rule.nextState = prefix + rule.nextState;
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function() {
          return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i = 0; i < states.length; i++)
              states[i] = prefix + states[i];
          } else {
            states = [];
            for (var key in embedRules)
              states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i = 0; i < states.length; i++)
              addRules.apply(this.$rules[states[i]], lang.deepCopy(escapeRules));
          }
          if (!this.$embeds)
            this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
          return this.$embeds;
        };
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function() {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state.processed = true;
            for (var i = 0; i < state.length; i++) {
              var rule = state[i];
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next)
                  rule.next = [];
                rule.next.push({defaultToken: rule.token}, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string")
                    stateName = stateName[0] || "";
                  if (rules[stateName])
                    stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push)
                      rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              if (rule.include || typeof rule == "string") {
                var includeName = rule.include || rule;
                var toInsert = rules[includeName];
              } else if (Array.isArray(rule))
                toInsert = rule;
              if (toInsert) {
                var args = [i, 1].concat(toInsert);
                if (rule.noEscape)
                  args = args.filter(function(x) {
                    return !x.next;
                  });
                state.splice.apply(state, args);
                i--;
                toInsert = null;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
          var keywords = Object.create(null);
          Object.keys(map).forEach(function(className) {
            var a = map[className];
            if (ignoreCase)
              a = a.toLowerCase();
            var list = a.split(splitChar || "|");
            for (var i = list.length; i--; )
              keywords[list[i]] = className;
          });
          if (Object.getPrototypeOf(keywords)) {
            keywords.__proto__ = null;
          }
          this.$keywordList = Object.keys(keywords);
          map = null;
          return ignoreCase ? function(value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function(value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function() {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var Behaviour = function() {
        this.$behaviours = {};
      };
      (function() {
        this.add = function(name, action, callback) {
          switch (undefined) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function(name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function(mode, filter) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter);
          } else {
            var behaviours = mode.getBehaviours(filter);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter) {
          if (!filter) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i = 0; i < filter.length; i++) {
              if (this.$behaviours[filter[i]]) {
                ret[filter[i]] = this.$behaviours[filter[i]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports.Behaviour = Behaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      exports.packages = {};
      addUnicodePackage({
        L: "0041-005A0061-007A00AA00B500BA00C0-00D600D8-00F600F8-02C102C6-02D102E0-02E402EC02EE0370-037403760377037A-037D03860388-038A038C038E-03A103A3-03F503F7-0481048A-05250531-055605590561-058705D0-05EA05F0-05F20621-064A066E066F0671-06D306D506E506E606EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA07F407F507FA0800-0815081A082408280904-0939093D09500958-0961097109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E460E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EC60EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10A0-10C510D0-10FA10FC1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317D717DC1820-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541AA71B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C7D1CE9-1CEC1CEE-1CF11D00-1DBF1E00-1F151F18-1F1D1F20-1F451F48-1F4D1F50-1F571F591F5B1F5D1F5F-1F7D1F80-1FB41FB6-1FBC1FBE1FC2-1FC41FC6-1FCC1FD0-1FD31FD6-1FDB1FE0-1FEC1FF2-1FF41FF6-1FFC2071207F2090-209421022107210A-211321152119-211D212421262128212A-212D212F-2139213C-213F2145-2149214E218321842C00-2C2E2C30-2C5E2C60-2CE42CEB-2CEE2D00-2D252D30-2D652D6F2D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE2E2F300530063031-3035303B303C3041-3096309D-309F30A1-30FA30FC-30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A48CA4D0-A4FDA500-A60CA610-A61FA62AA62BA640-A65FA662-A66EA67F-A697A6A0-A6E5A717-A71FA722-A788A78BA78CA7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2A9CFAA00-AA28AA40-AA42AA44-AA4BAA60-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADB-AADDABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB00-FB06FB13-FB17FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF21-FF3AFF41-FF5AFF66-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
        Ll: "0061-007A00AA00B500BA00DF-00F600F8-00FF01010103010501070109010B010D010F01110113011501170119011B011D011F01210123012501270129012B012D012F01310133013501370138013A013C013E014001420144014601480149014B014D014F01510153015501570159015B015D015F01610163016501670169016B016D016F0171017301750177017A017C017E-0180018301850188018C018D019201950199-019B019E01A101A301A501A801AA01AB01AD01B001B401B601B901BA01BD-01BF01C601C901CC01CE01D001D201D401D601D801DA01DC01DD01DF01E101E301E501E701E901EB01ED01EF01F001F301F501F901FB01FD01FF02010203020502070209020B020D020F02110213021502170219021B021D021F02210223022502270229022B022D022F02310233-0239023C023F0240024202470249024B024D024F-02930295-02AF037103730377037B-037D039003AC-03CE03D003D103D5-03D703D903DB03DD03DF03E103E303E503E703E903EB03ED03EF-03F303F503F803FB03FC0430-045F04610463046504670469046B046D046F04710473047504770479047B047D047F0481048B048D048F04910493049504970499049B049D049F04A104A304A504A704A904AB04AD04AF04B104B304B504B704B904BB04BD04BF04C204C404C604C804CA04CC04CE04CF04D104D304D504D704D904DB04DD04DF04E104E304E504E704E904EB04ED04EF04F104F304F504F704F904FB04FD04FF05010503050505070509050B050D050F05110513051505170519051B051D051F0521052305250561-05871D00-1D2B1D62-1D771D79-1D9A1E011E031E051E071E091E0B1E0D1E0F1E111E131E151E171E191E1B1E1D1E1F1E211E231E251E271E291E2B1E2D1E2F1E311E331E351E371E391E3B1E3D1E3F1E411E431E451E471E491E4B1E4D1E4F1E511E531E551E571E591E5B1E5D1E5F1E611E631E651E671E691E6B1E6D1E6F1E711E731E751E771E791E7B1E7D1E7F1E811E831E851E871E891E8B1E8D1E8F1E911E931E95-1E9D1E9F1EA11EA31EA51EA71EA91EAB1EAD1EAF1EB11EB31EB51EB71EB91EBB1EBD1EBF1EC11EC31EC51EC71EC91ECB1ECD1ECF1ED11ED31ED51ED71ED91EDB1EDD1EDF1EE11EE31EE51EE71EE91EEB1EED1EEF1EF11EF31EF51EF71EF91EFB1EFD1EFF-1F071F10-1F151F20-1F271F30-1F371F40-1F451F50-1F571F60-1F671F70-1F7D1F80-1F871F90-1F971FA0-1FA71FB0-1FB41FB61FB71FBE1FC2-1FC41FC61FC71FD0-1FD31FD61FD71FE0-1FE71FF2-1FF41FF61FF7210A210E210F2113212F21342139213C213D2146-2149214E21842C30-2C5E2C612C652C662C682C6A2C6C2C712C732C742C76-2C7C2C812C832C852C872C892C8B2C8D2C8F2C912C932C952C972C992C9B2C9D2C9F2CA12CA32CA52CA72CA92CAB2CAD2CAF2CB12CB32CB52CB72CB92CBB2CBD2CBF2CC12CC32CC52CC72CC92CCB2CCD2CCF2CD12CD32CD52CD72CD92CDB2CDD2CDF2CE12CE32CE42CEC2CEE2D00-2D25A641A643A645A647A649A64BA64DA64FA651A653A655A657A659A65BA65DA65FA663A665A667A669A66BA66DA681A683A685A687A689A68BA68DA68FA691A693A695A697A723A725A727A729A72BA72DA72F-A731A733A735A737A739A73BA73DA73FA741A743A745A747A749A74BA74DA74FA751A753A755A757A759A75BA75DA75FA761A763A765A767A769A76BA76DA76FA771-A778A77AA77CA77FA781A783A785A787A78CFB00-FB06FB13-FB17FF41-FF5A",
        Lu: "0041-005A00C0-00D600D8-00DE01000102010401060108010A010C010E01100112011401160118011A011C011E01200122012401260128012A012C012E01300132013401360139013B013D013F0141014301450147014A014C014E01500152015401560158015A015C015E01600162016401660168016A016C016E017001720174017601780179017B017D018101820184018601870189-018B018E-0191019301940196-0198019C019D019F01A001A201A401A601A701A901AC01AE01AF01B1-01B301B501B701B801BC01C401C701CA01CD01CF01D101D301D501D701D901DB01DE01E001E201E401E601E801EA01EC01EE01F101F401F6-01F801FA01FC01FE02000202020402060208020A020C020E02100212021402160218021A021C021E02200222022402260228022A022C022E02300232023A023B023D023E02410243-02460248024A024C024E03700372037603860388-038A038C038E038F0391-03A103A3-03AB03CF03D2-03D403D803DA03DC03DE03E003E203E403E603E803EA03EC03EE03F403F703F903FA03FD-042F04600462046404660468046A046C046E04700472047404760478047A047C047E0480048A048C048E04900492049404960498049A049C049E04A004A204A404A604A804AA04AC04AE04B004B204B404B604B804BA04BC04BE04C004C104C304C504C704C904CB04CD04D004D204D404D604D804DA04DC04DE04E004E204E404E604E804EA04EC04EE04F004F204F404F604F804FA04FC04FE05000502050405060508050A050C050E05100512051405160518051A051C051E0520052205240531-055610A0-10C51E001E021E041E061E081E0A1E0C1E0E1E101E121E141E161E181E1A1E1C1E1E1E201E221E241E261E281E2A1E2C1E2E1E301E321E341E361E381E3A1E3C1E3E1E401E421E441E461E481E4A1E4C1E4E1E501E521E541E561E581E5A1E5C1E5E1E601E621E641E661E681E6A1E6C1E6E1E701E721E741E761E781E7A1E7C1E7E1E801E821E841E861E881E8A1E8C1E8E1E901E921E941E9E1EA01EA21EA41EA61EA81EAA1EAC1EAE1EB01EB21EB41EB61EB81EBA1EBC1EBE1EC01EC21EC41EC61EC81ECA1ECC1ECE1ED01ED21ED41ED61ED81EDA1EDC1EDE1EE01EE21EE41EE61EE81EEA1EEC1EEE1EF01EF21EF41EF61EF81EFA1EFC1EFE1F08-1F0F1F18-1F1D1F28-1F2F1F38-1F3F1F48-1F4D1F591F5B1F5D1F5F1F68-1F6F1FB8-1FBB1FC8-1FCB1FD8-1FDB1FE8-1FEC1FF8-1FFB21022107210B-210D2110-211221152119-211D212421262128212A-212D2130-2133213E213F214521832C00-2C2E2C602C62-2C642C672C692C6B2C6D-2C702C722C752C7E-2C802C822C842C862C882C8A2C8C2C8E2C902C922C942C962C982C9A2C9C2C9E2CA02CA22CA42CA62CA82CAA2CAC2CAE2CB02CB22CB42CB62CB82CBA2CBC2CBE2CC02CC22CC42CC62CC82CCA2CCC2CCE2CD02CD22CD42CD62CD82CDA2CDC2CDE2CE02CE22CEB2CEDA640A642A644A646A648A64AA64CA64EA650A652A654A656A658A65AA65CA65EA662A664A666A668A66AA66CA680A682A684A686A688A68AA68CA68EA690A692A694A696A722A724A726A728A72AA72CA72EA732A734A736A738A73AA73CA73EA740A742A744A746A748A74AA74CA74EA750A752A754A756A758A75AA75CA75EA760A762A764A766A768A76AA76CA76EA779A77BA77DA77EA780A782A784A786A78BFF21-FF3A",
        Lt: "01C501C801CB01F21F88-1F8F1F98-1F9F1FA8-1FAF1FBC1FCC1FFC",
        Lm: "02B0-02C102C6-02D102E0-02E402EC02EE0374037A0559064006E506E607F407F507FA081A0824082809710E460EC610FC17D718431AA71C78-1C7D1D2C-1D611D781D9B-1DBF2071207F2090-20942C7D2D6F2E2F30053031-3035303B309D309E30FC-30FEA015A4F8-A4FDA60CA67FA717-A71FA770A788A9CFAA70AADDFF70FF9EFF9F",
        Lo: "01BB01C0-01C3029405D0-05EA05F0-05F20621-063F0641-064A066E066F0671-06D306D506EE06EF06FA-06FC06FF07100712-072F074D-07A507B107CA-07EA0800-08150904-0939093D09500958-096109720979-097F0985-098C098F09900993-09A809AA-09B009B209B6-09B909BD09CE09DC09DD09DF-09E109F009F10A05-0A0A0A0F0A100A13-0A280A2A-0A300A320A330A350A360A380A390A59-0A5C0A5E0A72-0A740A85-0A8D0A8F-0A910A93-0AA80AAA-0AB00AB20AB30AB5-0AB90ABD0AD00AE00AE10B05-0B0C0B0F0B100B13-0B280B2A-0B300B320B330B35-0B390B3D0B5C0B5D0B5F-0B610B710B830B85-0B8A0B8E-0B900B92-0B950B990B9A0B9C0B9E0B9F0BA30BA40BA8-0BAA0BAE-0BB90BD00C05-0C0C0C0E-0C100C12-0C280C2A-0C330C35-0C390C3D0C580C590C600C610C85-0C8C0C8E-0C900C92-0CA80CAA-0CB30CB5-0CB90CBD0CDE0CE00CE10D05-0D0C0D0E-0D100D12-0D280D2A-0D390D3D0D600D610D7A-0D7F0D85-0D960D9A-0DB10DB3-0DBB0DBD0DC0-0DC60E01-0E300E320E330E40-0E450E810E820E840E870E880E8A0E8D0E94-0E970E99-0E9F0EA1-0EA30EA50EA70EAA0EAB0EAD-0EB00EB20EB30EBD0EC0-0EC40EDC0EDD0F000F40-0F470F49-0F6C0F88-0F8B1000-102A103F1050-1055105A-105D106110651066106E-10701075-1081108E10D0-10FA1100-1248124A-124D1250-12561258125A-125D1260-1288128A-128D1290-12B012B2-12B512B8-12BE12C012C2-12C512C8-12D612D8-13101312-13151318-135A1380-138F13A0-13F41401-166C166F-167F1681-169A16A0-16EA1700-170C170E-17111720-17311740-17511760-176C176E-17701780-17B317DC1820-18421844-18771880-18A818AA18B0-18F51900-191C1950-196D1970-19741980-19AB19C1-19C71A00-1A161A20-1A541B05-1B331B45-1B4B1B83-1BA01BAE1BAF1C00-1C231C4D-1C4F1C5A-1C771CE9-1CEC1CEE-1CF12135-21382D30-2D652D80-2D962DA0-2DA62DA8-2DAE2DB0-2DB62DB8-2DBE2DC0-2DC62DC8-2DCE2DD0-2DD62DD8-2DDE3006303C3041-3096309F30A1-30FA30FF3105-312D3131-318E31A0-31B731F0-31FF3400-4DB54E00-9FCBA000-A014A016-A48CA4D0-A4F7A500-A60BA610-A61FA62AA62BA66EA6A0-A6E5A7FB-A801A803-A805A807-A80AA80C-A822A840-A873A882-A8B3A8F2-A8F7A8FBA90A-A925A930-A946A960-A97CA984-A9B2AA00-AA28AA40-AA42AA44-AA4BAA60-AA6FAA71-AA76AA7AAA80-AAAFAAB1AAB5AAB6AAB9-AABDAAC0AAC2AADBAADCABC0-ABE2AC00-D7A3D7B0-D7C6D7CB-D7FBF900-FA2DFA30-FA6DFA70-FAD9FB1DFB1F-FB28FB2A-FB36FB38-FB3CFB3EFB40FB41FB43FB44FB46-FBB1FBD3-FD3DFD50-FD8FFD92-FDC7FDF0-FDFBFE70-FE74FE76-FEFCFF66-FF6FFF71-FF9DFFA0-FFBEFFC2-FFC7FFCA-FFCFFFD2-FFD7FFDA-FFDC",
        M: "0300-036F0483-04890591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DE-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0903093C093E-094E0951-0955096209630981-098309BC09BE-09C409C709C809CB-09CD09D709E209E30A01-0A030A3C0A3E-0A420A470A480A4B-0A4D0A510A700A710A750A81-0A830ABC0ABE-0AC50AC7-0AC90ACB-0ACD0AE20AE30B01-0B030B3C0B3E-0B440B470B480B4B-0B4D0B560B570B620B630B820BBE-0BC20BC6-0BC80BCA-0BCD0BD70C01-0C030C3E-0C440C46-0C480C4A-0C4D0C550C560C620C630C820C830CBC0CBE-0CC40CC6-0CC80CCA-0CCD0CD50CD60CE20CE30D020D030D3E-0D440D46-0D480D4A-0D4D0D570D620D630D820D830DCA0DCF-0DD40DD60DD8-0DDF0DF20DF30E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F3E0F3F0F71-0F840F860F870F90-0F970F99-0FBC0FC6102B-103E1056-1059105E-10601062-10641067-106D1071-10741082-108D108F109A-109D135F1712-17141732-1734175217531772177317B6-17D317DD180B-180D18A91920-192B1930-193B19B0-19C019C819C91A17-1A1B1A55-1A5E1A60-1A7C1A7F1B00-1B041B34-1B441B6B-1B731B80-1B821BA1-1BAA1C24-1C371CD0-1CD21CD4-1CE81CED1CF21DC0-1DE61DFD-1DFF20D0-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66F-A672A67CA67DA6F0A6F1A802A806A80BA823-A827A880A881A8B4-A8C4A8E0-A8F1A926-A92DA947-A953A980-A983A9B3-A9C0AA29-AA36AA43AA4CAA4DAA7BAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE3-ABEAABECABEDFB1EFE00-FE0FFE20-FE26",
        Mn: "0300-036F0483-04870591-05BD05BF05C105C205C405C505C70610-061A064B-065E067006D6-06DC06DF-06E406E706E806EA-06ED07110730-074A07A6-07B007EB-07F30816-0819081B-08230825-08270829-082D0900-0902093C0941-0948094D0951-095509620963098109BC09C1-09C409CD09E209E30A010A020A3C0A410A420A470A480A4B-0A4D0A510A700A710A750A810A820ABC0AC1-0AC50AC70AC80ACD0AE20AE30B010B3C0B3F0B41-0B440B4D0B560B620B630B820BC00BCD0C3E-0C400C46-0C480C4A-0C4D0C550C560C620C630CBC0CBF0CC60CCC0CCD0CE20CE30D41-0D440D4D0D620D630DCA0DD2-0DD40DD60E310E34-0E3A0E47-0E4E0EB10EB4-0EB90EBB0EBC0EC8-0ECD0F180F190F350F370F390F71-0F7E0F80-0F840F860F870F90-0F970F99-0FBC0FC6102D-10301032-10371039103A103D103E10581059105E-10601071-1074108210851086108D109D135F1712-17141732-1734175217531772177317B7-17BD17C617C9-17D317DD180B-180D18A91920-19221927192819321939-193B1A171A181A561A58-1A5E1A601A621A65-1A6C1A73-1A7C1A7F1B00-1B031B341B36-1B3A1B3C1B421B6B-1B731B801B811BA2-1BA51BA81BA91C2C-1C331C361C371CD0-1CD21CD4-1CE01CE2-1CE81CED1DC0-1DE61DFD-1DFF20D0-20DC20E120E5-20F02CEF-2CF12DE0-2DFF302A-302F3099309AA66FA67CA67DA6F0A6F1A802A806A80BA825A826A8C4A8E0-A8F1A926-A92DA947-A951A980-A982A9B3A9B6-A9B9A9BCAA29-AA2EAA31AA32AA35AA36AA43AA4CAAB0AAB2-AAB4AAB7AAB8AABEAABFAAC1ABE5ABE8ABEDFB1EFE00-FE0FFE20-FE26",
        Mc: "0903093E-09400949-094C094E0982098309BE-09C009C709C809CB09CC09D70A030A3E-0A400A830ABE-0AC00AC90ACB0ACC0B020B030B3E0B400B470B480B4B0B4C0B570BBE0BBF0BC10BC20BC6-0BC80BCA-0BCC0BD70C01-0C030C41-0C440C820C830CBE0CC0-0CC40CC70CC80CCA0CCB0CD50CD60D020D030D3E-0D400D46-0D480D4A-0D4C0D570D820D830DCF-0DD10DD8-0DDF0DF20DF30F3E0F3F0F7F102B102C10311038103B103C105610571062-10641067-106D108310841087-108C108F109A-109C17B617BE-17C517C717C81923-19261929-192B193019311933-193819B0-19C019C819C91A19-1A1B1A551A571A611A631A641A6D-1A721B041B351B3B1B3D-1B411B431B441B821BA11BA61BA71BAA1C24-1C2B1C341C351CE11CF2A823A824A827A880A881A8B4-A8C3A952A953A983A9B4A9B5A9BAA9BBA9BD-A9C0AA2FAA30AA33AA34AA4DAA7BABE3ABE4ABE6ABE7ABE9ABEAABEC",
        Me: "0488048906DE20DD-20E020E2-20E4A670-A672",
        N: "0030-003900B200B300B900BC-00BE0660-066906F0-06F907C0-07C90966-096F09E6-09EF09F4-09F90A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BF20C66-0C6F0C78-0C7E0CE6-0CEF0D66-0D750E50-0E590ED0-0ED90F20-0F331040-10491090-10991369-137C16EE-16F017E0-17E917F0-17F91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C5920702074-20792080-20892150-21822185-21892460-249B24EA-24FF2776-27932CFD30073021-30293038-303A3192-31953220-32293251-325F3280-328932B1-32BFA620-A629A6E6-A6EFA830-A835A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
        Nd: "0030-00390660-066906F0-06F907C0-07C90966-096F09E6-09EF0A66-0A6F0AE6-0AEF0B66-0B6F0BE6-0BEF0C66-0C6F0CE6-0CEF0D66-0D6F0E50-0E590ED0-0ED90F20-0F291040-10491090-109917E0-17E91810-18191946-194F19D0-19DA1A80-1A891A90-1A991B50-1B591BB0-1BB91C40-1C491C50-1C59A620-A629A8D0-A8D9A900-A909A9D0-A9D9AA50-AA59ABF0-ABF9FF10-FF19",
        Nl: "16EE-16F02160-21822185-218830073021-30293038-303AA6E6-A6EF",
        No: "00B200B300B900BC-00BE09F4-09F90BF0-0BF20C78-0C7E0D70-0D750F2A-0F331369-137C17F0-17F920702074-20792080-20892150-215F21892460-249B24EA-24FF2776-27932CFD3192-31953220-32293251-325F3280-328932B1-32BFA830-A835",
        P: "0021-00230025-002A002C-002F003A003B003F0040005B-005D005F007B007D00A100AB00B700BB00BF037E0387055A-055F0589058A05BE05C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F3A-0F3D0F850FD0-0FD4104A-104F10FB1361-13681400166D166E169B169C16EB-16ED1735173617D4-17D617D8-17DA1800-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD32010-20272030-20432045-20512053-205E207D207E208D208E2329232A2768-277527C527C627E6-27EF2983-299829D8-29DB29FC29FD2CF9-2CFC2CFE2CFF2E00-2E2E2E302E313001-30033008-30113014-301F3030303D30A030FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFD3EFD3FFE10-FE19FE30-FE52FE54-FE61FE63FE68FE6AFE6BFF01-FF03FF05-FF0AFF0C-FF0FFF1AFF1BFF1FFF20FF3B-FF3DFF3FFF5BFF5DFF5F-FF65",
        Pd: "002D058A05BE140018062010-20152E172E1A301C303030A0FE31FE32FE58FE63FF0D",
        Ps: "0028005B007B0F3A0F3C169B201A201E2045207D208D23292768276A276C276E27702772277427C527E627E827EA27EC27EE2983298529872989298B298D298F299129932995299729D829DA29FC2E222E242E262E283008300A300C300E3010301430163018301A301DFD3EFE17FE35FE37FE39FE3BFE3DFE3FFE41FE43FE47FE59FE5BFE5DFF08FF3BFF5BFF5FFF62",
        Pe: "0029005D007D0F3B0F3D169C2046207E208E232A2769276B276D276F27712773277527C627E727E927EB27ED27EF298429862988298A298C298E2990299229942996299829D929DB29FD2E232E252E272E293009300B300D300F3011301530173019301B301E301FFD3FFE18FE36FE38FE3AFE3CFE3EFE40FE42FE44FE48FE5AFE5CFE5EFF09FF3DFF5DFF60FF63",
        Pi: "00AB2018201B201C201F20392E022E042E092E0C2E1C2E20",
        Pf: "00BB2019201D203A2E032E052E0A2E0D2E1D2E21",
        Pc: "005F203F20402054FE33FE34FE4D-FE4FFF3F",
        Po: "0021-00230025-0027002A002C002E002F003A003B003F0040005C00A100B700BF037E0387055A-055F058905C005C305C605F305F40609060A060C060D061B061E061F066A-066D06D40700-070D07F7-07F90830-083E0964096509700DF40E4F0E5A0E5B0F04-0F120F850FD0-0FD4104A-104F10FB1361-1368166D166E16EB-16ED1735173617D4-17D617D8-17DA1800-18051807-180A1944194519DE19DF1A1E1A1F1AA0-1AA61AA8-1AAD1B5A-1B601C3B-1C3F1C7E1C7F1CD3201620172020-20272030-2038203B-203E2041-20432047-205120532055-205E2CF9-2CFC2CFE2CFF2E002E012E06-2E082E0B2E0E-2E162E182E192E1B2E1E2E1F2E2A-2E2E2E302E313001-3003303D30FBA4FEA4FFA60D-A60FA673A67EA6F2-A6F7A874-A877A8CEA8CFA8F8-A8FAA92EA92FA95FA9C1-A9CDA9DEA9DFAA5C-AA5FAADEAADFABEBFE10-FE16FE19FE30FE45FE46FE49-FE4CFE50-FE52FE54-FE57FE5F-FE61FE68FE6AFE6BFF01-FF03FF05-FF07FF0AFF0CFF0EFF0FFF1AFF1BFF1FFF20FF3CFF61FF64FF65",
        S: "0024002B003C-003E005E0060007C007E00A2-00A900AC00AE-00B100B400B600B800D700F702C2-02C502D2-02DF02E5-02EB02ED02EF-02FF03750384038503F604820606-0608060B060E060F06E906FD06FE07F609F209F309FA09FB0AF10B700BF3-0BFA0C7F0CF10CF20D790E3F0F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-139917DB194019E0-19FF1B61-1B6A1B74-1B7C1FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE20442052207A-207C208A-208C20A0-20B8210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B2140-2144214A-214D214F2190-2328232B-23E82400-24262440-244A249C-24E92500-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE27C0-27C427C7-27CA27CC27D0-27E527F0-29822999-29D729DC-29FB29FE-2B4C2B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F309B309C319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A700-A716A720A721A789A78AA828-A82BA836-A839AA77-AA79FB29FDFCFDFDFE62FE64-FE66FE69FF04FF0BFF1C-FF1EFF3EFF40FF5CFF5EFFE0-FFE6FFE8-FFEEFFFCFFFD",
        Sm: "002B003C-003E007C007E00AC00B100D700F703F60606-060820442052207A-207C208A-208C2140-2144214B2190-2194219A219B21A021A321A621AE21CE21CF21D221D421F4-22FF2308-230B23202321237C239B-23B323DC-23E125B725C125F8-25FF266F27C0-27C427C7-27CA27CC27D0-27E527F0-27FF2900-29822999-29D729DC-29FB29FE-2AFF2B30-2B442B47-2B4CFB29FE62FE64-FE66FF0BFF1C-FF1EFF5CFF5EFFE2FFE9-FFEC",
        Sc: "002400A2-00A5060B09F209F309FB0AF10BF90E3F17DB20A0-20B8A838FDFCFE69FF04FFE0FFE1FFE5FFE6",
        Sk: "005E006000A800AF00B400B802C2-02C502D2-02DF02E5-02EB02ED02EF-02FF0375038403851FBD1FBF-1FC11FCD-1FCF1FDD-1FDF1FED-1FEF1FFD1FFE309B309CA700-A716A720A721A789A78AFF3EFF40FFE3",
        So: "00A600A700A900AE00B000B60482060E060F06E906FD06FE07F609FA0B700BF3-0BF80BFA0C7F0CF10CF20D790F01-0F030F13-0F170F1A-0F1F0F340F360F380FBE-0FC50FC7-0FCC0FCE0FCF0FD5-0FD8109E109F13601390-1399194019E0-19FF1B61-1B6A1B74-1B7C210021012103-21062108210921142116-2118211E-2123212521272129212E213A213B214A214C214D214F2195-2199219C-219F21A121A221A421A521A7-21AD21AF-21CD21D021D121D321D5-21F32300-2307230C-231F2322-2328232B-237B237D-239A23B4-23DB23E2-23E82400-24262440-244A249C-24E92500-25B625B8-25C025C2-25F72600-266E2670-26CD26CF-26E126E326E8-26FF2701-27042706-2709270C-27272729-274B274D274F-27522756-275E2761-276727942798-27AF27B1-27BE2800-28FF2B00-2B2F2B452B462B50-2B592CE5-2CEA2E80-2E992E9B-2EF32F00-2FD52FF0-2FFB300430123013302030363037303E303F319031913196-319F31C0-31E33200-321E322A-32503260-327F328A-32B032C0-32FE3300-33FF4DC0-4DFFA490-A4C6A828-A82BA836A837A839AA77-AA79FDFDFFE4FFE8FFEDFFEEFFFCFFFD",
        Z: "002000A01680180E2000-200A20282029202F205F3000",
        Zs: "002000A01680180E2000-200A202F205F3000",
        Zl: "2028",
        Zp: "2029",
        C: "0000-001F007F-009F00AD03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-0605061C061D0620065F06DD070E070F074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17B417B517DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF200B-200F202A-202E2060-206F20722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-F8FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFD-FF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFFBFFFEFFFF",
        Cc: "0000-001F007F-009F",
        Cf: "00AD0600-060306DD070F17B417B5200B-200F202A-202E2060-2064206A-206FFEFFFFF9-FFFB",
        Co: "E000-F8FF",
        Cs: "D800-DFFF",
        Cn: "03780379037F-0383038B038D03A20526-05300557055805600588058B-059005C8-05CF05EB-05EF05F5-05FF06040605061C061D0620065F070E074B074C07B2-07BF07FB-07FF082E082F083F-08FF093A093B094F095609570973-097809800984098D098E0991099209A909B109B3-09B509BA09BB09C509C609C909CA09CF-09D609D8-09DB09DE09E409E509FC-0A000A040A0B-0A0E0A110A120A290A310A340A370A3A0A3B0A3D0A43-0A460A490A4A0A4E-0A500A52-0A580A5D0A5F-0A650A76-0A800A840A8E0A920AA90AB10AB40ABA0ABB0AC60ACA0ACE0ACF0AD1-0ADF0AE40AE50AF00AF2-0B000B040B0D0B0E0B110B120B290B310B340B3A0B3B0B450B460B490B4A0B4E-0B550B58-0B5B0B5E0B640B650B72-0B810B840B8B-0B8D0B910B96-0B980B9B0B9D0BA0-0BA20BA5-0BA70BAB-0BAD0BBA-0BBD0BC3-0BC50BC90BCE0BCF0BD1-0BD60BD8-0BE50BFB-0C000C040C0D0C110C290C340C3A-0C3C0C450C490C4E-0C540C570C5A-0C5F0C640C650C70-0C770C800C810C840C8D0C910CA90CB40CBA0CBB0CC50CC90CCE-0CD40CD7-0CDD0CDF0CE40CE50CF00CF3-0D010D040D0D0D110D290D3A-0D3C0D450D490D4E-0D560D58-0D5F0D640D650D76-0D780D800D810D840D97-0D990DB20DBC0DBE0DBF0DC7-0DC90DCB-0DCE0DD50DD70DE0-0DF10DF5-0E000E3B-0E3E0E5C-0E800E830E850E860E890E8B0E8C0E8E-0E930E980EA00EA40EA60EA80EA90EAC0EBA0EBE0EBF0EC50EC70ECE0ECF0EDA0EDB0EDE-0EFF0F480F6D-0F700F8C-0F8F0F980FBD0FCD0FD9-0FFF10C6-10CF10FD-10FF1249124E124F12571259125E125F1289128E128F12B112B612B712BF12C112C612C712D7131113161317135B-135E137D-137F139A-139F13F5-13FF169D-169F16F1-16FF170D1715-171F1737-173F1754-175F176D17711774-177F17DE17DF17EA-17EF17FA-17FF180F181A-181F1878-187F18AB-18AF18F6-18FF191D-191F192C-192F193C-193F1941-1943196E196F1975-197F19AC-19AF19CA-19CF19DB-19DD1A1C1A1D1A5F1A7D1A7E1A8A-1A8F1A9A-1A9F1AAE-1AFF1B4C-1B4F1B7D-1B7F1BAB-1BAD1BBA-1BFF1C38-1C3A1C4A-1C4C1C80-1CCF1CF3-1CFF1DE7-1DFC1F161F171F1E1F1F1F461F471F4E1F4F1F581F5A1F5C1F5E1F7E1F7F1FB51FC51FD41FD51FDC1FF01FF11FF51FFF2065-206920722073208F2095-209F20B9-20CF20F1-20FF218A-218F23E9-23FF2427-243F244B-245F26CE26E226E4-26E727002705270A270B2728274C274E2753-2755275F27602795-279727B027BF27CB27CD-27CF2B4D-2B4F2B5A-2BFF2C2F2C5F2CF2-2CF82D26-2D2F2D66-2D6E2D70-2D7F2D97-2D9F2DA72DAF2DB72DBF2DC72DCF2DD72DDF2E32-2E7F2E9A2EF4-2EFF2FD6-2FEF2FFC-2FFF3040309730983100-3104312E-3130318F31B8-31BF31E4-31EF321F32FF4DB6-4DBF9FCC-9FFFA48D-A48FA4C7-A4CFA62C-A63FA660A661A674-A67BA698-A69FA6F8-A6FFA78D-A7FAA82C-A82FA83A-A83FA878-A87FA8C5-A8CDA8DA-A8DFA8FC-A8FFA954-A95EA97D-A97FA9CEA9DA-A9DDA9E0-A9FFAA37-AA3FAA4EAA4FAA5AAA5BAA7C-AA7FAAC3-AADAAAE0-ABBFABEEABEFABFA-ABFFD7A4-D7AFD7C7-D7CAD7FC-D7FFFA2EFA2FFA6EFA6FFADA-FAFFFB07-FB12FB18-FB1CFB37FB3DFB3FFB42FB45FBB2-FBD2FD40-FD4FFD90FD91FDC8-FDEFFDFEFDFFFE1A-FE1FFE27-FE2FFE53FE67FE6C-FE6FFE75FEFDFEFEFF00FFBF-FFC1FFC8FFC9FFD0FFD1FFD8FFD9FFDD-FFDFFFE7FFEF-FFF8FFFEFFFF"
      });
      function addUnicodePackage(pack) {
        var codePoint = /\w{4}/g;
        for (var name in pack)
          exports.packages[name] = pack[name].replace(codePoint, "\\u$&");
      }
    });
    ace.define("ace/token_iterator", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var TokenIterator = function(session, initialRow, initialColumn) {
        this.$session = session;
        this.$row = initialRow;
        this.$rowTokens = session.getTokens(initialRow);
        var token = session.getTokenAt(initialRow, initialColumn);
        this.$tokenIndex = token ? token.index : -1;
      };
      (function() {
        this.stepBackward = function() {
          this.$tokenIndex -= 1;
          while (this.$tokenIndex < 0) {
            this.$row -= 1;
            if (this.$row < 0) {
              this.$row = 0;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = this.$rowTokens.length - 1;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        this.stepForward = function() {
          this.$tokenIndex += 1;
          var rowCount;
          while (this.$tokenIndex >= this.$rowTokens.length) {
            this.$row += 1;
            if (!rowCount)
              rowCount = this.$session.getLength();
            if (this.$row >= rowCount) {
              this.$row = rowCount - 1;
              return null;
            }
            this.$rowTokens = this.$session.getTokens(this.$row);
            this.$tokenIndex = 0;
          }
          return this.$rowTokens[this.$tokenIndex];
        };
        this.getCurrentToken = function() {
          return this.$rowTokens[this.$tokenIndex];
        };
        this.getCurrentTokenRow = function() {
          return this.$row;
        };
        this.getCurrentTokenColumn = function() {
          var rowTokens = this.$rowTokens;
          var tokenIndex = this.$tokenIndex;
          var column = rowTokens[tokenIndex].start;
          if (column !== undefined)
            return column;
          column = 0;
          while (tokenIndex > 0) {
            tokenIndex -= 1;
            column += rowTokens[tokenIndex].value.length;
          }
          return column;
        };
        this.getCurrentTokenPosition = function() {
          return {
            row: this.$row,
            column: this.getCurrentTokenColumn()
          };
        };
      }).call(TokenIterator.prototype);
      exports.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require, exports, module) {
      "use strict";
      var Tokenizer = require("../tokenizer").Tokenizer;
      var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
      var Behaviour = require("./behaviour").Behaviour;
      var unicode = require("../unicode");
      var lang = require("../lib/lang");
      var TokenIterator = require("../token_iterator").TokenIterator;
      var Range = require("../range").Range;
      var Mode = function() {
        this.HighlightRules = TextHighlightRules;
        this.$behaviour = new Behaviour();
      };
      (function() {
        this.tokenRe = new RegExp("^[" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.packages.L + unicode.packages.Mn + unicode.packages.Mc + unicode.packages.Nd + unicode.packages.Pc + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules();
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
          var doc = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment)
              return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function(line, i) {
              if (testRemove(line, i))
                return;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc.insertInLine({
                  row: i,
                  column: line.length
                }, lineCommentEnd);
                doc.insertInLine({
                  row: i,
                  column: minIndent
                }, lineCommentStart);
              }
            };
            var uncomment = function(line, i) {
              var m;
              if (m = line.match(regexpEnd))
                doc.removeInLine(i, line.length - m[0].length, line.length);
              if (m = line.match(regexpStart))
                doc.removeInLine(i, m[1].length, m[0].length);
            };
            var testRemove = function(line, row) {
              if (regexpStart.test(line))
                return true;
              var tokens = session.getTokens(row);
              for (var i = 0; i < tokens.length; i++) {
                if (tokens[i].type === "comment")
                  return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function(line, i) {
              var m = line.match(regexpStart);
              if (!m)
                return;
              var start = m[1].length,
                  end = m[0].length;
              if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ")
                end--;
              doc.removeInLine(i, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent))
                  doc.insertInLine({
                    row: i,
                    column: minIndent
                  }, commentWithSpace);
                else
                  doc.insertInLine({
                    row: i,
                    column: minIndent
                  }, lineCommentStart);
              }
            };
            var testRemove = function(line, i) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ")
                spaces++;
              if (spaces % tabSize != 0)
                return false;
              var spaces = 0;
              while (line.charAt(after++) == " ")
                spaces++;
              if (tabSize > 2)
                return spaces % tabSize != tabSize - 1;
              else
                return spaces % tabSize == 0;
              return true;
            };
          }
          function iter(fun) {
            for (var i = startRow; i <= endRow; i++)
              fun(doc.getLine(i), i);
          }
          var minEmptyLength = Infinity;
          iter(function(line, i) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent)
                minIndent = indent;
              if (shouldRemove && !testRemove(line, i))
                shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment)
            return;
          if (!comment.start && comment[0])
            comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          var sel = session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow,
              colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange,
                endRange;
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.start);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                startRange = new Range(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i = token.value.indexOf(comment.end);
              if (i != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i;
                endRange = new Range(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange)
              session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
          return false;
        };
        this.autoOutdent = function(state, doc, row) {};
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
          return null;
        };
        this.createModeDelegates = function(mapping) {
          this.$embeds = [];
          this.$modes = {};
          for (var i in mapping) {
            if (mapping[i]) {
              this.$embeds.push(i);
              this.$modes[i] = new mapping[i]();
            }
          }
          var delegations = ["toggleBlockComment", "toggleCommentLines", "getNextLineIndent", "checkOutdent", "autoOutdent", "transformAction", "getCompletions"];
          for (var i = 0; i < delegations.length; i++) {
            (function(scope) {
              var functionName = delegations[i];
              var defaultHandler = scope[functionName];
              scope[delegations[i]] = function() {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            }(this));
          }
        };
        this.$delegator = function(method, args, defaultHandler) {
          var state = args[0];
          if (typeof state != "string")
            state = state[0];
          for (var i = 0; i < this.$embeds.length; i++) {
            if (!this.$modes[this.$embeds[i]])
              continue;
            var split = state.split(this.$embeds[i]);
            if (!split[0] && split[1]) {
              args[0] = split[1];
              var mode = this.$modes[this.$embeds[i]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : undefined;
        };
        this.transformAction = function(state, action, editor, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function(append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer.rules;
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0,
                  l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token))
                    completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a = 0,
                      aLength = ruleItr[r].token.length; a < aLength; a++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append)
            return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
          if (!this.$highlightRules)
            this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function(word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports.Mode = Mode;
    });
    ace.define("ace/apply_delta", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      function throwDeltaError(delta, errorText) {
        console.log("Invalid Delta:", delta);
        throw "Invalid Delta: " + errorText;
      }
      function positionInDocument(docLines, position) {
        return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
      }
      function validateDelta(docLines, delta) {
        if (delta.action != "insert" && delta.action != "remove")
          throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
        if (!(delta.lines instanceof Array))
          throwDeltaError(delta, "delta.lines must be an Array");
        if (!delta.start || !delta.end)
          throwDeltaError(delta, "delta.start/end must be an present");
        var start = delta.start;
        if (!positionInDocument(docLines, delta.start))
          throwDeltaError(delta, "delta.start must be contained in document");
        var end = delta.end;
        if (delta.action == "remove" && !positionInDocument(docLines, end))
          throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
        var numRangeRows = end.row - start.row;
        var numRangeLastLineChars = (end.column - (numRangeRows == 0 ? start.column : 0));
        if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars)
          throwDeltaError(delta, "delta.range must match delta lines");
      }
      exports.applyDelta = function(docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var Anchor = exports.Anchor = function(doc, row, column) {
        this.$onChange = this.onChange.bind(this);
        this.attach(doc);
        if (typeof column == "undefined")
          this.setPosition(row.row, row.column);
        else
          this.setPosition(row, column);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.getPosition = function() {
          return this.$clipPositionToDocument(this.row, this.column);
        };
        this.getDocument = function() {
          return this.document;
        };
        this.$insertRight = false;
        this.onChange = function(delta) {
          if (delta.start.row == delta.end.row && delta.start.row != this.row)
            return;
          if (delta.start.row > this.row)
            return;
          var point = $getTransformedPoint(delta, {
            row: this.row,
            column: this.column
          }, this.$insertRight);
          this.setPosition(point.row, point.column, true);
        };
        function $pointsInOrder(point1, point2, equalPointsInOrder) {
          var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
          return (point1.row < point2.row) || (point1.row == point2.row && bColIsAfter);
        }
        function $getTransformedPoint(delta, point, moveIfEqual) {
          var deltaIsInsert = delta.action == "insert";
          var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
          var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
          var deltaStart = delta.start;
          var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
          if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
            return {
              row: point.row,
              column: point.column
            };
          }
          if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
            return {
              row: point.row + deltaRowShift,
              column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
            };
          }
          return {
            row: deltaStart.row,
            column: deltaStart.column
          };
        }
        this.setPosition = function(row, column, noClip) {
          var pos;
          if (noClip) {
            pos = {
              row: row,
              column: column
            };
          } else {
            pos = this.$clipPositionToDocument(row, column);
          }
          if (this.row == pos.row && this.column == pos.column)
            return;
          var old = {
            row: this.row,
            column: this.column
          };
          this.row = pos.row;
          this.column = pos.column;
          this._signal("change", {
            old: old,
            value: pos
          });
        };
        this.detach = function() {
          this.document.removeEventListener("change", this.$onChange);
        };
        this.attach = function(doc) {
          this.document = doc || this.document;
          this.document.on("change", this.$onChange);
        };
        this.$clipPositionToDocument = function(row, column) {
          var pos = {};
          if (row >= this.document.getLength()) {
            pos.row = Math.max(0, this.document.getLength() - 1);
            pos.column = this.document.getLine(pos.row).length;
          } else if (row < 0) {
            pos.row = 0;
            pos.column = 0;
          } else {
            pos.row = row;
            pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
          }
          if (column < 0)
            pos.column = 0;
          return pos;
        };
      }).call(Anchor.prototype);
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var applyDelta = require("./apply_delta").applyDelta;
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var Range = require("./range").Range;
      var Anchor = require("./anchor").Anchor;
      var Document = function(textOrLines) {
        this.$lines = [""];
        if (textOrLines.length === 0) {
          this.$lines = [""];
        } else if (Array.isArray(textOrLines)) {
          this.insertMergedLines({
            row: 0,
            column: 0
          }, textOrLines);
        } else {
          this.insert({
            row: 0,
            column: 0
          }, textOrLines);
        }
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setValue = function(text) {
          var len = this.getLength() - 1;
          this.remove(new Range(0, 0, len, this.getLine(len).length));
          this.insert({
            row: 0,
            column: 0
          }, text);
        };
        this.getValue = function() {
          return this.getAllLines().join(this.getNewLineCharacter());
        };
        this.createAnchor = function(row, column) {
          return new Anchor(this, row, column);
        };
        if ("aaa".split(/a/).length === 0) {
          this.$split = function(text) {
            return text.replace(/\r\n|\r/g, "\n").split("\n");
          };
        } else {
          this.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
          };
        }
        this.$detectNewLine = function(text) {
          var match = text.match(/^.*?(\r\n|\r|\n)/m);
          this.$autoNewLine = match ? match[1] : "\n";
          this._signal("changeNewLineMode");
        };
        this.getNewLineCharacter = function() {
          switch (this.$newLineMode) {
            case "windows":
              return "\r\n";
            case "unix":
              return "\n";
            default:
              return this.$autoNewLine || "\n";
          }
        };
        this.$autoNewLine = "";
        this.$newLineMode = "auto";
        this.setNewLineMode = function(newLineMode) {
          if (this.$newLineMode === newLineMode)
            return;
          this.$newLineMode = newLineMode;
          this._signal("changeNewLineMode");
        };
        this.getNewLineMode = function() {
          return this.$newLineMode;
        };
        this.isNewLine = function(text) {
          return (text == "\r\n" || text == "\r" || text == "\n");
        };
        this.getLine = function(row) {
          return this.$lines[row] || "";
        };
        this.getLines = function(firstRow, lastRow) {
          return this.$lines.slice(firstRow, lastRow + 1);
        };
        this.getAllLines = function() {
          return this.getLines(0, this.getLength());
        };
        this.getLength = function() {
          return this.$lines.length;
        };
        this.getTextRange = function(range) {
          return this.getLinesForRange(range).join(this.getNewLineCharacter());
        };
        this.getLinesForRange = function(range) {
          var lines;
          if (range.start.row === range.end.row) {
            lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
          } else {
            lines = this.getLines(range.start.row, range.end.row);
            lines[0] = (lines[0] || "").substring(range.start.column);
            var l = lines.length - 1;
            if (range.end.row - range.start.row == l)
              lines[l] = lines[l].substring(0, range.end.column);
          }
          return lines;
        };
        this.insertLines = function(row, lines) {
          console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
          return this.insertFullLines(row, lines);
        };
        this.removeLines = function(firstRow, lastRow) {
          console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
          return this.removeFullLines(firstRow, lastRow);
        };
        this.insertNewLine = function(position) {
          console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, [\'\', \'\']) instead.");
          return this.insertMergedLines(position, ["", ""]);
        };
        this.insert = function(position, text) {
          if (this.getLength() <= 1)
            this.$detectNewLine(text);
          return this.insertMergedLines(position, this.$split(text));
        };
        this.insertInLine = function(position, text) {
          var start = this.clippedPos(position.row, position.column);
          var end = this.pos(position.row, position.column + text.length);
          this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: [text]
          }, true);
          return this.clonePos(end);
        };
        this.clippedPos = function(row, column) {
          var length = this.getLength();
          if (row === undefined) {
            row = length;
          } else if (row < 0) {
            row = 0;
          } else if (row >= length) {
            row = length - 1;
            column = undefined;
          }
          var line = this.getLine(row);
          if (column == undefined)
            column = line.length;
          column = Math.min(Math.max(column, 0), line.length);
          return {
            row: row,
            column: column
          };
        };
        this.clonePos = function(pos) {
          return {
            row: pos.row,
            column: pos.column
          };
        };
        this.pos = function(row, column) {
          return {
            row: row,
            column: column
          };
        };
        this.$clipPosition = function(position) {
          var length = this.getLength();
          if (position.row >= length) {
            position.row = Math.max(0, length - 1);
            position.column = this.getLine(length - 1).length;
          } else {
            position.row = Math.max(0, position.row);
            position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
          }
          return position;
        };
        this.insertFullLines = function(row, lines) {
          row = Math.min(Math.max(row, 0), this.getLength());
          var column = 0;
          if (row < this.getLength()) {
            lines = lines.concat([""]);
            column = 0;
          } else {
            lines = [""].concat(lines);
            row--;
            column = this.$lines[row].length;
          }
          this.insertMergedLines({
            row: row,
            column: column
          }, lines);
        };
        this.insertMergedLines = function(position, lines) {
          var start = this.clippedPos(position.row, position.column);
          var end = {
            row: start.row + lines.length - 1,
            column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
          };
          this.applyDelta({
            start: start,
            end: end,
            action: "insert",
            lines: lines
          });
          return this.clonePos(end);
        };
        this.remove = function(range) {
          var start = this.clippedPos(range.start.row, range.start.column);
          var end = this.clippedPos(range.end.row, range.end.column);
          this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({
              start: start,
              end: end
            })
          });
          return this.clonePos(start);
        };
        this.removeInLine = function(row, startColumn, endColumn) {
          var start = this.clippedPos(row, startColumn);
          var end = this.clippedPos(row, endColumn);
          this.applyDelta({
            start: start,
            end: end,
            action: "remove",
            lines: this.getLinesForRange({
              start: start,
              end: end
            })
          }, true);
          return this.clonePos(start);
        };
        this.removeFullLines = function(firstRow, lastRow) {
          firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
          lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
          var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
          var deleteLastNewLine = lastRow < this.getLength() - 1;
          var startRow = (deleteFirstNewLine ? firstRow - 1 : firstRow);
          var startCol = (deleteFirstNewLine ? this.getLine(startRow).length : 0);
          var endRow = (deleteLastNewLine ? lastRow + 1 : lastRow);
          var endCol = (deleteLastNewLine ? 0 : this.getLine(endRow).length);
          var range = new Range(startRow, startCol, endRow, endCol);
          var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
          this.applyDelta({
            start: range.start,
            end: range.end,
            action: "remove",
            lines: this.getLinesForRange(range)
          });
          return deletedLines;
        };
        this.removeNewLine = function(row) {
          if (row < this.getLength() - 1 && row >= 0) {
            this.applyDelta({
              start: this.pos(row, this.getLine(row).length),
              end: this.pos(row + 1, 0),
              action: "remove",
              lines: ["", ""]
            });
          }
        };
        this.replace = function(range, text) {
          if (!(range instanceof Range))
            range = Range.fromPoints(range.start, range.end);
          if (text.length === 0 && range.isEmpty())
            return range.start;
          if (text == this.getTextRange(range))
            return range.end;
          this.remove(range);
          var end;
          if (text) {
            end = this.insert(range.start, text);
          } else {
            end = range.start;
          }
          return end;
        };
        this.applyDeltas = function(deltas) {
          for (var i = 0; i < deltas.length; i++) {
            this.applyDelta(deltas[i]);
          }
        };
        this.revertDeltas = function(deltas) {
          for (var i = deltas.length - 1; i >= 0; i--) {
            this.revertDelta(deltas[i]);
          }
        };
        this.applyDelta = function(delta, doNotValidate) {
          var isInsert = delta.action == "insert";
          if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
            return;
          }
          if (isInsert && delta.lines.length > 20000)
            this.$splitAndapplyLargeDelta(delta, 20000);
          applyDelta(this.$lines, delta, doNotValidate);
          this._signal("change", delta);
        };
        this.$splitAndapplyLargeDelta = function(delta, MAX) {
          var lines = delta.lines;
          var l = lines.length;
          var row = delta.start.row;
          var column = delta.start.column;
          var from = 0,
              to = 0;
          do {
            from = to;
            to += MAX - 1;
            var chunk = lines.slice(from, to);
            if (to > l) {
              delta.lines = chunk;
              delta.start.row = row + from;
              delta.start.column = column;
              break;
            }
            chunk.push("");
            this.applyDelta({
              start: this.pos(row + from, column),
              end: this.pos(row + to, column = 0),
              action: delta.action,
              lines: chunk
            }, true);
          } while (true);
        };
        this.revertDelta = function(delta) {
          this.applyDelta({
            start: this.clonePos(delta.start),
            end: this.clonePos(delta.end),
            action: (delta.action == "insert" ? "remove" : "insert"),
            lines: delta.lines.slice()
          });
        };
        this.indexToPosition = function(index, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          for (var i = startRow || 0,
              l = lines.length; i < l; i++) {
            index -= lines[i].length + newlineLength;
            if (index < 0)
              return {
                row: i,
                column: index + lines[i].length + newlineLength
              };
          }
          return {
            row: l - 1,
            column: lines[l - 1].length
          };
        };
        this.positionToIndex = function(pos, startRow) {
          var lines = this.$lines || this.getAllLines();
          var newlineLength = this.getNewLineCharacter().length;
          var index = 0;
          var row = Math.min(pos.row, lines.length);
          for (var i = startRow || 0; i < row; ++i)
            index += lines[i].length + newlineLength;
          return index + pos.column;
        };
      }).call(Document.prototype);
      exports.Document = Document;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = function(tokenizer, editor) {
        this.running = false;
        this.lines = [];
        this.states = [];
        this.currentLine = 0;
        this.tokenizer = tokenizer;
        var self = this;
        this.$worker = function() {
          if (!self.running) {
            return;
          }
          var workerStart = new Date();
          var currentLine = self.currentLine;
          var endLine = -1;
          var doc = self.doc;
          var startLine = currentLine;
          while (self.lines[currentLine])
            currentLine++;
          var len = doc.getLength();
          var processedLines = 0;
          self.running = false;
          while (currentLine < len) {
            self.$tokenizeRow(currentLine);
            endLine = currentLine;
            do {
              currentLine++;
            } while (self.lines[currentLine]);
            processedLines++;
            if ((processedLines % 5 === 0) && (new Date() - workerStart) > 20) {
              self.running = setTimeout(self.$worker, 20);
              break;
            }
          }
          self.currentLine = currentLine;
          if (startLine <= endLine)
            self.fireUpdateEvent(startLine, endLine);
        };
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setTokenizer = function(tokenizer) {
          this.tokenizer = tokenizer;
          this.lines = [];
          this.states = [];
          this.start(0);
        };
        this.setDocument = function(doc) {
          this.doc = doc;
          this.lines = [];
          this.states = [];
          this.stop();
        };
        this.fireUpdateEvent = function(firstRow, lastRow) {
          var data = {
            first: firstRow,
            last: lastRow
          };
          this._signal("update", {data: data});
        };
        this.start = function(startRow) {
          this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
          this.lines.splice(this.currentLine, this.lines.length);
          this.states.splice(this.currentLine, this.states.length);
          this.stop();
          this.running = setTimeout(this.$worker, 700);
        };
        this.scheduleStart = function() {
          if (!this.running)
            this.running = setTimeout(this.$worker, 700);
        };
        this.$updateOnChange = function(delta) {
          var startRow = delta.start.row;
          var len = delta.end.row - startRow;
          if (len === 0) {
            this.lines[startRow] = null;
          } else if (delta.action == "remove") {
            this.lines.splice(startRow, len + 1, null);
            this.states.splice(startRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(startRow, 1);
            this.lines.splice.apply(this.lines, args);
            this.states.splice.apply(this.states, args);
          }
          this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
          this.stop();
        };
        this.stop = function() {
          if (this.running)
            clearTimeout(this.running);
          this.running = false;
        };
        this.getTokens = function(row) {
          return this.lines[row] || this.$tokenizeRow(row);
        };
        this.getState = function(row) {
          if (this.currentLine == row)
            this.$tokenizeRow(row);
          return this.states[row] || "start";
        };
        this.$tokenizeRow = function(row) {
          var line = this.doc.getLine(row);
          var state = this.states[row - 1];
          var data = this.tokenizer.getLineTokens(line, state, row);
          if (this.states[row] + "" !== data.state + "") {
            this.states[row] = data.state;
            this.lines[row + 1] = null;
            if (this.currentLine > row + 1)
              this.currentLine = row + 1;
          } else if (this.currentLine == row) {
            this.currentLine = row + 1;
          }
          return this.lines[row] = data.tokens;
        };
      }).call(BackgroundTokenizer.prototype);
      exports.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require, exports, module) {
      "use strict";
      var lang = require("./lib/lang");
      var oop = require("./lib/oop");
      var Range = require("./range").Range;
      var SearchHighlight = function(regExp, clazz, type) {
        this.setRegexp(regExp);
        this.clazz = clazz;
        this.type = type || "text";
      };
      (function() {
        this.MAX_RANGES = 500;
        this.setRegexp = function(regExp) {
          if (this.regExp + "" == regExp + "")
            return;
          this.regExp = regExp;
          this.cache = [];
        };
        this.update = function(html, markerLayer, session, config) {
          if (!this.regExp)
            return;
          var start = config.firstRow,
              end = config.lastRow;
          for (var i = start; i <= end; i++) {
            var ranges = this.cache[i];
            if (ranges == null) {
              ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
              if (ranges.length > this.MAX_RANGES)
                ranges = ranges.slice(0, this.MAX_RANGES);
              ranges = ranges.map(function(match) {
                return new Range(i, match.offset, i, match.offset + match.length);
              });
              this.cache[i] = ranges.length ? ranges : "";
            }
            for (var j = ranges.length; j--; ) {
              markerLayer.drawSingleLineMarker(html, ranges[j].toScreenRange(session), this.clazz, config);
            }
          }
        };
      }).call(SearchHighlight.prototype);
      exports.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require, exports, module) {
      "use strict";
      var Range = require("../range").Range;
      function FoldLine(foldData, folds) {
        this.foldData = foldData;
        if (Array.isArray(folds)) {
          this.folds = folds;
        } else {
          folds = this.folds = [folds];
        }
        var last = folds[folds.length - 1];
        this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
        this.start = this.range.start;
        this.end = this.range.end;
        this.folds.forEach(function(fold) {
          fold.setFoldLine(this);
        }, this);
      }
      (function() {
        this.shiftRow = function(shift) {
          this.start.row += shift;
          this.end.row += shift;
          this.folds.forEach(function(fold) {
            fold.start.row += shift;
            fold.end.row += shift;
          });
        };
        this.addFold = function(fold) {
          if (fold.sameRow) {
            if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
              throw new Error("Can't add a fold to this FoldLine as it has no connection");
            }
            this.folds.push(fold);
            this.folds.sort(function(a, b) {
              return -a.range.compareEnd(b.start.row, b.start.column);
            });
            if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            }
          } else if (fold.start.row == this.end.row) {
            this.folds.push(fold);
            this.end.row = fold.end.row;
            this.end.column = fold.end.column;
          } else if (fold.end.row == this.start.row) {
            this.folds.unshift(fold);
            this.start.row = fold.start.row;
            this.start.column = fold.start.column;
          } else {
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
          }
          fold.foldLine = this;
        };
        this.containsRow = function(row) {
          return row >= this.start.row && row <= this.end.row;
        };
        this.walk = function(callback, endRow, endColumn) {
          var lastEnd = 0,
              folds = this.folds,
              fold,
              cmp,
              stop,
              isNewRow = true;
          if (endRow == null) {
            endRow = this.end.row;
            endColumn = this.end.column;
          }
          for (var i = 0; i < folds.length; i++) {
            fold = folds[i];
            cmp = fold.range.compareStart(endRow, endColumn);
            if (cmp == -1) {
              callback(null, endRow, endColumn, lastEnd, isNewRow);
              return;
            }
            stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
            stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
            if (stop || cmp === 0) {
              return;
            }
            isNewRow = !fold.sameRow;
            lastEnd = fold.end.column;
          }
          callback(null, endRow, endColumn, lastEnd, isNewRow);
        };
        this.getNextFoldTo = function(row, column) {
          var fold,
              cmp;
          for (var i = 0; i < this.folds.length; i++) {
            fold = this.folds[i];
            cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              return {
                fold: fold,
                kind: "after"
              };
            } else if (cmp === 0) {
              return {
                fold: fold,
                kind: "inside"
              };
            }
          }
          return null;
        };
        this.addRemoveChars = function(row, column, len) {
          var ret = this.getNextFoldTo(row, column),
              fold,
              folds;
          if (ret) {
            fold = ret.fold;
            if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
              window.console && window.console.log(row, column, fold);
            } else if (fold.start.row == row) {
              folds = this.folds;
              var i = folds.indexOf(fold);
              if (i === 0) {
                this.start.column += len;
              }
              for (i; i < folds.length; i++) {
                fold = folds[i];
                fold.start.column += len;
                if (!fold.sameRow) {
                  return;
                }
                fold.end.column += len;
              }
              this.end.column += len;
            }
          }
        };
        this.split = function(row, column) {
          var pos = this.getNextFoldTo(row, column);
          if (!pos || pos.kind == "inside")
            return null;
          var fold = pos.fold;
          var folds = this.folds;
          var foldData = this.foldData;
          var i = folds.indexOf(fold);
          var foldBefore = folds[i - 1];
          this.end.row = foldBefore.end.row;
          this.end.column = foldBefore.end.column;
          folds = folds.splice(i, folds.length - i);
          var newFoldLine = new FoldLine(foldData, folds);
          foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
          return newFoldLine;
        };
        this.merge = function(foldLineNext) {
          var folds = foldLineNext.folds;
          for (var i = 0; i < folds.length; i++) {
            this.addFold(folds[i]);
          }
          var foldData = this.foldData;
          foldData.splice(foldData.indexOf(foldLineNext), 1);
        };
        this.toString = function() {
          var ret = [this.range.toString() + ": ["];
          this.folds.forEach(function(fold) {
            ret.push("  " + fold.toString());
          });
          ret.push("]");
          return ret.join("\n");
        };
        this.idxToPosition = function(idx) {
          var lastFoldEndColumn = 0;
          for (var i = 0; i < this.folds.length; i++) {
            var fold = this.folds[i];
            idx -= fold.start.column - lastFoldEndColumn;
            if (idx < 0) {
              return {
                row: fold.start.row,
                column: fold.start.column + idx
              };
            }
            idx -= fold.placeholder.length;
            if (idx < 0) {
              return fold.start;
            }
            lastFoldEndColumn = fold.end.column;
          }
          return {
            row: this.end.row,
            column: this.end.column + idx
          };
        };
      }).call(FoldLine.prototype);
      exports.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require, exports, module) {
      "use strict";
      var Range = require("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = function() {
        this.ranges = [];
      };
      (function() {
        this.comparePoints = comparePoints;
        this.pointIndex = function(pos, excludeEdges, startIndex) {
          var list = this.ranges;
          for (var i = startIndex || 0; i < list.length; i++) {
            var range = list[i];
            var cmpEnd = comparePoints(pos, range.end);
            if (cmpEnd > 0)
              continue;
            var cmpStart = comparePoints(pos, range.start);
            if (cmpEnd === 0)
              return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
            if (cmpStart > 0 || (cmpStart === 0 && !excludeEdges))
              return i;
            return -i - 1;
          }
          return -i - 1;
        };
        this.add = function(range) {
          var excludeEdges = !range.isEmpty();
          var startIndex = this.pointIndex(range.start, excludeEdges);
          if (startIndex < 0)
            startIndex = -startIndex - 1;
          var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
          if (endIndex < 0)
            endIndex = -endIndex - 1;
          else
            endIndex++;
          return this.ranges.splice(startIndex, endIndex - startIndex, range);
        };
        this.addList = function(list) {
          var removed = [];
          for (var i = list.length; i--; ) {
            removed.push.apply(removed, this.add(list[i]));
          }
          return removed;
        };
        this.substractPoint = function(pos) {
          var i = this.pointIndex(pos);
          if (i >= 0)
            return this.ranges.splice(i, 1);
        };
        this.merge = function() {
          var removed = [];
          var list = this.ranges;
          list = list.sort(function(a, b) {
            return comparePoints(a.start, b.start);
          });
          var next = list[0],
              range;
          for (var i = 1; i < list.length; i++) {
            range = next;
            next = list[i];
            var cmp = comparePoints(range.end, next.start);
            if (cmp < 0)
              continue;
            if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
              continue;
            if (comparePoints(range.end, next.end) < 0) {
              range.end.row = next.end.row;
              range.end.column = next.end.column;
            }
            list.splice(i, 1);
            removed.push(next);
            next = range;
            i--;
          }
          this.ranges = list;
          return removed;
        };
        this.contains = function(row, column) {
          return this.pointIndex({
            row: row,
            column: column
          }) >= 0;
        };
        this.containsPoint = function(pos) {
          return this.pointIndex(pos) >= 0;
        };
        this.rangeAtPoint = function(pos) {
          var i = this.pointIndex(pos);
          if (i >= 0)
            return this.ranges[i];
        };
        this.clipRows = function(startRow, endRow) {
          var list = this.ranges;
          if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
            return [];
          var startIndex = this.pointIndex({
            row: startRow,
            column: 0
          });
          if (startIndex < 0)
            startIndex = -startIndex - 1;
          var endIndex = this.pointIndex({
            row: endRow,
            column: 0
          }, startIndex);
          if (endIndex < 0)
            endIndex = -endIndex - 1;
          var clipped = [];
          for (var i = startIndex; i < endIndex; i++) {
            clipped.push(list[i]);
          }
          return clipped;
        };
        this.removeAll = function() {
          return this.ranges.splice(0, this.ranges.length);
        };
        this.attach = function(session) {
          if (this.session)
            this.detach();
          this.session = session;
          this.onChange = this.$onChange.bind(this);
          this.session.on('change', this.onChange);
        };
        this.detach = function() {
          if (!this.session)
            return;
          this.session.removeListener('change', this.onChange);
          this.session = null;
        };
        this.$onChange = function(delta) {
          if (delta.action == "insert") {
            var start = delta.start;
            var end = delta.end;
          } else {
            var end = delta.start;
            var start = delta.end;
          }
          var startRow = start.row;
          var endRow = end.row;
          var lineDif = endRow - startRow;
          var colDiff = -start.column + end.column;
          var ranges = this.ranges;
          for (var i = 0,
              n = ranges.length; i < n; i++) {
            var r = ranges[i];
            if (r.end.row < startRow)
              continue;
            if (r.start.row > startRow)
              break;
            if (r.start.row == startRow && r.start.column >= start.column) {
              if (r.start.column == start.column && this.$insertRight) {} else {
                r.start.column += colDiff;
                r.start.row += lineDif;
              }
            }
            if (r.end.row == startRow && r.end.column >= start.column) {
              if (r.end.column == start.column && this.$insertRight) {
                continue;
              }
              if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column)
                  r.end.column -= colDiff;
              }
              r.end.column += colDiff;
              r.end.row += lineDif;
            }
          }
          if (lineDif != 0 && i < n) {
            for (; i < n; i++) {
              var r = ranges[i];
              r.start.row += lineDif;
              r.end.row += lineDif;
            }
          }
        };
      }).call(RangeList.prototype);
      exports.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range", "ace/range_list", "ace/lib/oop"], function(require, exports, module) {
      "use strict";
      var Range = require("../range").Range;
      var RangeList = require("../range_list").RangeList;
      var oop = require("../lib/oop");
      var Fold = exports.Fold = function(range, placeholder) {
        this.foldLine = null;
        this.placeholder = placeholder;
        this.range = range;
        this.start = range.start;
        this.end = range.end;
        this.sameRow = range.start.row == range.end.row;
        this.subFolds = this.ranges = [];
      };
      oop.inherits(Fold, RangeList);
      (function() {
        this.toString = function() {
          return '"' + this.placeholder + '" ' + this.range.toString();
        };
        this.setFoldLine = function(foldLine) {
          this.foldLine = foldLine;
          this.subFolds.forEach(function(fold) {
            fold.setFoldLine(foldLine);
          });
        };
        this.clone = function() {
          var range = this.range.clone();
          var fold = new Fold(range, this.placeholder);
          this.subFolds.forEach(function(subFold) {
            fold.subFolds.push(subFold.clone());
          });
          fold.collapseChildren = this.collapseChildren;
          return fold;
        };
        this.addSubFold = function(fold) {
          if (this.range.isEqual(fold))
            return;
          if (!this.range.containsRange(fold))
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
          consumeRange(fold, this.start);
          var row = fold.start.row,
              column = fold.start.column;
          for (var i = 0,
              cmp = -1; i < this.subFolds.length; i++) {
            cmp = this.subFolds[i].range.compare(row, column);
            if (cmp != 1)
              break;
          }
          var afterStart = this.subFolds[i];
          if (cmp == 0)
            return afterStart.addSubFold(fold);
          var row = fold.range.end.row,
              column = fold.range.end.column;
          for (var j = i,
              cmp = -1; j < this.subFolds.length; j++) {
            cmp = this.subFolds[j].range.compare(row, column);
            if (cmp != 1)
              break;
          }
          var afterEnd = this.subFolds[j];
          if (cmp == 0)
            throw new Error("A fold can't intersect already existing fold" + fold.range + this.range);
          var consumedFolds = this.subFolds.splice(i, j - i, fold);
          fold.setFoldLine(this.foldLine);
          return fold;
        };
        this.restoreRange = function(range) {
          return restoreRange(range, this.start);
        };
      }).call(Fold.prototype);
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
          point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0)
          point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator"], function(require, exports, module) {
      "use strict";
      var Range = require("../range").Range;
      var FoldLine = require("./fold_line").FoldLine;
      var Fold = require("./fold").Fold;
      var TokenIterator = require("../token_iterator").TokenIterator;
      function Folding() {
        this.getFoldAt = function(row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine)
            return null;
          var folds = foldLine.folds;
          for (var i = 0; i < folds.length; i++) {
            var fold = folds[i];
            if (fold.range.contains(row, column)) {
              if (side == 1 && fold.range.isEnd(row, column)) {
                continue;
              } else if (side == -1 && fold.range.isStart(row, column)) {
                continue;
              }
              return fold;
            }
          }
        };
        this.getFoldsInRange = function(range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i = 0; i < foldLines.length; i++) {
            var cmp = foldLines[i].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i].folds;
            for (var j = 0; j < folds.length; j++) {
              var fold = folds[j];
              cmp = fold.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function() {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i = 0; i < foldLines.length; i++)
            for (var j = 0; j < foldLines[i].folds.length; j++)
              folds.push(foldLines[i].folds[j]);
          return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine)
            return null;
          var lastFold = {end: {column: 0}};
          var str,
              fold;
          for (var i = 0; i < foldLine.folds.length; i++) {
            fold = foldLine.folds[i];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold;
          }
          if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
          if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
          else if (trim == 1)
            return str.substring(column - lastFold.end.column);
          else
            return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i = 0;
          if (startFoldLine)
            i = foldData.indexOf(startFoldLine);
          if (i == -1)
            i = 0;
          for (i; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function(first, last) {
          var foldData = this.$foldData,
              rowCount = last - first + 1;
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i],
                end = foldLine.end.row,
                start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first)
                  rowCount -= last - start;
                else
                  rowCount = 0;
              }
              break;
            } else if (end >= first) {
              if (start >= first)
                rowCount -= end - start;
              else
                rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function(a, b) {
            return a.start.row - b.start.row;
          });
          return foldLine;
        };
        this.addFold = function(placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold;
          if (placeholder instanceof Fold)
            fold = placeholder;
          else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold.range);
          var startRow = fold.start.row;
          var startColumn = fold.start.column;
          var endRow = fold.end.row;
          var endColumn = fold.end.column;
          if (!(startRow < endRow || startRow == endRow && startColumn <= endColumn - 2))
            throw new Error("The range has to be at least 2 characters width");
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);
          if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            folds.forEach(function(subFold) {
              fold.addSubFold(subFold);
            });
          }
          for (var i = 0; i < foldData.length; i++) {
            var foldLine = foldData[i];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold);
              added = true;
              if (!fold.sameRow) {
                var foldLineNext = foldData[i + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
          if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
          else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._signal("changeFold", {
            data: fold,
            action: "add"
          });
          return fold;
        };
        this.addFolds = function(folds) {
          folds.forEach(function(fold) {
            this.addFold(fold);
          }, this);
        };
        this.removeFold = function(fold) {
          var foldLine = fold.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
          } else {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode)
              this.$updateWrapData(startRow, endRow);
            else
              this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._signal("changeFold", {
            data: fold,
            action: "remove"
          });
        };
        this.removeFolds = function(folds) {
          var cloneFolds = [];
          for (var i = 0; i < folds.length; i++) {
            cloneFolds.push(folds[i]);
          }
          cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function(fold) {
          this.removeFold(fold);
          fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
          }
          fold.subFolds = [];
        };
        this.expandFolds = function(folds) {
          folds.forEach(function(fold) {
            this.expandFold(fold);
          }, this);
        };
        this.unfold = function(location, expandInner) {
          var range,
              folds;
          if (location == null) {
            range = new Range(0, 0, this.getLength(), 0);
            expandInner = true;
          } else if (typeof location == "number")
            range = new Range(location, 0, location, this.getLine(location).length);
          else if ("row" in location)
            range = Range.fromPoints(location, location);
          else
            range = location;
          folds = this.getFoldsInRangeList(range);
          if (expandInner) {
            this.removeFolds(folds);
          } else {
            var subFolds = folds;
            while (subFolds.length) {
              this.expandFolds(subFolds);
              subFolds = this.getFoldsInRangeList(range);
            }
          }
          if (folds.length)
            return folds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null)
            startRow = foldLine.start.row;
          if (startColumn == null)
            startColumn = 0;
          if (endRow == null)
            endRow = foldLine.end.row;
          if (endColumn == null)
            endColumn = this.getLine(endRow).length;
          var doc = this.doc;
          var textLine = "";
          foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
              return;
            if (row == startRow) {
              if (column < startColumn)
                return;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function() {
          var fd = [];
          fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
              return fold.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function(tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
              this.expandFold(fold);
              return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({
              row: cursor.row,
              column: cursor.column + 1
            })) {
              if (range.comparePoint(bracketPos) == 1)
                range.end = bracketPos;
              else
                range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return;
            } else if (folds.length == 1) {
              fold = folds[0];
            }
          }
          if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
          if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
              return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          if (token && /^comment|string/.test(token.type)) {
            var range = new Range();
            var re = new RegExp(token.type.replace(/\..*/, "\\."));
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re.test(token.type));
              iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + 2;
            iterator = new TokenIterator(this, row, column);
            if (dir != -1) {
              do {
                token = iterator.stepForward();
              } while (token && re.test(token.type));
              token = iterator.stepBackward();
            } else
              token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn() + token.value.length - 2;
            return range;
          }
        };
        this.foldAll = function(startRow, endRow, depth) {
          if (depth == undefined)
            depth = 100000;
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets)
            return;
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
              foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
              continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              try {
                var fold = this.addFold("...", range);
                if (fold)
                  fold.collapseChildren = depth;
              } catch (e) {}
            }
          }
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
          if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style)
            return;
          this.$foldStyle = style;
          if (style == "manual")
            this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
          if (this.$foldMode == foldMode)
            return;
          this.$foldMode = foldMode;
          this.off('change', this.$updateFoldWidgets);
          this.off('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
          this._signal("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
          this.on('change', this.$updateFoldWidgets);
          this.on('tokenizerUpdate', this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || (ignoreCurrent && fw[row]))
            return {};
          var i = row - 1,
              firstRange;
          while (i >= 0) {
            var c = fw[i];
            if (c == null)
              c = fw[i] = this.getFoldWidget(i);
            if (c == "start") {
              var range = this.getFoldWidgetRange(i);
              if (!firstRange)
                firstRange = range;
              if (range && range.end.row >= row)
                break;
            }
            i--;
          }
          return {
            range: i !== -1 && range,
            firstRange: firstRange
          };
        };
        this.onFoldWidgetClick = function(row, e) {
          e = e.domEvent;
          var options = {
            children: e.shiftKey,
            all: e.ctrlKey || e.metaKey,
            siblings: e.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = (e.target || e.srcElement);
            if (el && /ace_fold-widget/.test(el.className))
              el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function(row, options) {
          if (!this.getFoldWidget)
            return;
          var type = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type === "end" ? -1 : 1;
          var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold) {
            if (options.children || options.all)
              this.removeFold(fold);
            else
              this.expandFold(fold);
            return;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
              this.removeFold(fold);
              return;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 10000 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
          } else if (range) {
            if (options.all)
              range.collapseChildren = 10000;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range)
            return;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
              this.removeFold(fold);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function(delta) {
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == 'remove') {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
        this.tokenizerUpdateFoldWidgets = function(e) {
          var rows = e.data;
          if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
              this.foldWidgets.splice(rows.first, this.foldWidgets.length);
          }
        };
      }
      exports.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require, exports, module) {
      "use strict";
      var TokenIterator = require("../token_iterator").TokenIterator;
      var Range = require("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function(position, chr) {
          if (position.column == 0)
            return null;
          var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
          if (charBeforeCursor == "")
            return null;
          var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match)
            return null;
          if (match[1])
            return this.$findClosingBracket(match[1], position);
          else
            return this.$findOpeningBracket(match[2], position);
        };
        this.getBracketRange = function(pos) {
          var line = this.getLine(pos.row);
          var before = true,
              range;
          var chr = line.charAt(pos.column - 1);
          var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match) {
            chr = line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match)
            return null;
          if (match[1]) {
            var bracketPos = this.$findClosingBracket(match[1], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match[2], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{"
        };
        this.$findOpeningBracket = function(bracket, position, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function(bracket, position, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            valueIndex = 0;
          }
          return null;
        };
      }
      exports.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var lang = require("./lib/lang");
      var config = require("./config");
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var Selection = require("./selection").Selection;
      var TextMode = require("./mode/text").Mode;
      var Range = require("./range").Range;
      var Document = require("./document").Document;
      var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = require("./search_highlight").SearchHighlight;
      var EditSession = function(text, mode) {
        this.$breakpoints = [];
        this.$decorations = [];
        this.$frontMarkers = {};
        this.$backMarkers = {};
        this.$markerId = 1;
        this.$undoSelect = true;
        this.$foldData = [];
        this.$foldData.toString = function() {
          return this.join("\n");
        };
        this.on("changeFold", this.onChangeFold.bind(this));
        this.$onChange = this.onChange.bind(this);
        if (typeof text != "object" || !text.getLine)
          text = new Document(text);
        this.setDocument(text);
        this.selection = new Selection(this);
        config.resetOptions(this);
        this.setMode(mode);
        config._signal("session", this);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setDocument = function(doc) {
          if (this.doc)
            this.doc.removeListener("change", this.$onChange);
          this.doc = doc;
          doc.on("change", this.$onChange);
          if (this.bgTokenizer)
            this.bgTokenizer.setDocument(this.getDocument());
          this.resetCaches();
        };
        this.getDocument = function() {
          return this.doc;
        };
        this.$resetRowCache = function(docRow) {
          if (!docRow) {
            this.$docRowCache = [];
            this.$screenRowCache = [];
            return;
          }
          var l = this.$docRowCache.length;
          var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
          if (l > i) {
            this.$docRowCache.splice(i, l);
            this.$screenRowCache.splice(i, l);
          }
        };
        this.$getRowCacheIndex = function(cacheArray, val) {
          var low = 0;
          var hi = cacheArray.length - 1;
          while (low <= hi) {
            var mid = (low + hi) >> 1;
            var c = cacheArray[mid];
            if (val > c)
              low = mid + 1;
            else if (val < c)
              hi = mid - 1;
            else
              return mid;
          }
          return low - 1;
        };
        this.resetCaches = function() {
          this.$modified = true;
          this.$wrapData = [];
          this.$rowLengthCache = [];
          this.$resetRowCache(0);
          if (this.bgTokenizer)
            this.bgTokenizer.start(0);
        };
        this.onChangeFold = function(e) {
          var fold = e.data;
          this.$resetRowCache(fold.start.row);
        };
        this.onChange = function(delta) {
          this.$modified = true;
          this.$resetRowCache(delta.start.row);
          var removedFolds = this.$updateInternalDataOnChange(delta);
          if (!this.$fromUndo && this.$undoManager && !delta.ignore) {
            this.$deltasDoc.push(delta);
            if (removedFolds && removedFolds.length != 0) {
              this.$deltasFold.push({
                action: "removeFolds",
                folds: removedFolds
              });
            }
            this.$informUndoManager.schedule();
          }
          this.bgTokenizer && this.bgTokenizer.$updateOnChange(delta);
          this._signal("change", delta);
        };
        this.setValue = function(text) {
          this.doc.setValue(text);
          this.selection.moveTo(0, 0);
          this.$resetRowCache(0);
          this.$deltas = [];
          this.$deltasDoc = [];
          this.$deltasFold = [];
          this.setUndoManager(this.$undoManager);
          this.getUndoManager().reset();
        };
        this.getValue = this.toString = function() {
          return this.doc.getValue();
        };
        this.getSelection = function() {
          return this.selection;
        };
        this.getState = function(row) {
          return this.bgTokenizer.getState(row);
        };
        this.getTokens = function(row) {
          return this.bgTokenizer.getTokens(row);
        };
        this.getTokenAt = function(row, column) {
          var tokens = this.bgTokenizer.getTokens(row);
          var token,
              c = 0;
          if (column == null) {
            i = tokens.length - 1;
            c = this.getLine(row).length;
          } else {
            for (var i = 0; i < tokens.length; i++) {
              c += tokens[i].value.length;
              if (c >= column)
                break;
            }
          }
          token = tokens[i];
          if (!token)
            return null;
          token.index = i;
          token.start = c - token.value.length;
          return token;
        };
        this.setUndoManager = function(undoManager) {
          this.$undoManager = undoManager;
          this.$deltas = [];
          this.$deltasDoc = [];
          this.$deltasFold = [];
          if (this.$informUndoManager)
            this.$informUndoManager.cancel();
          if (undoManager) {
            var self = this;
            this.$syncInformUndoManager = function() {
              self.$informUndoManager.cancel();
              if (self.$deltasFold.length) {
                self.$deltas.push({
                  group: "fold",
                  deltas: self.$deltasFold
                });
                self.$deltasFold = [];
              }
              if (self.$deltasDoc.length) {
                self.$deltas.push({
                  group: "doc",
                  deltas: self.$deltasDoc
                });
                self.$deltasDoc = [];
              }
              if (self.$deltas.length > 0) {
                undoManager.execute({
                  action: "aceupdate",
                  args: [self.$deltas, self],
                  merge: self.mergeUndoDeltas
                });
              }
              self.mergeUndoDeltas = false;
              self.$deltas = [];
            };
            this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
          }
        };
        this.markUndoGroup = function() {
          if (this.$syncInformUndoManager)
            this.$syncInformUndoManager();
        };
        this.$defaultUndoManager = {
          undo: function() {},
          redo: function() {},
          reset: function() {}
        };
        this.getUndoManager = function() {
          return this.$undoManager || this.$defaultUndoManager;
        };
        this.getTabString = function() {
          if (this.getUseSoftTabs()) {
            return lang.stringRepeat(" ", this.getTabSize());
          } else {
            return "\t";
          }
        };
        this.setUseSoftTabs = function(val) {
          this.setOption("useSoftTabs", val);
        };
        this.getUseSoftTabs = function() {
          return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        };
        this.setTabSize = function(tabSize) {
          this.setOption("tabSize", tabSize);
        };
        this.getTabSize = function() {
          return this.$tabSize;
        };
        this.isTabStop = function(position) {
          return this.$useSoftTabs && (position.column % this.$tabSize === 0);
        };
        this.$overwrite = false;
        this.setOverwrite = function(overwrite) {
          this.setOption("overwrite", overwrite);
        };
        this.getOverwrite = function() {
          return this.$overwrite;
        };
        this.toggleOverwrite = function() {
          this.setOverwrite(!this.$overwrite);
        };
        this.addGutterDecoration = function(row, className) {
          if (!this.$decorations[row])
            this.$decorations[row] = "";
          this.$decorations[row] += " " + className;
          this._signal("changeBreakpoint", {});
        };
        this.removeGutterDecoration = function(row, className) {
          this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
          this._signal("changeBreakpoint", {});
        };
        this.getBreakpoints = function() {
          return this.$breakpoints;
        };
        this.setBreakpoints = function(rows) {
          this.$breakpoints = [];
          for (var i = 0; i < rows.length; i++) {
            this.$breakpoints[rows[i]] = "ace_breakpoint";
          }
          this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoints = function() {
          this.$breakpoints = [];
          this._signal("changeBreakpoint", {});
        };
        this.setBreakpoint = function(row, className) {
          if (className === undefined)
            className = "ace_breakpoint";
          if (className)
            this.$breakpoints[row] = className;
          else
            delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        this.clearBreakpoint = function(row) {
          delete this.$breakpoints[row];
          this._signal("changeBreakpoint", {});
        };
        this.addMarker = function(range, clazz, type, inFront) {
          var id = this.$markerId++;
          var marker = {
            range: range,
            type: type || "line",
            renderer: typeof type == "function" ? type : null,
            clazz: clazz,
            inFront: !!inFront,
            id: id
          };
          if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
          }
          return id;
        };
        this.addDynamicMarker = function(marker, inFront) {
          if (!marker.update)
            return;
          var id = this.$markerId++;
          marker.id = id;
          marker.inFront = !!inFront;
          if (inFront) {
            this.$frontMarkers[id] = marker;
            this._signal("changeFrontMarker");
          } else {
            this.$backMarkers[id] = marker;
            this._signal("changeBackMarker");
          }
          return marker;
        };
        this.removeMarker = function(markerId) {
          var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
          if (!marker)
            return;
          var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
          if (marker) {
            delete(markers[markerId]);
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          }
        };
        this.getMarkers = function(inFront) {
          return inFront ? this.$frontMarkers : this.$backMarkers;
        };
        this.highlight = function(re) {
          if (!this.$searchHighlight) {
            var highlight = new SearchHighlight(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(highlight);
          }
          this.$searchHighlight.setRegexp(re);
        };
        this.highlightLines = function(startRow, endRow, clazz, inFront) {
          if (typeof endRow != "number") {
            clazz = endRow;
            endRow = startRow;
          }
          if (!clazz)
            clazz = "ace_step";
          var range = new Range(startRow, 0, endRow, Infinity);
          range.id = this.addMarker(range, clazz, "fullLine", inFront);
          return range;
        };
        this.setAnnotations = function(annotations) {
          this.$annotations = annotations;
          this._signal("changeAnnotation", {});
        };
        this.getAnnotations = function() {
          return this.$annotations || [];
        };
        this.clearAnnotations = function() {
          this.setAnnotations([]);
        };
        this.$detectNewLine = function(text) {
          var match = text.match(/^.*?(\r?\n)/m);
          if (match) {
            this.$autoNewLine = match[1];
          } else {
            this.$autoNewLine = "\n";
          }
        };
        this.getWordRange = function(row, column) {
          var line = this.getLine(row);
          var inToken = false;
          if (column > 0)
            inToken = !!line.charAt(column - 1).match(this.tokenRe);
          if (!inToken)
            inToken = !!line.charAt(column).match(this.tokenRe);
          if (inToken)
            var re = this.tokenRe;
          else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
            var re = /\s/;
          else
            var re = this.nonTokenRe;
          var start = column;
          if (start > 0) {
            do {
              start--;
            } while (start >= 0 && line.charAt(start).match(re));
            start++;
          }
          var end = column;
          while (end < line.length && line.charAt(end).match(re)) {
            end++;
          }
          return new Range(row, start, row, end);
        };
        this.getAWordRange = function(row, column) {
          var wordRange = this.getWordRange(row, column);
          var line = this.getLine(wordRange.end.row);
          while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
            wordRange.end.column += 1;
          }
          return wordRange;
        };
        this.setNewLineMode = function(newLineMode) {
          this.doc.setNewLineMode(newLineMode);
        };
        this.getNewLineMode = function() {
          return this.doc.getNewLineMode();
        };
        this.setUseWorker = function(useWorker) {
          this.setOption("useWorker", useWorker);
        };
        this.getUseWorker = function() {
          return this.$useWorker;
        };
        this.onReloadTokenizer = function(e) {
          var rows = e.data;
          this.bgTokenizer.start(rows.first);
          this._signal("tokenizerUpdate", e);
        };
        this.$modes = {};
        this.$mode = null;
        this.$modeId = null;
        this.setMode = function(mode, cb) {
          if (mode && typeof mode === "object") {
            if (mode.getTokenizer)
              return this.$onChangeMode(mode);
            var options = mode;
            var path = options.path;
          } else {
            path = mode || "ace/mode/text";
          }
          if (!this.$modes["ace/mode/text"])
            this.$modes["ace/mode/text"] = new TextMode();
          if (this.$modes[path] && !options) {
            this.$onChangeMode(this.$modes[path]);
            cb && cb();
            return;
          }
          this.$modeId = path;
          config.loadModule(["mode", path], function(m) {
            if (this.$modeId !== path)
              return cb && cb();
            if (this.$modes[path] && !options) {
              this.$onChangeMode(this.$modes[path]);
            } else if (m && m.Mode) {
              m = new m.Mode(options);
              if (!options) {
                this.$modes[path] = m;
                m.$id = path;
              }
              this.$onChangeMode(m);
            }
            cb && cb();
          }.bind(this));
          if (!this.$mode)
            this.$onChangeMode(this.$modes["ace/mode/text"], true);
        };
        this.$onChangeMode = function(mode, $isPlaceholder) {
          if (!$isPlaceholder)
            this.$modeId = mode.$id;
          if (this.$mode === mode)
            return;
          this.$mode = mode;
          this.$stopWorker();
          if (this.$useWorker)
            this.$startWorker();
          var tokenizer = mode.getTokenizer();
          if (tokenizer.addEventListener !== undefined) {
            var onReloadTokenizer = this.onReloadTokenizer.bind(this);
            tokenizer.addEventListener("update", onReloadTokenizer);
          }
          if (!this.bgTokenizer) {
            this.bgTokenizer = new BackgroundTokenizer(tokenizer);
            var _self = this;
            this.bgTokenizer.addEventListener("update", function(e) {
              _self._signal("tokenizerUpdate", e);
            });
          } else {
            this.bgTokenizer.setTokenizer(tokenizer);
          }
          this.bgTokenizer.setDocument(this.getDocument());
          this.tokenRe = mode.tokenRe;
          this.nonTokenRe = mode.nonTokenRe;
          if (!$isPlaceholder) {
            if (mode.attachToSession)
              mode.attachToSession(this);
            this.$options.wrapMethod.set.call(this, this.$wrapMethod);
            this.$setFolding(mode.foldingRules);
            this.bgTokenizer.start(0);
            this._emit("changeMode");
          }
        };
        this.$stopWorker = function() {
          if (this.$worker) {
            this.$worker.terminate();
            this.$worker = null;
          }
        };
        this.$startWorker = function() {
          try {
            this.$worker = this.$mode.createWorker(this);
          } catch (e) {
            config.warn("Could not load worker", e);
            this.$worker = null;
          }
        };
        this.getMode = function() {
          return this.$mode;
        };
        this.$scrollTop = 0;
        this.setScrollTop = function(scrollTop) {
          if (this.$scrollTop === scrollTop || isNaN(scrollTop))
            return;
          this.$scrollTop = scrollTop;
          this._signal("changeScrollTop", scrollTop);
        };
        this.getScrollTop = function() {
          return this.$scrollTop;
        };
        this.$scrollLeft = 0;
        this.setScrollLeft = function(scrollLeft) {
          if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
            return;
          this.$scrollLeft = scrollLeft;
          this._signal("changeScrollLeft", scrollLeft);
        };
        this.getScrollLeft = function() {
          return this.$scrollLeft;
        };
        this.getScreenWidth = function() {
          this.$computeWidth();
          if (this.lineWidgets)
            return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
          return this.screenWidth;
        };
        this.getLineWidgetMaxWidth = function() {
          if (this.lineWidgetsWidth != null)
            return this.lineWidgetsWidth;
          var width = 0;
          this.lineWidgets.forEach(function(w) {
            if (w && w.screenWidth > width)
              width = w.screenWidth;
          });
          return this.lineWidgetWidth = width;
        };
        this.$computeWidth = function(force) {
          if (this.$modified || force) {
            this.$modified = false;
            if (this.$useWrapMode)
              return this.screenWidth = this.$wrapLimit;
            var lines = this.doc.getAllLines();
            var cache = this.$rowLengthCache;
            var longestScreenLine = 0;
            var foldIndex = 0;
            var foldLine = this.$foldData[foldIndex];
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            var len = lines.length;
            for (var i = 0; i < len; i++) {
              if (i > foldStart) {
                i = foldLine.end.row + 1;
                if (i >= len)
                  break;
                foldLine = this.$foldData[foldIndex++];
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (cache[i] == null)
                cache[i] = this.$getStringScreenWidth(lines[i])[0];
              if (cache[i] > longestScreenLine)
                longestScreenLine = cache[i];
            }
            this.screenWidth = longestScreenLine;
          }
        };
        this.getLine = function(row) {
          return this.doc.getLine(row);
        };
        this.getLines = function(firstRow, lastRow) {
          return this.doc.getLines(firstRow, lastRow);
        };
        this.getLength = function() {
          return this.doc.getLength();
        };
        this.getTextRange = function(range) {
          return this.doc.getTextRange(range || this.selection.getRange());
        };
        this.insert = function(position, text) {
          return this.doc.insert(position, text);
        };
        this.remove = function(range) {
          return this.doc.remove(range);
        };
        this.removeFullLines = function(firstRow, lastRow) {
          return this.doc.removeFullLines(firstRow, lastRow);
        };
        this.undoChanges = function(deltas, dontSelect) {
          if (!deltas.length)
            return;
          this.$fromUndo = true;
          var lastUndoRange = null;
          for (var i = deltas.length - 1; i != -1; i--) {
            var delta = deltas[i];
            if (delta.group == "doc") {
              this.doc.revertDeltas(delta.deltas);
              lastUndoRange = this.$getUndoSelection(delta.deltas, true, lastUndoRange);
            } else {
              delta.deltas.forEach(function(foldDelta) {
                this.addFolds(foldDelta.folds);
              }, this);
            }
          }
          this.$fromUndo = false;
          lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
          return lastUndoRange;
        };
        this.redoChanges = function(deltas, dontSelect) {
          if (!deltas.length)
            return;
          this.$fromUndo = true;
          var lastUndoRange = null;
          for (var i = 0; i < deltas.length; i++) {
            var delta = deltas[i];
            if (delta.group == "doc") {
              this.doc.applyDeltas(delta.deltas);
              lastUndoRange = this.$getUndoSelection(delta.deltas, false, lastUndoRange);
            }
          }
          this.$fromUndo = false;
          lastUndoRange && this.$undoSelect && !dontSelect && this.selection.setSelectionRange(lastUndoRange);
          return lastUndoRange;
        };
        this.setUndoSelect = function(enable) {
          this.$undoSelect = enable;
        };
        this.$getUndoSelection = function(deltas, isUndo, lastUndoRange) {
          function isInsert(delta) {
            return isUndo ? delta.action !== "insert" : delta.action === "insert";
          }
          var delta = deltas[0];
          var range,
              point;
          var lastDeltaIsInsert = false;
          if (isInsert(delta)) {
            range = Range.fromPoints(delta.start, delta.end);
            lastDeltaIsInsert = true;
          } else {
            range = Range.fromPoints(delta.start, delta.start);
            lastDeltaIsInsert = false;
          }
          for (var i = 1; i < deltas.length; i++) {
            delta = deltas[i];
            if (isInsert(delta)) {
              point = delta.start;
              if (range.compare(point.row, point.column) == -1) {
                range.setStart(point);
              }
              point = delta.end;
              if (range.compare(point.row, point.column) == 1) {
                range.setEnd(point);
              }
              lastDeltaIsInsert = true;
            } else {
              point = delta.start;
              if (range.compare(point.row, point.column) == -1) {
                range = Range.fromPoints(delta.start, delta.start);
              }
              lastDeltaIsInsert = false;
            }
          }
          if (lastUndoRange != null) {
            if (Range.comparePoints(lastUndoRange.start, range.start) === 0) {
              lastUndoRange.start.column += range.end.column - range.start.column;
              lastUndoRange.end.column += range.end.column - range.start.column;
            }
            var cmp = lastUndoRange.compareRange(range);
            if (cmp == 1) {
              range.setStart(lastUndoRange.start);
            } else if (cmp == -1) {
              range.setEnd(lastUndoRange.end);
            }
          }
          return range;
        };
        this.replace = function(range, text) {
          return this.doc.replace(range, text);
        };
        this.moveText = function(fromRange, toPosition, copy) {
          var text = this.getTextRange(fromRange);
          var folds = this.getFoldsInRange(fromRange);
          var toRange = Range.fromPoints(toPosition, toPosition);
          if (!copy) {
            this.remove(fromRange);
            var rowDiff = fromRange.start.row - fromRange.end.row;
            var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
            if (collDiff) {
              if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                toRange.start.column += collDiff;
              if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                toRange.end.column += collDiff;
            }
            if (rowDiff && toRange.start.row >= fromRange.end.row) {
              toRange.start.row += rowDiff;
              toRange.end.row += rowDiff;
            }
          }
          toRange.end = this.insert(toRange.start, text);
          if (folds.length) {
            var oldStart = fromRange.start;
            var newStart = toRange.start;
            var rowDiff = newStart.row - oldStart.row;
            var collDiff = newStart.column - oldStart.column;
            this.addFolds(folds.map(function(x) {
              x = x.clone();
              if (x.start.row == oldStart.row)
                x.start.column += collDiff;
              if (x.end.row == oldStart.row)
                x.end.column += collDiff;
              x.start.row += rowDiff;
              x.end.row += rowDiff;
              return x;
            }));
          }
          return toRange;
        };
        this.indentRows = function(startRow, endRow, indentString) {
          indentString = indentString.replace(/\t/g, this.getTabString());
          for (var row = startRow; row <= endRow; row++)
            this.doc.insertInLine({
              row: row,
              column: 0
            }, indentString);
        };
        this.outdentRows = function(range) {
          var rowRange = range.collapseRows();
          var deleteRange = new Range(0, 0, 0, 0);
          var size = this.getTabSize();
          for (var i = rowRange.start.row; i <= rowRange.end.row; ++i) {
            var line = this.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            for (var j = 0; j < size; ++j)
              if (line.charAt(j) != ' ')
                break;
            if (j < size && line.charAt(j) == '\t') {
              deleteRange.start.column = j;
              deleteRange.end.column = j + 1;
            } else {
              deleteRange.start.column = 0;
              deleteRange.end.column = j;
            }
            this.remove(deleteRange);
          }
        };
        this.$moveLines = function(firstRow, lastRow, dir) {
          firstRow = this.getRowFoldStart(firstRow);
          lastRow = this.getRowFoldEnd(lastRow);
          if (dir < 0) {
            var row = this.getRowFoldStart(firstRow + dir);
            if (row < 0)
              return 0;
            var diff = row - firstRow;
          } else if (dir > 0) {
            var row = this.getRowFoldEnd(lastRow + dir);
            if (row > this.doc.getLength() - 1)
              return 0;
            var diff = row - lastRow;
          } else {
            firstRow = this.$clipRowToDocument(firstRow);
            lastRow = this.$clipRowToDocument(lastRow);
            var diff = lastRow - firstRow + 1;
          }
          var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
          var folds = this.getFoldsInRange(range).map(function(x) {
            x = x.clone();
            x.start.row += diff;
            x.end.row += diff;
            return x;
          });
          var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
          this.doc.insertFullLines(firstRow + diff, lines);
          folds.length && this.addFolds(folds);
          return diff;
        };
        this.moveLinesUp = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, -1);
        };
        this.moveLinesDown = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 1);
        };
        this.duplicateLines = function(firstRow, lastRow) {
          return this.$moveLines(firstRow, lastRow, 0);
        };
        this.$clipRowToDocument = function(row) {
          return Math.max(0, Math.min(row, this.doc.getLength() - 1));
        };
        this.$clipColumnToRow = function(row, column) {
          if (column < 0)
            return 0;
          return Math.min(this.doc.getLine(row).length, column);
        };
        this.$clipPositionToDocument = function(row, column) {
          column = Math.max(0, column);
          if (row < 0) {
            row = 0;
            column = 0;
          } else {
            var len = this.doc.getLength();
            if (row >= len) {
              row = len - 1;
              column = this.doc.getLine(len - 1).length;
            } else {
              column = Math.min(this.doc.getLine(row).length, column);
            }
          }
          return {
            row: row,
            column: column
          };
        };
        this.$clipRangeToDocument = function(range) {
          if (range.start.row < 0) {
            range.start.row = 0;
            range.start.column = 0;
          } else {
            range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
          }
          var len = this.doc.getLength() - 1;
          if (range.end.row > len) {
            range.end.row = len;
            range.end.column = this.doc.getLine(len).length;
          } else {
            range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
          }
          return range;
        };
        this.$wrapLimit = 80;
        this.$useWrapMode = false;
        this.$wrapLimitRange = {
          min: null,
          max: null
        };
        this.setUseWrapMode = function(useWrapMode) {
          if (useWrapMode != this.$useWrapMode) {
            this.$useWrapMode = useWrapMode;
            this.$modified = true;
            this.$resetRowCache(0);
            if (useWrapMode) {
              var len = this.getLength();
              this.$wrapData = Array(len);
              this.$updateWrapData(0, len - 1);
            }
            this._signal("changeWrapMode");
          }
        };
        this.getUseWrapMode = function() {
          return this.$useWrapMode;
        };
        this.setWrapLimitRange = function(min, max) {
          if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
            this.$wrapLimitRange = {
              min: min,
              max: max
            };
            this.$modified = true;
            if (this.$useWrapMode)
              this._signal("changeWrapMode");
          }
        };
        this.adjustWrapLimit = function(desiredLimit, $printMargin) {
          var limits = this.$wrapLimitRange;
          if (limits.max < 0)
            limits = {
              min: $printMargin,
              max: $printMargin
            };
          var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
          if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
            this.$wrapLimit = wrapLimit;
            this.$modified = true;
            if (this.$useWrapMode) {
              this.$updateWrapData(0, this.getLength() - 1);
              this.$resetRowCache(0);
              this._signal("changeWrapLimit");
            }
            return true;
          }
          return false;
        };
        this.$constrainWrapLimit = function(wrapLimit, min, max) {
          if (min)
            wrapLimit = Math.max(min, wrapLimit);
          if (max)
            wrapLimit = Math.min(max, wrapLimit);
          return wrapLimit;
        };
        this.getWrapLimit = function() {
          return this.$wrapLimit;
        };
        this.setWrapLimit = function(limit) {
          this.setWrapLimitRange(limit, limit);
        };
        this.getWrapLimitRange = function() {
          return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
          };
        };
        this.$updateInternalDataOnChange = function(delta) {
          var useWrapMode = this.$useWrapMode;
          var action = delta.action;
          var start = delta.start;
          var end = delta.end;
          var firstRow = start.row;
          var lastRow = end.row;
          var len = lastRow - firstRow;
          var removedFolds = null;
          this.$updating = true;
          if (len != 0) {
            if (action === "remove") {
              this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
              var foldLines = this.$foldData;
              removedFolds = this.getFoldsInRange(delta);
              this.removeFolds(removedFolds);
              var foldLine = this.getFoldLine(end.row);
              var idx = 0;
              if (foldLine) {
                foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                foldLine.shiftRow(-len);
                var foldLineBefore = this.getFoldLine(firstRow);
                if (foldLineBefore && foldLineBefore !== foldLine) {
                  foldLineBefore.merge(foldLine);
                  foldLine = foldLineBefore;
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= end.row) {
                  foldLine.shiftRow(-len);
                }
              }
              lastRow = firstRow;
            } else {
              var args = Array(len);
              args.unshift(firstRow, 0);
              var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
              arr.splice.apply(arr, args);
              var foldLines = this.$foldData;
              var foldLine = this.getFoldLine(firstRow);
              var idx = 0;
              if (foldLine) {
                var cmp = foldLine.range.compareInside(start.row, start.column);
                if (cmp == 0) {
                  foldLine = foldLine.split(start.row, start.column);
                  if (foldLine) {
                    foldLine.shiftRow(len);
                    foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                  }
                } else if (cmp == -1) {
                  foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                  foldLine.shiftRow(len);
                }
                idx = foldLines.indexOf(foldLine) + 1;
              }
              for (idx; idx < foldLines.length; idx++) {
                var foldLine = foldLines[idx];
                if (foldLine.start.row >= firstRow) {
                  foldLine.shiftRow(len);
                }
              }
            }
          } else {
            len = Math.abs(delta.start.column - delta.end.column);
            if (action === "remove") {
              removedFolds = this.getFoldsInRange(delta);
              this.removeFolds(removedFolds);
              len = -len;
            }
            var foldLine = this.getFoldLine(firstRow);
            if (foldLine) {
              foldLine.addRemoveChars(firstRow, start.column, len);
            }
          }
          if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
            console.error("doc.getLength() and $wrapData.length have to be the same!");
          }
          this.$updating = false;
          if (useWrapMode)
            this.$updateWrapData(firstRow, lastRow);
          else
            this.$updateRowLengthCache(firstRow, lastRow);
          return removedFolds;
        };
        this.$updateRowLengthCache = function(firstRow, lastRow, b) {
          this.$rowLengthCache[firstRow] = null;
          this.$rowLengthCache[lastRow] = null;
        };
        this.$updateWrapData = function(firstRow, lastRow) {
          var lines = this.doc.getAllLines();
          var tabSize = this.getTabSize();
          var wrapData = this.$wrapData;
          var wrapLimit = this.$wrapLimit;
          var tokens;
          var foldLine;
          var row = firstRow;
          lastRow = Math.min(lastRow, lines.length - 1);
          while (row <= lastRow) {
            foldLine = this.getFoldLine(row, foldLine);
            if (!foldLine) {
              tokens = this.$getDisplayTokens(lines[row]);
              wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row++;
            } else {
              tokens = [];
              foldLine.walk(function(placeholder, row, column, lastColumn) {
                var walkTokens;
                if (placeholder != null) {
                  walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                  walkTokens[0] = PLACEHOLDER_START;
                  for (var i = 1; i < walkTokens.length; i++) {
                    walkTokens[i] = PLACEHOLDER_BODY;
                  }
                } else {
                  walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                }
                tokens = tokens.concat(walkTokens);
              }.bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
              wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
              row = foldLine.end.row + 1;
            }
          }
        };
        var CHAR = 1,
            CHAR_EXT = 2,
            PLACEHOLDER_START = 3,
            PLACEHOLDER_BODY = 4,
            PUNCTUATION = 9,
            SPACE = 10,
            TAB = 11,
            TAB_SPACE = 12;
        this.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
          if (tokens.length == 0) {
            return [];
          }
          var splits = [];
          var displayLength = tokens.length;
          var lastSplit = 0,
              lastDocSplit = 0;
          var isCode = this.$wrapAsCode;
          var indentedSoftWrap = this.$indentedSoftWrap;
          var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
          function getWrapIndent() {
            var indentation = 0;
            if (maxIndent === 0)
              return indentation;
            if (indentedSoftWrap) {
              for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];
                if (token == SPACE)
                  indentation += 1;
                else if (token == TAB)
                  indentation += tabSize;
                else if (token == TAB_SPACE)
                  continue;
                else
                  break;
              }
            }
            if (isCode && indentedSoftWrap !== false)
              indentation += tabSize;
            return Math.min(indentation, maxIndent);
          }
          function addSplit(screenPos) {
            var displayed = tokens.slice(lastSplit, screenPos);
            var len = displayed.length;
            displayed.join("").replace(/12/g, function() {
              len -= 1;
            }).replace(/2/g, function() {
              len -= 1;
            });
            if (!splits.length) {
              indent = getWrapIndent();
              splits.indent = indent;
            }
            lastDocSplit += len;
            splits.push(lastDocSplit);
            lastSplit = screenPos;
          }
          var indent = 0;
          while (displayLength - lastSplit > wrapLimit - indent) {
            var split = lastSplit + wrapLimit - indent;
            if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
              addSplit(split);
              continue;
            }
            if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
              for (split; split != lastSplit - 1; split--) {
                if (tokens[split] == PLACEHOLDER_START) {
                  break;
                }
              }
              if (split > lastSplit) {
                addSplit(split);
                continue;
              }
              split = lastSplit + wrapLimit;
              for (split; split < tokens.length; split++) {
                if (tokens[split] != PLACEHOLDER_BODY) {
                  break;
                }
              }
              if (split == tokens.length) {
                break;
              }
              addSplit(split);
              continue;
            }
            var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
            while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
              split--;
            }
            if (isCode) {
              while (split > minSplit && tokens[split] < PLACEHOLDER_START) {
                split--;
              }
              while (split > minSplit && tokens[split] == PUNCTUATION) {
                split--;
              }
            } else {
              while (split > minSplit && tokens[split] < SPACE) {
                split--;
              }
            }
            if (split > minSplit) {
              addSplit(++split);
              continue;
            }
            split = lastSplit + wrapLimit;
            if (tokens[split] == CHAR_EXT)
              split--;
            addSplit(split - indent);
          }
          return splits;
        };
        this.$getDisplayTokens = function(str, offset) {
          var arr = [];
          var tabSize;
          offset = offset || 0;
          for (var i = 0; i < str.length; i++) {
            var c = str.charCodeAt(i);
            if (c == 9) {
              tabSize = this.getScreenTabSize(arr.length + offset);
              arr.push(TAB);
              for (var n = 1; n < tabSize; n++) {
                arr.push(TAB_SPACE);
              }
            } else if (c == 32) {
              arr.push(SPACE);
            } else if ((c > 39 && c < 48) || (c > 57 && c < 64)) {
              arr.push(PUNCTUATION);
            } else if (c >= 0x1100 && isFullWidth(c)) {
              arr.push(CHAR, CHAR_EXT);
            } else {
              arr.push(CHAR);
            }
          }
          return arr;
        };
        this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
          if (maxScreenColumn == 0)
            return [0, 0];
          if (maxScreenColumn == null)
            maxScreenColumn = Infinity;
          screenColumn = screenColumn || 0;
          var c,
              column;
          for (column = 0; column < str.length; column++) {
            c = str.charCodeAt(column);
            if (c == 9) {
              screenColumn += this.getScreenTabSize(screenColumn);
            } else if (c >= 0x1100 && isFullWidth(c)) {
              screenColumn += 2;
            } else {
              screenColumn += 1;
            }
            if (screenColumn > maxScreenColumn) {
              break;
            }
          }
          return [screenColumn, column];
        };
        this.lineWidgets = null;
        this.getRowLength = function(row) {
          if (this.lineWidgets)
            var h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
          else
            h = 0;
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
          } else {
            return this.$wrapData[row].length + 1 + h;
          }
        };
        this.getRowLineCount = function(row) {
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1;
          } else {
            return this.$wrapData[row].length + 1;
          }
        };
        this.getRowWrapIndent = function(screenRow) {
          if (this.$useWrapMode) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            var splits = this.$wrapData[pos.row];
            return splits.length && splits[0] < pos.column ? splits.indent : 0;
          } else {
            return 0;
          }
        };
        this.getScreenLastRowColumn = function(screenRow) {
          var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
          return this.documentToScreenColumn(pos.row, pos.column);
        };
        this.getDocumentLastRowColumn = function(docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.getScreenLastRowColumn(screenRow);
        };
        this.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
          var screenRow = this.documentToScreenRow(docRow, docColumn);
          return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
        };
        this.getRowSplitData = function(row) {
          if (!this.$useWrapMode) {
            return undefined;
          } else {
            return this.$wrapData[row];
          }
        };
        this.getScreenTabSize = function(screenColumn) {
          return this.$tabSize - screenColumn % this.$tabSize;
        };
        this.screenToDocumentRow = function(screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).row;
        };
        this.screenToDocumentColumn = function(screenRow, screenColumn) {
          return this.screenToDocumentPosition(screenRow, screenColumn).column;
        };
        this.screenToDocumentPosition = function(screenRow, screenColumn) {
          if (screenRow < 0)
            return {
              row: 0,
              column: 0
            };
          var line;
          var docRow = 0;
          var docColumn = 0;
          var column;
          var row = 0;
          var rowLength = 0;
          var rowCache = this.$screenRowCache;
          var i = this.$getRowCacheIndex(rowCache, screenRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var docRow = this.$docRowCache[i];
            var doCache = screenRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var maxRow = this.getLength() - 1;
          var foldLine = this.getNextFoldLine(docRow);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row <= screenRow) {
            rowLength = this.getRowLength(docRow);
            if (row + rowLength > screenRow || docRow >= maxRow) {
              break;
            } else {
              row += rowLength;
              docRow++;
              if (docRow > foldStart) {
                docRow = foldLine.end.row + 1;
                foldLine = this.getNextFoldLine(docRow, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
            }
            if (doCache) {
              this.$docRowCache.push(docRow);
              this.$screenRowCache.push(row);
            }
          }
          if (foldLine && foldLine.start.row <= docRow) {
            line = this.getFoldDisplayLine(foldLine);
            docRow = foldLine.start.row;
          } else if (row + rowLength <= screenRow || docRow > maxRow) {
            return {
              row: maxRow,
              column: this.getLine(maxRow).length
            };
          } else {
            line = this.getLine(docRow);
            foldLine = null;
          }
          var wrapIndent = 0;
          if (this.$useWrapMode) {
            var splits = this.$wrapData[docRow];
            if (splits) {
              var splitIndex = Math.floor(screenRow - row);
              column = splits[splitIndex];
              if (splitIndex > 0 && splits.length) {
                wrapIndent = splits.indent;
                docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                line = line.substring(docColumn);
              }
            }
          }
          docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
          if (this.$useWrapMode && docColumn >= column)
            docColumn = column - 1;
          if (foldLine)
            return foldLine.idxToPosition(docColumn);
          return {
            row: docRow,
            column: docColumn
          };
        };
        this.documentToScreenPosition = function(docRow, docColumn) {
          if (typeof docColumn === "undefined")
            var pos = this.$clipPositionToDocument(docRow.row, docRow.column);
          else
            pos = this.$clipPositionToDocument(docRow, docColumn);
          docRow = pos.row;
          docColumn = pos.column;
          var screenRow = 0;
          var foldStartRow = null;
          var fold = null;
          fold = this.getFoldAt(docRow, docColumn, 1);
          if (fold) {
            docRow = fold.start.row;
            docColumn = fold.start.column;
          }
          var rowEnd,
              row = 0;
          var rowCache = this.$docRowCache;
          var i = this.$getRowCacheIndex(rowCache, docRow);
          var l = rowCache.length;
          if (l && i >= 0) {
            var row = rowCache[i];
            var screenRow = this.$screenRowCache[i];
            var doCache = docRow > rowCache[l - 1];
          } else {
            var doCache = !l;
          }
          var foldLine = this.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (row < docRow) {
            if (row >= foldStart) {
              rowEnd = foldLine.end.row + 1;
              if (rowEnd > docRow)
                break;
              foldLine = this.getNextFoldLine(rowEnd, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            } else {
              rowEnd = row + 1;
            }
            screenRow += this.getRowLength(row);
            row = rowEnd;
            if (doCache) {
              this.$docRowCache.push(row);
              this.$screenRowCache.push(screenRow);
            }
          }
          var textLine = "";
          if (foldLine && row >= foldStart) {
            textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
            foldStartRow = foldLine.start.row;
          } else {
            textLine = this.getLine(docRow).substring(0, docColumn);
            foldStartRow = docRow;
          }
          var wrapIndent = 0;
          if (this.$useWrapMode) {
            var wrapRow = this.$wrapData[foldStartRow];
            if (wrapRow) {
              var screenRowOffset = 0;
              while (textLine.length >= wrapRow[screenRowOffset]) {
                screenRow++;
                screenRowOffset++;
              }
              textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
              wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
            }
          }
          return {
            row: screenRow,
            column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
          };
        };
        this.documentToScreenColumn = function(row, docColumn) {
          return this.documentToScreenPosition(row, docColumn).column;
        };
        this.documentToScreenRow = function(docRow, docColumn) {
          return this.documentToScreenPosition(docRow, docColumn).row;
        };
        this.getScreenLength = function() {
          var screenRows = 0;
          var fold = null;
          if (!this.$useWrapMode) {
            screenRows = this.getLength();
            var foldData = this.$foldData;
            for (var i = 0; i < foldData.length; i++) {
              fold = foldData[i];
              screenRows -= fold.end.row - fold.start.row;
            }
          } else {
            var lastRow = this.$wrapData.length;
            var row = 0,
                i = 0;
            var fold = this.$foldData[i++];
            var foldStart = fold ? fold.start.row : Infinity;
            while (row < lastRow) {
              var splits = this.$wrapData[row];
              screenRows += splits ? splits.length + 1 : 1;
              row++;
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = this.$foldData[i++];
                foldStart = fold ? fold.start.row : Infinity;
              }
            }
          }
          if (this.lineWidgets)
            screenRows += this.$getWidgetScreenLength();
          return screenRows;
        };
        this.$setFontMetrics = function(fm) {
          if (!this.$enableVarChar)
            return;
          this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn === 0)
              return [0, 0];
            if (!maxScreenColumn)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c,
                column;
            for (column = 0; column < str.length; column++) {
              c = str.charAt(column);
              if (c === "\t") {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else {
                screenColumn += fm.getCharacterWidth(c);
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
        };
        this.destroy = function() {
          if (this.bgTokenizer) {
            this.bgTokenizer.setDocument(null);
            this.bgTokenizer = null;
          }
          this.$stopWorker();
        };
        function isFullWidth(c) {
          if (c < 0x1100)
            return false;
          return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
        }
      }).call(EditSession.prototype);
      require("./edit_session/folding").Folding.call(EditSession.prototype);
      require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function(value) {
            if (!value || value == "off")
              value = false;
            else if (value == "free")
              value = true;
            else if (value == "printMargin")
              value = -1;
            else if (typeof value == "string")
              value = parseInt(value, 10) || false;
            if (this.$wrap == value)
              return;
            this.$wrap = value;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
          },
          get: function() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1)
                return "printMargin";
              if (!this.getWrapLimitRange().min)
                return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$modified = true;
                this.$resetRowCache(0);
                this.$updateWrapData(0, this.getLength() - 1);
              }
            }
          },
          initialValue: "auto"
        },
        indentedSoftWrap: {initialValue: true},
        firstLineNumber: {
          set: function() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
              this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: {initialValue: true},
        tabSize: {
          set: function(tabSize) {
            if (isNaN(tabSize) || this.$tabSize === tabSize)
              return;
            this.$modified = true;
            this.$rowLengthCache = [];
            this.$tabSize = tabSize;
            this._signal("changeTabSize");
          },
          initialValue: 4,
          handlesSet: true
        },
        overwrite: {
          set: function(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function(val) {
            this.doc.setNewLineMode(val);
          },
          get: function() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function(val) {
            this.setMode(val);
          },
          get: function() {
            return this.$modeId;
          }
        }
      });
      exports.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require, exports, module) {
      "use strict";
      var lang = require("./lib/lang");
      var oop = require("./lib/oop");
      var Range = require("./range").Range;
      var Search = function() {
        this.$options = {};
      };
      (function() {
        this.set = function(options) {
          oop.mixin(this.$options, options);
          return this;
        };
        this.getOptions = function() {
          return lang.copyObject(this.$options);
        };
        this.setOptions = function(options) {
          this.$options = options;
        };
        this.find = function(session) {
          var options = this.$options;
          var iterator = this.$matchIterator(session, options);
          if (!iterator)
            return false;
          var firstRange = null;
          iterator.forEach(function(range, row, offset) {
            if (!range.start) {
              var column = range.offset + (offset || 0);
              firstRange = new Range(row, column, row, column + range.length);
              if (!range.length && options.start && options.start.start && options.skipCurrent != false && firstRange.isEqual(options.start)) {
                firstRange = null;
                return false;
              }
            } else
              firstRange = range;
            return true;
          });
          return firstRange;
        };
        this.findAll = function(session) {
          var options = this.$options;
          if (!options.needle)
            return [];
          this.$assembleRegExp(options);
          var range = options.range;
          var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
          var ranges = [];
          var re = options.re;
          if (options.$isMultiLine) {
            var len = re.length;
            var maxRow = lines.length - len;
            var prevRange;
            outer: for (var row = re.offset || 0; row <= maxRow; row++) {
              for (var j = 0; j < len; j++)
                if (lines[row + j].search(re[j]) == -1)
                  continue outer;
              var startLine = lines[row];
              var line = lines[row + len - 1];
              var startIndex = startLine.length - startLine.match(re[0])[0].length;
              var endIndex = line.match(re[len - 1])[0].length;
              if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                continue;
              }
              ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
              if (len > 2)
                row = row + len - 2;
            }
          } else {
            for (var i = 0; i < lines.length; i++) {
              var matches = lang.getMatchOffsets(lines[i], re);
              for (var j = 0; j < matches.length; j++) {
                var match = matches[j];
                ranges.push(new Range(i, match.offset, i, match.offset + match.length));
              }
            }
          }
          if (range) {
            var startColumn = range.start.column;
            var endColumn = range.start.column;
            var i = 0,
                j = ranges.length - 1;
            while (i < j && ranges[i].start.column < startColumn && ranges[i].start.row == range.start.row)
              i++;
            while (i < j && ranges[j].end.column > endColumn && ranges[j].end.row == range.end.row)
              j--;
            ranges = ranges.slice(i, j + 1);
            for (i = 0, j = ranges.length; i < j; i++) {
              ranges[i].start.row += range.start.row;
              ranges[i].end.row += range.start.row;
            }
          }
          return ranges;
        };
        this.replace = function(input, replacement) {
          var options = this.$options;
          var re = this.$assembleRegExp(options);
          if (options.$isMultiLine)
            return replacement;
          if (!re)
            return;
          var match = re.exec(input);
          if (!match || match[0].length != input.length)
            return null;
          replacement = input.replace(re, replacement);
          if (options.preserveCase) {
            replacement = replacement.split("");
            for (var i = Math.min(input.length, input.length); i--; ) {
              var ch = input[i];
              if (ch && ch.toLowerCase() != ch)
                replacement[i] = replacement[i].toUpperCase();
              else
                replacement[i] = replacement[i].toLowerCase();
            }
            replacement = replacement.join("");
          }
          return replacement;
        };
        this.$matchIterator = function(session, options) {
          var re = this.$assembleRegExp(options);
          if (!re)
            return false;
          var callback;
          if (options.$isMultiLine) {
            var len = re.length;
            var matchIterator = function(line, row, offset) {
              var startIndex = line.search(re[0]);
              if (startIndex == -1)
                return;
              for (var i = 1; i < len; i++) {
                line = session.getLine(row + i);
                if (line.search(re[i]) == -1)
                  return;
              }
              var endIndex = line.match(re[len - 1])[0].length;
              var range = new Range(row, startIndex, row + len - 1, endIndex);
              if (re.offset == 1) {
                range.start.row--;
                range.start.column = Number.MAX_VALUE;
              } else if (offset)
                range.start.column += offset;
              if (callback(range))
                return true;
            };
          } else if (options.backwards) {
            var matchIterator = function(line, row, startIndex) {
              var matches = lang.getMatchOffsets(line, re);
              for (var i = matches.length - 1; i >= 0; i--)
                if (callback(matches[i], row, startIndex))
                  return true;
            };
          } else {
            var matchIterator = function(line, row, startIndex) {
              var matches = lang.getMatchOffsets(line, re);
              for (var i = 0; i < matches.length; i++)
                if (callback(matches[i], row, startIndex))
                  return true;
            };
          }
          var lineIterator = this.$lineIterator(session, options);
          return {forEach: function(_callback) {
              callback = _callback;
              lineIterator.forEach(matchIterator);
            }};
        };
        this.$assembleRegExp = function(options, $disableFakeMultiline) {
          if (options.needle instanceof RegExp)
            return options.re = options.needle;
          var needle = options.needle;
          if (!options.needle)
            return options.re = false;
          if (!options.regExp)
            needle = lang.escapeRegExp(needle);
          if (options.wholeWord)
            needle = "\\b" + needle + "\\b";
          var modifier = options.caseSensitive ? "gm" : "gmi";
          options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
          if (options.$isMultiLine)
            return options.re = this.$assembleMultilineRegExp(needle, modifier);
          try {
            var re = new RegExp(needle, modifier);
          } catch (e) {
            re = false;
          }
          return options.re = re;
        };
        this.$assembleMultilineRegExp = function(needle, modifier) {
          var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
          var re = [];
          for (var i = 0; i < parts.length; i++)
            try {
              re.push(new RegExp(parts[i], modifier));
            } catch (e) {
              return false;
            }
          if (parts[0] == "") {
            re.shift();
            re.offset = 1;
          } else {
            re.offset = 0;
          }
          return re;
        };
        this.$lineIterator = function(session, options) {
          var backwards = options.backwards == true;
          var skipCurrent = options.skipCurrent != false;
          var range = options.range;
          var start = options.start;
          if (!start)
            start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
          if (start.start)
            start = start[skipCurrent != backwards ? "end" : "start"];
          var firstRow = range ? range.start.row : 0;
          var lastRow = range ? range.end.row : session.getLength() - 1;
          var forEach = backwards ? function(callback) {
            var row = start.row;
            var line = session.getLine(row).substring(0, start.column);
            if (callback(line, row))
              return;
            for (row--; row >= firstRow; row--)
              if (callback(session.getLine(row), row))
                return;
            if (options.wrap == false)
              return;
            for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
              if (callback(session.getLine(row), row))
                return;
          } : function(callback) {
            var row = start.row;
            var line = session.getLine(row).substr(start.column);
            if (callback(line, row, start.column))
              return;
            for (row = row + 1; row <= lastRow; row++)
              if (callback(session.getLine(row), row))
                return;
            if (options.wrap == false)
              return;
            for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
              if (callback(session.getLine(row), row))
                return;
          };
          return {forEach: forEach};
        };
      }).call(Search.prototype);
      exports.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require, exports, module) {
      "use strict";
      var keyUtil = require("../lib/keys");
      var useragent = require("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      function HashHandler(config, platform) {
        this.platform = platform || (useragent.isMac ? "mac" : "win");
        this.commands = {};
        this.commandKeyBinding = {};
        this.addCommands(config);
        this.$singleCommand = true;
      }
      function MultiHashHandler(config, platform) {
        HashHandler.call(this, config, platform);
        this.$singleCommand = false;
      }
      MultiHashHandler.prototype = HashHandler.prototype;
      (function() {
        this.addCommand = function(command) {
          if (this.commands[command.name])
            this.removeCommand(command);
          this.commands[command.name] = command;
          if (command.bindKey)
            this._buildKeyHash(command);
        };
        this.removeCommand = function(command, keepCommand) {
          var name = command && (typeof command === 'string' ? command : command.name);
          command = this.commands[name];
          if (!keepCommand)
            delete this.commands[name];
          var ckb = this.commandKeyBinding;
          for (var keyId in ckb) {
            var cmdGroup = ckb[keyId];
            if (cmdGroup == command) {
              delete ckb[keyId];
            } else if (Array.isArray(cmdGroup)) {
              var i = cmdGroup.indexOf(command);
              if (i != -1) {
                cmdGroup.splice(i, 1);
                if (cmdGroup.length == 1)
                  ckb[keyId] = cmdGroup[0];
              }
            }
          }
        };
        this.bindKey = function(key, command, position) {
          if (typeof key == "object" && key) {
            if (position == undefined)
              position = key.position;
            key = key[this.platform];
          }
          if (!key)
            return;
          if (typeof command == "function")
            return this.addCommand({
              exec: command,
              bindKey: key,
              name: command.name || key
            });
          key.split("|").forEach(function(keyPart) {
            var chain = "";
            if (keyPart.indexOf(" ") != -1) {
              var parts = keyPart.split(/\s+/);
              keyPart = parts.pop();
              parts.forEach(function(keyPart) {
                var binding = this.parseKeys(keyPart);
                var id = KEY_MODS[binding.hashId] + binding.key;
                chain += (chain ? " " : "") + id;
                this._addCommandToBinding(chain, "chainKeys");
              }, this);
              chain += " ";
            }
            var binding = this.parseKeys(keyPart);
            var id = KEY_MODS[binding.hashId] + binding.key;
            this._addCommandToBinding(chain + id, command, position);
          }, this);
        };
        function getPosition(command) {
          return typeof command == "object" && command.bindKey && command.bindKey.position || 0;
        }
        this._addCommandToBinding = function(keyId, command, position) {
          var ckb = this.commandKeyBinding,
              i;
          if (!command) {
            delete ckb[keyId];
          } else if (!ckb[keyId] || this.$singleCommand) {
            ckb[keyId] = command;
          } else {
            if (!Array.isArray(ckb[keyId])) {
              ckb[keyId] = [ckb[keyId]];
            } else if ((i = ckb[keyId].indexOf(command)) != -1) {
              ckb[keyId].splice(i, 1);
            }
            if (typeof position != "number") {
              if (position || command.isDefault)
                position = -100;
              else
                position = getPosition(command);
            }
            var commands = ckb[keyId];
            for (i = 0; i < commands.length; i++) {
              var other = commands[i];
              var otherPos = getPosition(other);
              if (otherPos > position)
                break;
            }
            commands.splice(i, 0, command);
          }
        };
        this.addCommands = function(commands) {
          commands && Object.keys(commands).forEach(function(name) {
            var command = commands[name];
            if (!command)
              return;
            if (typeof command === "string")
              return this.bindKey(command, name);
            if (typeof command === "function")
              command = {exec: command};
            if (typeof command !== "object")
              return;
            if (!command.name)
              command.name = name;
            this.addCommand(command);
          }, this);
        };
        this.removeCommands = function(commands) {
          Object.keys(commands).forEach(function(name) {
            this.removeCommand(commands[name]);
          }, this);
        };
        this.bindKeys = function(keyList) {
          Object.keys(keyList).forEach(function(key) {
            this.bindKey(key, keyList[key]);
          }, this);
        };
        this._buildKeyHash = function(command) {
          this.bindKey(command.bindKey, command);
        };
        this.parseKeys = function(keys) {
          var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
            return x;
          });
          var key = parts.pop();
          var keyCode = keyUtil[key];
          if (keyUtil.FUNCTION_KEYS[keyCode])
            key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
          else if (!parts.length)
            return {
              key: key,
              hashId: -1
            };
          else if (parts.length == 1 && parts[0] == "shift")
            return {
              key: key.toUpperCase(),
              hashId: -1
            };
          var hashId = 0;
          for (var i = parts.length; i--; ) {
            var modifier = keyUtil.KEY_MODS[parts[i]];
            if (modifier == null) {
              if (typeof console != "undefined")
                console.error("invalid modifier " + parts[i] + " in " + keys);
              return false;
            }
            hashId |= modifier;
          }
          return {
            key: key,
            hashId: hashId
          };
        };
        this.findKeyCommand = function findKeyCommand(hashId, keyString) {
          var key = KEY_MODS[hashId] + keyString;
          return this.commandKeyBinding[key];
        };
        this.handleKeyboard = function(data, hashId, keyString, keyCode) {
          if (keyCode < 0)
            return;
          var key = KEY_MODS[hashId] + keyString;
          var command = this.commandKeyBinding[key];
          if (data.$keyChain) {
            data.$keyChain += " " + key;
            command = this.commandKeyBinding[data.$keyChain] || command;
          }
          if (command) {
            if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
              data.$keyChain = data.$keyChain || key;
              return {command: "null"};
            }
          }
          if (data.$keyChain) {
            if ((!hashId || hashId == 4) && keyString.length == 1)
              data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
            else if (hashId == -1 || keyCode > 0)
              data.$keyChain = "";
          }
          return {command: command};
        };
        this.getStatusText = function(editor, data) {
          return data.$keyChain || "";
        };
      }).call(HashHandler.prototype);
      exports.HashHandler = HashHandler;
      exports.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require, exports, module) {
      "use strict";
      var oop = require("../lib/oop");
      var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = require("../lib/event_emitter").EventEmitter;
      var CommandManager = function(platform, commands) {
        MultiHashHandler.call(this, commands, platform);
        this.byName = this.commands;
        this.setDefaultHandler("exec", function(e) {
          return e.command.exec(e.editor, e.args || {});
        });
      };
      oop.inherits(CommandManager, MultiHashHandler);
      (function() {
        oop.implement(this, EventEmitter);
        this.exec = function(command, editor, args) {
          if (Array.isArray(command)) {
            for (var i = command.length; i--; ) {
              if (this.exec(command[i], editor, args))
                return true;
            }
            return false;
          }
          if (typeof command === "string")
            command = this.commands[command];
          if (!command)
            return false;
          if (editor && editor.$readOnly && !command.readOnly)
            return false;
          var e = {
            editor: editor,
            command: command,
            args: args
          };
          e.returnValue = this._emit("exec", e);
          this._signal("afterExec", e);
          return e.returnValue === false ? false : true;
        };
        this.toggleRecording = function(editor) {
          if (this.$inReplay)
            return;
          editor && editor._emit("changeStatus");
          if (this.recording) {
            this.macro.pop();
            this.removeEventListener("exec", this.$addCommandToMacro);
            if (!this.macro.length)
              this.macro = this.oldMacro;
            return this.recording = false;
          }
          if (!this.$addCommandToMacro) {
            this.$addCommandToMacro = function(e) {
              this.macro.push([e.command, e.args]);
            }.bind(this);
          }
          this.oldMacro = this.macro;
          this.macro = [];
          this.on("exec", this.$addCommandToMacro);
          return this.recording = true;
        };
        this.replay = function(editor) {
          if (this.$inReplay || !this.macro)
            return;
          if (this.recording)
            return this.toggleRecording(editor);
          try {
            this.$inReplay = true;
            this.macro.forEach(function(x) {
              if (typeof x == "string")
                this.exec(x, editor);
              else
                this.exec(x[0], editor, x[1]);
            }, this);
          } finally {
            this.$inReplay = false;
          }
        };
        this.trimMacro = function(m) {
          return m.map(function(x) {
            if (typeof x[0] != "string")
              x[0] = x[0].name;
            if (!x[1])
              x = x[0];
            return x;
          });
        };
      }).call(CommandManager.prototype);
      exports.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require, exports, module) {
      "use strict";
      var lang = require("../lib/lang");
      var config = require("../config");
      var Range = require("../range").Range;
      function bindKey(win, mac) {
        return {
          win: win,
          mac: mac
        };
      }
      exports.commands = [{
        name: "showSettingsMenu",
        bindKey: bindKey("Ctrl-,", "Command-,"),
        exec: function(editor) {
          config.loadModule("ace/ext/settings_menu", function(module) {
            module.init(editor);
            editor.showSettingsMenu();
          });
        },
        readOnly: true
      }, {
        name: "goToNextError",
        bindKey: bindKey("Alt-E", "Ctrl-E"),
        exec: function(editor) {
          config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, 1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "goToPreviousError",
        bindKey: bindKey("Alt-Shift-E", "Ctrl-Shift-E"),
        exec: function(editor) {
          config.loadModule("ace/ext/error_marker", function(module) {
            module.showErrorMarker(editor, -1);
          });
        },
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "selectall",
        bindKey: bindKey("Ctrl-A", "Command-A"),
        exec: function(editor) {
          editor.selectAll();
        },
        readOnly: true
      }, {
        name: "centerselection",
        bindKey: bindKey(null, "Ctrl-L"),
        exec: function(editor) {
          editor.centerSelection();
        },
        readOnly: true
      }, {
        name: "gotoline",
        bindKey: bindKey("Ctrl-L", "Command-L"),
        exec: function(editor) {
          var line = parseInt(prompt("Enter line number:"), 10);
          if (!isNaN(line)) {
            editor.gotoLine(line);
          }
        },
        readOnly: true
      }, {
        name: "fold",
        bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function(editor) {
          editor.session.toggleFold(false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "unfold",
        bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function(editor) {
          editor.session.toggleFold(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "toggleFoldWidget",
        bindKey: bindKey("F2", "F2"),
        exec: function(editor) {
          editor.session.toggleFoldWidget();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "toggleParentFoldWidget",
        bindKey: bindKey("Alt-F2", "Alt-F2"),
        exec: function(editor) {
          editor.session.toggleFoldWidget(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "foldall",
        bindKey: bindKey(null, "Ctrl-Command-Option-0"),
        exec: function(editor) {
          editor.session.foldAll();
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "foldOther",
        bindKey: bindKey("Alt-0", "Command-Option-0"),
        exec: function(editor) {
          editor.session.foldAll();
          editor.session.unfold(editor.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "unfoldall",
        bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function(editor) {
          editor.session.unfold();
        },
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "findnext",
        bindKey: bindKey("Ctrl-K", "Command-G"),
        exec: function(editor) {
          editor.findNext();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "findprevious",
        bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function(editor) {
          editor.findPrevious();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: true
      }, {
        name: "selectOrFindNext",
        bindKey: bindKey("Alt-K", "Ctrl-G"),
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          else
            editor.findNext();
        },
        readOnly: true
      }, {
        name: "selectOrFindPrevious",
        bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function(editor) {
          if (editor.selection.isEmpty())
            editor.selection.selectWord();
          else
            editor.findPrevious();
        },
        readOnly: true
      }, {
        name: "find",
        bindKey: bindKey("Ctrl-F", "Command-F"),
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor);
          });
        },
        readOnly: true
      }, {
        name: "overwrite",
        bindKey: "Insert",
        exec: function(editor) {
          editor.toggleOverwrite();
        },
        readOnly: true
      }, {
        name: "selecttostart",
        bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Up"),
        exec: function(editor) {
          editor.getSelection().selectFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "gotostart",
        bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function(editor) {
          editor.navigateFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "selectup",
        bindKey: bindKey("Shift-Up", "Shift-Up"),
        exec: function(editor) {
          editor.getSelection().selectUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "golineup",
        bindKey: bindKey("Up", "Up|Ctrl-P"),
        exec: function(editor, args) {
          editor.navigateUp(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttoend",
        bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-Down"),
        exec: function(editor) {
          editor.getSelection().selectFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "gotoend",
        bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
        exec: function(editor) {
          editor.navigateFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: true,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      }, {
        name: "selectdown",
        bindKey: bindKey("Shift-Down", "Shift-Down"),
        exec: function(editor) {
          editor.getSelection().selectDown();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "golinedown",
        bindKey: bindKey("Down", "Down|Ctrl-N"),
        exec: function(editor, args) {
          editor.navigateDown(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectwordleft",
        bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function(editor) {
          editor.getSelection().selectWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotowordleft",
        bindKey: bindKey("Ctrl-Left", "Option-Left"),
        exec: function(editor) {
          editor.navigateWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttolinestart",
        bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left"),
        exec: function(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotolinestart",
        bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function(editor) {
          editor.navigateLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectleft",
        bindKey: bindKey("Shift-Left", "Shift-Left"),
        exec: function(editor) {
          editor.getSelection().selectLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotoleft",
        bindKey: bindKey("Left", "Left|Ctrl-B"),
        exec: function(editor, args) {
          editor.navigateLeft(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectwordright",
        bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotowordright",
        bindKey: bindKey("Ctrl-Right", "Option-Right"),
        exec: function(editor) {
          editor.navigateWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selecttolineend",
        bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotolineend",
        bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function(editor) {
          editor.navigateLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectright",
        bindKey: bindKey("Shift-Right", "Shift-Right"),
        exec: function(editor) {
          editor.getSelection().selectRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "gotoright",
        bindKey: bindKey("Right", "Right|Ctrl-F"),
        exec: function(editor, args) {
          editor.navigateRight(args.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectpagedown",
        bindKey: "Shift-PageDown",
        exec: function(editor) {
          editor.selectPageDown();
        },
        readOnly: true
      }, {
        name: "pagedown",
        bindKey: bindKey(null, "Option-PageDown"),
        exec: function(editor) {
          editor.scrollPageDown();
        },
        readOnly: true
      }, {
        name: "gotopagedown",
        bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
        exec: function(editor) {
          editor.gotoPageDown();
        },
        readOnly: true
      }, {
        name: "selectpageup",
        bindKey: "Shift-PageUp",
        exec: function(editor) {
          editor.selectPageUp();
        },
        readOnly: true
      }, {
        name: "pageup",
        bindKey: bindKey(null, "Option-PageUp"),
        exec: function(editor) {
          editor.scrollPageUp();
        },
        readOnly: true
      }, {
        name: "gotopageup",
        bindKey: "PageUp",
        exec: function(editor) {
          editor.gotoPageUp();
        },
        readOnly: true
      }, {
        name: "scrollup",
        bindKey: bindKey("Ctrl-Up", null),
        exec: function(e) {
          e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      }, {
        name: "scrolldown",
        bindKey: bindKey("Ctrl-Down", null),
        exec: function(e) {
          e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
        },
        readOnly: true
      }, {
        name: "selectlinestart",
        bindKey: "Shift-Home",
        exec: function(editor) {
          editor.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectlineend",
        bindKey: "Shift-End",
        exec: function(editor) {
          editor.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "togglerecording",
        bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
        exec: function(editor) {
          editor.commands.toggleRecording(editor);
        },
        readOnly: true
      }, {
        name: "replaymacro",
        bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function(editor) {
          editor.commands.replay(editor);
        },
        readOnly: true
      }, {
        name: "jumptomatching",
        bindKey: bindKey("Ctrl-P", "Ctrl-P"),
        exec: function(editor) {
          editor.jumpToMatching();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "selecttomatching",
        bindKey: bindKey("Ctrl-Shift-P", "Ctrl-Shift-P"),
        exec: function(editor) {
          editor.jumpToMatching(true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "expandToMatching",
        bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function(editor) {
          editor.jumpToMatching(true, true);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: true
      }, {
        name: "passKeysToBrowser",
        bindKey: bindKey(null, null),
        exec: function() {},
        passEvent: true,
        readOnly: true
      }, {
        name: "copy",
        exec: function(editor) {},
        readOnly: true
      }, {
        name: "cut",
        exec: function(editor) {
          var range = editor.getSelectionRange();
          editor._emit("cut", range);
          if (!editor.selection.isEmpty()) {
            editor.session.remove(range);
            editor.clearSelection();
          }
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "paste",
        exec: function(editor, args) {
          editor.$handlePaste(args);
        },
        scrollIntoView: "cursor"
      }, {
        name: "removeline",
        bindKey: bindKey("Ctrl-D", "Command-D"),
        exec: function(editor) {
          editor.removeLines();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
      }, {
        name: "duplicateSelection",
        bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function(editor) {
          editor.duplicateSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "sortlines",
        bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function(editor) {
          editor.sortLines();
        },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
      }, {
        name: "togglecomment",
        bindKey: bindKey("Ctrl-/", "Command-/"),
        exec: function(editor) {
          editor.toggleCommentLines();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "toggleBlockComment",
        bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function(editor) {
          editor.toggleBlockComment();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "modifyNumberUp",
        bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function(editor) {
          editor.modifyNumber(1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "modifyNumberDown",
        bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function(editor) {
          editor.modifyNumber(-1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      }, {
        name: "replace",
        bindKey: bindKey("Ctrl-H", "Command-Option-F"),
        exec: function(editor) {
          config.loadModule("ace/ext/searchbox", function(e) {
            e.Search(editor, true);
          });
        }
      }, {
        name: "undo",
        bindKey: bindKey("Ctrl-Z", "Command-Z"),
        exec: function(editor) {
          editor.undo();
        }
      }, {
        name: "redo",
        bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function(editor) {
          editor.redo();
        }
      }, {
        name: "copylinesup",
        bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
        exec: function(editor) {
          editor.copyLinesUp();
        },
        scrollIntoView: "cursor"
      }, {
        name: "movelinesup",
        bindKey: bindKey("Alt-Up", "Option-Up"),
        exec: function(editor) {
          editor.moveLinesUp();
        },
        scrollIntoView: "cursor"
      }, {
        name: "copylinesdown",
        bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
        exec: function(editor) {
          editor.copyLinesDown();
        },
        scrollIntoView: "cursor"
      }, {
        name: "movelinesdown",
        bindKey: bindKey("Alt-Down", "Option-Down"),
        exec: function(editor) {
          editor.moveLinesDown();
        },
        scrollIntoView: "cursor"
      }, {
        name: "del",
        bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function(editor) {
          editor.remove("right");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "backspace",
        bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
        exec: function(editor) {
          editor.remove("left");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "cut_or_delete",
        bindKey: bindKey("Shift-Delete", null),
        exec: function(editor) {
          if (editor.selection.isEmpty()) {
            editor.remove("left");
          } else {
            return false;
          }
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolinestart",
        bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
        exec: function(editor) {
          editor.removeToLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removetolineend",
        bindKey: bindKey("Alt-Delete", "Ctrl-K"),
        exec: function(editor) {
          editor.removeToLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removewordleft",
        bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function(editor) {
          editor.removeWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "removewordright",
        bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
        exec: function(editor) {
          editor.removeWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "outdent",
        bindKey: bindKey("Shift-Tab", "Shift-Tab"),
        exec: function(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "indent",
        bindKey: bindKey("Tab", "Tab"),
        exec: function(editor) {
          editor.indent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      }, {
        name: "blockoutdent",
        bindKey: bindKey("Ctrl-[", "Ctrl-["),
        exec: function(editor) {
          editor.blockOutdent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "blockindent",
        bindKey: bindKey("Ctrl-]", "Ctrl-]"),
        exec: function(editor) {
          editor.blockIndent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      }, {
        name: "insertstring",
        exec: function(editor, str) {
          editor.insert(str);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "inserttext",
        exec: function(editor, args) {
          editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "splitline",
        bindKey: bindKey(null, "Ctrl-O"),
        exec: function(editor) {
          editor.splitLine();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "transposeletters",
        bindKey: bindKey("Ctrl-T", "Ctrl-T"),
        exec: function(editor) {
          editor.transposeLetters();
        },
        multiSelectAction: function(editor) {
          editor.transposeSelections(1);
        },
        scrollIntoView: "cursor"
      }, {
        name: "touppercase",
        bindKey: bindKey("Ctrl-U", "Ctrl-U"),
        exec: function(editor) {
          editor.toUpperCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "tolowercase",
        bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function(editor) {
          editor.toLowerCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      }, {
        name: "expandtoline",
        bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function(editor) {
          var range = editor.selection.getRange();
          range.start.column = range.end.column = 0;
          range.end.row++;
          editor.selection.setRange(range, false);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "joinlines",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          var isBackwards = editor.selection.isBackwards();
          var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
          var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
          var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
          var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
          var selectedCount = selectedText.replace(/\n\s*/, " ").length;
          var insertLine = editor.session.doc.getLine(selectionStart.row);
          for (var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++) {
            var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
            if (curLine.length !== 0) {
              curLine = " " + curLine;
            }
            insertLine += curLine;
          }
          if (selectionEnd.row + 1 < (editor.session.doc.getLength() - 1)) {
            insertLine += editor.session.doc.getNewLineCharacter();
          }
          editor.clearSelection();
          editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
          if (selectedCount > 0) {
            editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
            editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
          } else {
            firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? (firstLineEndCol + 1) : firstLineEndCol;
            editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
          }
        },
        multiSelectAction: "forEach",
        readOnly: true
      }, {
        name: "invertSelection",
        bindKey: bindKey(null, null),
        exec: function(editor) {
          var endRow = editor.session.doc.getLength() - 1;
          var endCol = editor.session.doc.getLine(endRow).length;
          var ranges = editor.selection.rangeList.ranges;
          var newRanges = [];
          if (ranges.length < 1) {
            ranges = [editor.selection.getRange()];
          }
          for (var i = 0; i < ranges.length; i++) {
            if (i == (ranges.length - 1)) {
              if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) {
                newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
              }
            }
            if (i === 0) {
              if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) {
                newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
              }
            } else {
              newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
            }
          }
          editor.exitMultiSelectMode();
          editor.clearSelection();
          for (var i = 0; i < newRanges.length; i++) {
            editor.selection.addRange(newRanges[i], false);
          }
        },
        readOnly: true,
        scrollIntoView: "none"
      }];
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator"], function(require, exports, module) {
      "use strict";
      require("./lib/fixoldbrowsers");
      var oop = require("./lib/oop");
      var dom = require("./lib/dom");
      var lang = require("./lib/lang");
      var useragent = require("./lib/useragent");
      var TextInput = require("./keyboard/textinput").TextInput;
      var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = require("./mouse/fold_handler").FoldHandler;
      var KeyBinding = require("./keyboard/keybinding").KeyBinding;
      var EditSession = require("./edit_session").EditSession;
      var Search = require("./search").Search;
      var Range = require("./range").Range;
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var CommandManager = require("./commands/command_manager").CommandManager;
      var defaultCommands = require("./commands/default_commands").commands;
      var config = require("./config");
      var TokenIterator = require("./token_iterator").TokenIterator;
      var Editor = function(renderer, session) {
        var container = renderer.getContainerElement();
        this.container = container;
        this.renderer = renderer;
        this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
        this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
        this.renderer.textarea = this.textInput.getElement();
        this.keyBinding = new KeyBinding(this);
        this.$mouseHandler = new MouseHandler(this);
        new FoldHandler(this);
        this.$blockScrolling = 0;
        this.$search = new Search().set({wrap: true});
        this.$historyTracker = this.$historyTracker.bind(this);
        this.commands.on("exec", this.$historyTracker);
        this.$initOperationListeners();
        this._$emitInputEvent = lang.delayedCall(function() {
          this._signal("input", {});
          if (this.session && this.session.bgTokenizer)
            this.session.bgTokenizer.scheduleStart();
        }.bind(this));
        this.on("change", function(_, _self) {
          _self._$emitInputEvent.schedule(31);
        });
        this.setSession(session || new EditSession(""));
        config.resetOptions(this);
        config._signal("editor", this);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$initOperationListeners = function() {
          function last(a) {
            return a[a.length - 1];
          }
          this.selections = [];
          this.commands.on("exec", this.startOperation.bind(this), true);
          this.commands.on("afterExec", this.endOperation.bind(this), true);
          this.$opResetTimer = lang.delayedCall(this.endOperation.bind(this));
          this.on("change", function() {
            this.curOp || this.startOperation();
            this.curOp.docChanged = true;
          }.bind(this), true);
          this.on("changeSelection", function() {
            this.curOp || this.startOperation();
            this.curOp.selectionChanged = true;
          }.bind(this), true);
        };
        this.curOp = null;
        this.prevOp = {};
        this.startOperation = function(commadEvent) {
          if (this.curOp) {
            if (!commadEvent || this.curOp.command)
              return;
            this.prevOp = this.curOp;
          }
          if (!commadEvent) {
            this.previousCommand = null;
            commadEvent = {};
          }
          this.$opResetTimer.schedule();
          this.curOp = {
            command: commadEvent.command || {},
            args: commadEvent.args,
            scrollTop: this.renderer.scrollTop
          };
          if (this.curOp.command.name && this.curOp.command.scrollIntoView !== undefined)
            this.$blockScrolling++;
        };
        this.endOperation = function(e) {
          if (this.curOp) {
            if (e && e.returnValue === false)
              return this.curOp = null;
            this._signal("beforeEndOperation");
            var command = this.curOp.command;
            if (command.name && this.$blockScrolling > 0)
              this.$blockScrolling--;
            var scrollIntoView = command && command.scrollIntoView;
            if (scrollIntoView) {
              switch (scrollIntoView) {
                case "center-animate":
                  scrollIntoView = "animate";
                case "center":
                  this.renderer.scrollCursorIntoView(null, 0.5);
                  break;
                case "animate":
                case "cursor":
                  this.renderer.scrollCursorIntoView();
                  break;
                case "selectionPart":
                  var range = this.selection.getRange();
                  var config = this.renderer.layerConfig;
                  if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) {
                    this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                  }
                  break;
                default:
                  break;
              }
              if (scrollIntoView == "animate")
                this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            this.prevOp = this.curOp;
            this.curOp = null;
          }
        };
        this.$mergeableCommands = ["backspace", "del", "insertstring"];
        this.$historyTracker = function(e) {
          if (!this.$mergeUndoDeltas)
            return;
          var prev = this.prevOp;
          var mergeableCommands = this.$mergeableCommands;
          var shouldMerge = prev.command && (e.command.name == prev.command.name);
          if (e.command.name == "insertstring") {
            var text = e.args;
            if (this.mergeNextCommand === undefined)
              this.mergeNextCommand = true;
            shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
            this.mergeNextCommand = true;
          } else {
            shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1;
          }
          if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) {
            shouldMerge = false;
          }
          if (shouldMerge)
            this.session.mergeUndoDeltas = true;
          else if (mergeableCommands.indexOf(e.command.name) !== -1)
            this.sequenceStartTime = Date.now();
        };
        this.setKeyboardHandler = function(keyboardHandler, cb) {
          if (keyboardHandler && typeof keyboardHandler === "string") {
            this.$keybindingId = keyboardHandler;
            var _self = this;
            config.loadModule(["keybinding", keyboardHandler], function(module) {
              if (_self.$keybindingId == keyboardHandler)
                _self.keyBinding.setKeyboardHandler(module && module.handler);
              cb && cb();
            });
          } else {
            this.$keybindingId = null;
            this.keyBinding.setKeyboardHandler(keyboardHandler);
            cb && cb();
          }
        };
        this.getKeyboardHandler = function() {
          return this.keyBinding.getKeyboardHandler();
        };
        this.setSession = function(session) {
          if (this.session == session)
            return;
          if (this.curOp)
            this.endOperation();
          this.curOp = {};
          var oldSession = this.session;
          if (oldSession) {
            this.session.off("change", this.$onDocumentChange);
            this.session.off("changeMode", this.$onChangeMode);
            this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
            this.session.off("changeTabSize", this.$onChangeTabSize);
            this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
            this.session.off("changeWrapMode", this.$onChangeWrapMode);
            this.session.off("changeFold", this.$onChangeFold);
            this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
            this.session.off("changeBackMarker", this.$onChangeBackMarker);
            this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
            this.session.off("changeAnnotation", this.$onChangeAnnotation);
            this.session.off("changeOverwrite", this.$onCursorChange);
            this.session.off("changeScrollTop", this.$onScrollTopChange);
            this.session.off("changeScrollLeft", this.$onScrollLeftChange);
            var selection = this.session.getSelection();
            selection.off("changeCursor", this.$onCursorChange);
            selection.off("changeSelection", this.$onSelectionChange);
          }
          this.session = session;
          if (session) {
            this.$onDocumentChange = this.onDocumentChange.bind(this);
            session.on("change", this.$onDocumentChange);
            this.renderer.setSession(session);
            this.$onChangeMode = this.onChangeMode.bind(this);
            session.on("changeMode", this.$onChangeMode);
            this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
            session.on("tokenizerUpdate", this.$onTokenizerUpdate);
            this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
            session.on("changeTabSize", this.$onChangeTabSize);
            this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
            session.on("changeWrapLimit", this.$onChangeWrapLimit);
            this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
            session.on("changeWrapMode", this.$onChangeWrapMode);
            this.$onChangeFold = this.onChangeFold.bind(this);
            session.on("changeFold", this.$onChangeFold);
            this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
            this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
            this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
            this.session.on("changeBackMarker", this.$onChangeBackMarker);
            this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
            this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
            this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
            this.session.on("changeAnnotation", this.$onChangeAnnotation);
            this.$onCursorChange = this.onCursorChange.bind(this);
            this.session.on("changeOverwrite", this.$onCursorChange);
            this.$onScrollTopChange = this.onScrollTopChange.bind(this);
            this.session.on("changeScrollTop", this.$onScrollTopChange);
            this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
            this.session.on("changeScrollLeft", this.$onScrollLeftChange);
            this.selection = session.getSelection();
            this.selection.on("changeCursor", this.$onCursorChange);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.onChangeMode();
            this.$blockScrolling += 1;
            this.onCursorChange();
            this.$blockScrolling -= 1;
            this.onScrollTopChange();
            this.onScrollLeftChange();
            this.onSelectionChange();
            this.onChangeFrontMarker();
            this.onChangeBackMarker();
            this.onChangeBreakpoint();
            this.onChangeAnnotation();
            this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
            this.renderer.updateFull();
          } else {
            this.selection = null;
            this.renderer.setSession(session);
          }
          this._signal("changeSession", {
            session: session,
            oldSession: oldSession
          });
          this.curOp = null;
          oldSession && oldSession._signal("changeEditor", {oldEditor: this});
          session && session._signal("changeEditor", {editor: this});
        };
        this.getSession = function() {
          return this.session;
        };
        this.setValue = function(val, cursorPos) {
          this.session.doc.setValue(val);
          if (!cursorPos)
            this.selectAll();
          else if (cursorPos == 1)
            this.navigateFileEnd();
          else if (cursorPos == -1)
            this.navigateFileStart();
          return val;
        };
        this.getValue = function() {
          return this.session.getValue();
        };
        this.getSelection = function() {
          return this.selection;
        };
        this.resize = function(force) {
          this.renderer.onResize(force);
        };
        this.setTheme = function(theme, cb) {
          this.renderer.setTheme(theme, cb);
        };
        this.getTheme = function() {
          return this.renderer.getTheme();
        };
        this.setStyle = function(style) {
          this.renderer.setStyle(style);
        };
        this.unsetStyle = function(style) {
          this.renderer.unsetStyle(style);
        };
        this.getFontSize = function() {
          return this.getOption("fontSize") || dom.computedStyle(this.container, "fontSize");
        };
        this.setFontSize = function(size) {
          this.setOption("fontSize", size);
        };
        this.$highlightBrackets = function() {
          if (this.session.$bracketHighlight) {
            this.session.removeMarker(this.session.$bracketHighlight);
            this.session.$bracketHighlight = null;
          }
          if (this.$highlightPending) {
            return;
          }
          var self = this;
          this.$highlightPending = true;
          setTimeout(function() {
            self.$highlightPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer)
              return;
            var pos = session.findMatchingBracket(self.getCursorPosition());
            if (pos) {
              var range = new Range(pos.row, pos.column, pos.row, pos.column + 1);
            } else if (session.$mode.getMatching) {
              var range = session.$mode.getMatching(self.session);
            }
            if (range)
              session.$bracketHighlight = session.addMarker(range, "ace_bracket", "text");
          }, 50);
        };
        this.$highlightTags = function() {
          if (this.$highlightTagPending)
            return;
          var self = this;
          this.$highlightTagPending = true;
          setTimeout(function() {
            self.$highlightTagPending = false;
            var session = self.session;
            if (!session || !session.bgTokenizer)
              return;
            var pos = self.getCursorPosition();
            var iterator = new TokenIterator(self.session, pos.row, pos.column);
            var token = iterator.getCurrentToken();
            if (!token || !/\b(?:tag-open|tag-name)/.test(token.type)) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
              return;
            }
            if (token.type.indexOf("tag-open") != -1) {
              token = iterator.stepForward();
              if (!token)
                return;
            }
            var tag = token.value;
            var depth = 0;
            var prevToken = iterator.stepBackward();
            if (prevToken.value == '<') {
              do {
                prevToken = token;
                token = iterator.stepForward();
                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                  if (prevToken.value === '<') {
                    depth++;
                  } else if (prevToken.value === '</') {
                    depth--;
                  }
                }
              } while (token && depth >= 0);
            } else {
              do {
                token = prevToken;
                prevToken = iterator.stepBackward();
                if (token && token.value === tag && token.type.indexOf('tag-name') !== -1) {
                  if (prevToken.value === '<') {
                    depth++;
                  } else if (prevToken.value === '</') {
                    depth--;
                  }
                }
              } while (prevToken && depth <= 0);
              iterator.stepForward();
            }
            if (!token) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
              return;
            }
            var row = iterator.getCurrentTokenRow();
            var column = iterator.getCurrentTokenColumn();
            var range = new Range(row, column, row, column + token.value.length);
            if (session.$tagHighlight && range.compareRange(session.$backMarkers[session.$tagHighlight].range) !== 0) {
              session.removeMarker(session.$tagHighlight);
              session.$tagHighlight = null;
            }
            if (range && !session.$tagHighlight)
              session.$tagHighlight = session.addMarker(range, "ace_bracket", "text");
          }, 50);
        };
        this.focus = function() {
          var _self = this;
          setTimeout(function() {
            _self.textInput.focus();
          });
          this.textInput.focus();
        };
        this.isFocused = function() {
          return this.textInput.isFocused();
        };
        this.blur = function() {
          this.textInput.blur();
        };
        this.onFocus = function(e) {
          if (this.$isFocused)
            return;
          this.$isFocused = true;
          this.renderer.showCursor();
          this.renderer.visualizeFocus();
          this._emit("focus", e);
        };
        this.onBlur = function(e) {
          if (!this.$isFocused)
            return;
          this.$isFocused = false;
          this.renderer.hideCursor();
          this.renderer.visualizeBlur();
          this._emit("blur", e);
        };
        this.$cursorChange = function() {
          this.renderer.updateCursor();
        };
        this.onDocumentChange = function(delta) {
          var wrap = this.session.$useWrapMode;
          var lastRow = (delta.start.row == delta.end.row ? delta.end.row : Infinity);
          this.renderer.updateLines(delta.start.row, lastRow, wrap);
          this._signal("change", delta);
          this.$cursorChange();
          this.$updateHighlightActiveLine();
        };
        this.onTokenizerUpdate = function(e) {
          var rows = e.data;
          this.renderer.updateLines(rows.first, rows.last);
        };
        this.onScrollTopChange = function() {
          this.renderer.scrollToY(this.session.getScrollTop());
        };
        this.onScrollLeftChange = function() {
          this.renderer.scrollToX(this.session.getScrollLeft());
        };
        this.onCursorChange = function() {
          this.$cursorChange();
          if (!this.$blockScrolling) {
            config.warn("Automatically scrolling cursor into view after selection change", "this will be disabled in the next version", "set editor.$blockScrolling = Infinity to disable this message");
            this.renderer.scrollCursorIntoView();
          }
          this.$highlightBrackets();
          this.$highlightTags();
          this.$updateHighlightActiveLine();
          this._signal("changeSelection");
        };
        this.$updateHighlightActiveLine = function() {
          var session = this.getSession();
          var highlight;
          if (this.$highlightActiveLine) {
            if ((this.$selectionStyle != "line" || !this.selection.isMultiLine()))
              highlight = this.getCursorPosition();
            if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
              highlight = false;
          }
          if (session.$highlightLineMarker && !highlight) {
            session.removeMarker(session.$highlightLineMarker.id);
            session.$highlightLineMarker = null;
          } else if (!session.$highlightLineMarker && highlight) {
            var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
            range.id = session.addMarker(range, "ace_active-line", "screenLine");
            session.$highlightLineMarker = range;
          } else if (highlight) {
            session.$highlightLineMarker.start.row = highlight.row;
            session.$highlightLineMarker.end.row = highlight.row;
            session.$highlightLineMarker.start.column = highlight.column;
            session._signal("changeBackMarker");
          }
        };
        this.onSelectionChange = function(e) {
          var session = this.session;
          if (session.$selectionMarker) {
            session.removeMarker(session.$selectionMarker);
          }
          session.$selectionMarker = null;
          if (!this.selection.isEmpty()) {
            var range = this.selection.getRange();
            var style = this.getSelectionStyle();
            session.$selectionMarker = session.addMarker(range, "ace_selection", style);
          } else {
            this.$updateHighlightActiveLine();
          }
          var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
          this.session.highlight(re);
          this._signal("changeSelection");
        };
        this.$getSelectionHighLightRegexp = function() {
          var session = this.session;
          var selection = this.getSelectionRange();
          if (selection.isEmpty() || selection.isMultiLine())
            return;
          var startOuter = selection.start.column - 1;
          var endOuter = selection.end.column + 1;
          var line = session.getLine(selection.start.row);
          var lineCols = line.length;
          var needle = line.substring(Math.max(startOuter, 0), Math.min(endOuter, lineCols));
          if ((startOuter >= 0 && /^[\w\d]/.test(needle)) || (endOuter <= lineCols && /[\w\d]$/.test(needle)))
            return;
          needle = line.substring(selection.start.column, selection.end.column);
          if (!/^[\w\d]+$/.test(needle))
            return;
          var re = this.$search.$assembleRegExp({
            wholeWord: true,
            caseSensitive: true,
            needle: needle
          });
          return re;
        };
        this.onChangeFrontMarker = function() {
          this.renderer.updateFrontMarkers();
        };
        this.onChangeBackMarker = function() {
          this.renderer.updateBackMarkers();
        };
        this.onChangeBreakpoint = function() {
          this.renderer.updateBreakpoints();
        };
        this.onChangeAnnotation = function() {
          this.renderer.setAnnotations(this.session.getAnnotations());
        };
        this.onChangeMode = function(e) {
          this.renderer.updateText();
          this._emit("changeMode", e);
        };
        this.onChangeWrapLimit = function() {
          this.renderer.updateFull();
        };
        this.onChangeWrapMode = function() {
          this.renderer.onResize(true);
        };
        this.onChangeFold = function() {
          this.$updateHighlightActiveLine();
          this.renderer.updateFull();
        };
        this.getSelectedText = function() {
          return this.session.getTextRange(this.getSelectionRange());
        };
        this.getCopyText = function() {
          var text = this.getSelectedText();
          this._signal("copy", text);
          return text;
        };
        this.onCopy = function() {
          this.commands.exec("copy", this);
        };
        this.onCut = function() {
          this.commands.exec("cut", this);
        };
        this.onPaste = function(text, event) {
          var e = {
            text: text,
            event: event
          };
          this.commands.exec("paste", this, e);
        };
        this.$handlePaste = function(e) {
          if (typeof e == "string")
            e = {text: e};
          this._signal("paste", e);
          var text = e.text;
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
            this.insert(text);
          } else {
            var lines = text.split(/\r\n|\r|\n/);
            var ranges = this.selection.rangeList.ranges;
            if (lines.length > ranges.length || lines.length < 2 || !lines[1])
              return this.commands.exec("insertstring", this, text);
            for (var i = ranges.length; i--; ) {
              var range = ranges[i];
              if (!range.isEmpty())
                this.session.remove(range);
              this.session.insert(range.start, lines[i]);
            }
          }
        };
        this.execCommand = function(command, args) {
          return this.commands.exec(command, this, args);
        };
        this.insert = function(text, pasted) {
          var session = this.session;
          var mode = session.getMode();
          var cursor = this.getCursorPosition();
          if (this.getBehavioursEnabled() && !pasted) {
            var transform = mode.transformAction(session.getState(cursor.row), 'insertion', this, session, text);
            if (transform) {
              if (text !== transform.text) {
                this.session.mergeUndoDeltas = false;
                this.$mergeNextCommand = false;
              }
              text = transform.text;
            }
          }
          if (text == "\t")
            text = this.session.getTabString();
          if (!this.selection.isEmpty()) {
            var range = this.getSelectionRange();
            cursor = this.session.remove(range);
            this.clearSelection();
          } else if (this.session.getOverwrite()) {
            var range = new Range.fromPoints(cursor, cursor);
            range.end.column += text.length;
            this.session.remove(range);
          }
          if (text == "\n" || text == "\r\n") {
            var line = session.getLine(cursor.row);
            if (cursor.column > line.search(/\S|$/)) {
              var d = line.substr(cursor.column).search(/\S|$/);
              session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
            }
          }
          this.clearSelection();
          var start = cursor.column;
          var lineState = session.getState(cursor.row);
          var line = session.getLine(cursor.row);
          var shouldOutdent = mode.checkOutdent(lineState, line, text);
          var end = session.insert(cursor, text);
          if (transform && transform.selection) {
            if (transform.selection.length == 2) {
              this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
            } else {
              this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
            }
          }
          if (session.getDocument().isNewLine(text)) {
            var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
            session.insert({
              row: cursor.row + 1,
              column: 0
            }, lineIndent);
          }
          if (shouldOutdent)
            mode.autoOutdent(lineState, session, cursor.row);
        };
        this.onTextInput = function(text) {
          this.keyBinding.onTextInput(text);
        };
        this.onCommandKey = function(e, hashId, keyCode) {
          this.keyBinding.onCommandKey(e, hashId, keyCode);
        };
        this.setOverwrite = function(overwrite) {
          this.session.setOverwrite(overwrite);
        };
        this.getOverwrite = function() {
          return this.session.getOverwrite();
        };
        this.toggleOverwrite = function() {
          this.session.toggleOverwrite();
        };
        this.setScrollSpeed = function(speed) {
          this.setOption("scrollSpeed", speed);
        };
        this.getScrollSpeed = function() {
          return this.getOption("scrollSpeed");
        };
        this.setDragDelay = function(dragDelay) {
          this.setOption("dragDelay", dragDelay);
        };
        this.getDragDelay = function() {
          return this.getOption("dragDelay");
        };
        this.setSelectionStyle = function(val) {
          this.setOption("selectionStyle", val);
        };
        this.getSelectionStyle = function() {
          return this.getOption("selectionStyle");
        };
        this.setHighlightActiveLine = function(shouldHighlight) {
          this.setOption("highlightActiveLine", shouldHighlight);
        };
        this.getHighlightActiveLine = function() {
          return this.getOption("highlightActiveLine");
        };
        this.setHighlightGutterLine = function(shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        this.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        };
        this.setHighlightSelectedWord = function(shouldHighlight) {
          this.setOption("highlightSelectedWord", shouldHighlight);
        };
        this.getHighlightSelectedWord = function() {
          return this.$highlightSelectedWord;
        };
        this.setAnimatedScroll = function(shouldAnimate) {
          this.renderer.setAnimatedScroll(shouldAnimate);
        };
        this.getAnimatedScroll = function() {
          return this.renderer.getAnimatedScroll();
        };
        this.setShowInvisibles = function(showInvisibles) {
          this.renderer.setShowInvisibles(showInvisibles);
        };
        this.getShowInvisibles = function() {
          return this.renderer.getShowInvisibles();
        };
        this.setDisplayIndentGuides = function(display) {
          this.renderer.setDisplayIndentGuides(display);
        };
        this.getDisplayIndentGuides = function() {
          return this.renderer.getDisplayIndentGuides();
        };
        this.setShowPrintMargin = function(showPrintMargin) {
          this.renderer.setShowPrintMargin(showPrintMargin);
        };
        this.getShowPrintMargin = function() {
          return this.renderer.getShowPrintMargin();
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
          this.renderer.setPrintMarginColumn(showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
          return this.renderer.getPrintMarginColumn();
        };
        this.setReadOnly = function(readOnly) {
          this.setOption("readOnly", readOnly);
        };
        this.getReadOnly = function() {
          return this.getOption("readOnly");
        };
        this.setBehavioursEnabled = function(enabled) {
          this.setOption("behavioursEnabled", enabled);
        };
        this.getBehavioursEnabled = function() {
          return this.getOption("behavioursEnabled");
        };
        this.setWrapBehavioursEnabled = function(enabled) {
          this.setOption("wrapBehavioursEnabled", enabled);
        };
        this.getWrapBehavioursEnabled = function() {
          return this.getOption("wrapBehavioursEnabled");
        };
        this.setShowFoldWidgets = function(show) {
          this.setOption("showFoldWidgets", show);
        };
        this.getShowFoldWidgets = function() {
          return this.getOption("showFoldWidgets");
        };
        this.setFadeFoldWidgets = function(fade) {
          this.setOption("fadeFoldWidgets", fade);
        };
        this.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        };
        this.remove = function(dir) {
          if (this.selection.isEmpty()) {
            if (dir == "left")
              this.selection.selectLeft();
            else
              this.selection.selectRight();
          }
          var range = this.getSelectionRange();
          if (this.getBehavioursEnabled()) {
            var session = this.session;
            var state = session.getState(range.start.row);
            var new_range = session.getMode().transformAction(state, 'deletion', this, session, range);
            if (range.end.column === 0) {
              var text = session.getTextRange(range);
              if (text[text.length - 1] == "\n") {
                var line = session.getLine(range.end.row);
                if (/^\s+$/.test(line)) {
                  range.end.column = line.length;
                }
              }
            }
            if (new_range)
              range = new_range;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        this.removeWordRight = function() {
          if (this.selection.isEmpty())
            this.selection.selectWordRight();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeWordLeft = function() {
          if (this.selection.isEmpty())
            this.selection.selectWordLeft();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeToLineStart = function() {
          if (this.selection.isEmpty())
            this.selection.selectLineStart();
          this.session.remove(this.getSelectionRange());
          this.clearSelection();
        };
        this.removeToLineEnd = function() {
          if (this.selection.isEmpty())
            this.selection.selectLineEnd();
          var range = this.getSelectionRange();
          if (range.start.column == range.end.column && range.start.row == range.end.row) {
            range.end.column = 0;
            range.end.row++;
          }
          this.session.remove(range);
          this.clearSelection();
        };
        this.splitLine = function() {
          if (!this.selection.isEmpty()) {
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          }
          var cursor = this.getCursorPosition();
          this.insert("\n");
          this.moveCursorToPosition(cursor);
        };
        this.transposeLetters = function() {
          if (!this.selection.isEmpty()) {
            return;
          }
          var cursor = this.getCursorPosition();
          var column = cursor.column;
          if (column === 0)
            return;
          var line = this.session.getLine(cursor.row);
          var swap,
              range;
          if (column < line.length) {
            swap = line.charAt(column) + line.charAt(column - 1);
            range = new Range(cursor.row, column - 1, cursor.row, column + 1);
          } else {
            swap = line.charAt(column - 1) + line.charAt(column - 2);
            range = new Range(cursor.row, column - 2, cursor.row, column);
          }
          this.session.replace(range, swap);
        };
        this.toLowerCase = function() {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toLowerCase());
          this.selection.setSelectionRange(originalRange);
        };
        this.toUpperCase = function() {
          var originalRange = this.getSelectionRange();
          if (this.selection.isEmpty()) {
            this.selection.selectWord();
          }
          var range = this.getSelectionRange();
          var text = this.session.getTextRange(range);
          this.session.replace(range, text.toUpperCase());
          this.selection.setSelectionRange(originalRange);
        };
        this.indent = function() {
          var session = this.session;
          var range = this.getSelectionRange();
          if (range.start.row < range.end.row) {
            var rows = this.$getSelectedRows();
            session.indentRows(rows.first, rows.last, "\t");
            return;
          } else if (range.start.column < range.end.column) {
            var text = session.getTextRange(range);
            if (!/^\s+$/.test(text)) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "\t");
              return;
            }
          }
          var line = session.getLine(range.start.row);
          var position = range.start;
          var size = session.getTabSize();
          var column = session.documentToScreenColumn(position.row, position.column);
          if (this.session.getUseSoftTabs()) {
            var count = (size - column % size);
            var indentString = lang.stringRepeat(" ", count);
          } else {
            var count = column % size;
            while (line[range.start.column] == " " && count) {
              range.start.column--;
              count--;
            }
            this.selection.setSelectionRange(range);
            indentString = "\t";
          }
          return this.insert(indentString);
        };
        this.blockIndent = function() {
          var rows = this.$getSelectedRows();
          this.session.indentRows(rows.first, rows.last, "\t");
        };
        this.blockOutdent = function() {
          var selection = this.session.getSelection();
          this.session.outdentRows(selection.getRange());
        };
        this.sortLines = function() {
          var rows = this.$getSelectedRows();
          var session = this.session;
          var lines = [];
          for (i = rows.first; i <= rows.last; i++)
            lines.push(session.getLine(i));
          lines.sort(function(a, b) {
            if (a.toLowerCase() < b.toLowerCase())
              return -1;
            if (a.toLowerCase() > b.toLowerCase())
              return 1;
            return 0;
          });
          var deleteRange = new Range(0, 0, 0, 0);
          for (var i = rows.first; i <= rows.last; i++) {
            var line = session.getLine(i);
            deleteRange.start.row = i;
            deleteRange.end.row = i;
            deleteRange.end.column = line.length;
            session.replace(deleteRange, lines[i - rows.first]);
          }
        };
        this.toggleCommentLines = function() {
          var state = this.session.getState(this.getCursorPosition().row);
          var rows = this.$getSelectedRows();
          this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
        };
        this.toggleBlockComment = function() {
          var cursor = this.getCursorPosition();
          var state = this.session.getState(cursor.row);
          var range = this.getSelectionRange();
          this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
        };
        this.getNumberAt = function(row, column) {
          var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
          _numberRx.lastIndex = 0;
          var s = this.session.getLine(row);
          while (_numberRx.lastIndex < column) {
            var m = _numberRx.exec(s);
            if (m.index <= column && m.index + m[0].length >= column) {
              var number = {
                value: m[0],
                start: m.index,
                end: m.index + m[0].length
              };
              return number;
            }
          }
          return null;
        };
        this.modifyNumber = function(amount) {
          var row = this.selection.getCursor().row;
          var column = this.selection.getCursor().column;
          var charRange = new Range(row, column - 1, row, column);
          var c = this.session.getTextRange(charRange);
          if (!isNaN(parseFloat(c)) && isFinite(c)) {
            var nr = this.getNumberAt(row, column);
            if (nr) {
              var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
              var decimals = nr.start + nr.value.length - fp;
              var t = parseFloat(nr.value);
              t *= Math.pow(10, decimals);
              if (fp !== nr.end && column < fp) {
                amount *= Math.pow(10, nr.end - column - 1);
              } else {
                amount *= Math.pow(10, nr.end - column);
              }
              t += amount;
              t /= Math.pow(10, decimals);
              var nnr = t.toFixed(decimals);
              var replaceRange = new Range(row, nr.start, row, nr.end);
              this.session.replace(replaceRange, nnr);
              this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
            }
          }
        };
        this.removeLines = function() {
          var rows = this.$getSelectedRows();
          this.session.removeFullLines(rows.first, rows.last);
          this.clearSelection();
        };
        this.duplicateSelection = function() {
          var sel = this.selection;
          var doc = this.session;
          var range = sel.getRange();
          var reverse = sel.isBackwards();
          if (range.isEmpty()) {
            var row = range.start.row;
            doc.duplicateLines(row, row);
          } else {
            var point = reverse ? range.start : range.end;
            var endPoint = doc.insert(point, doc.getTextRange(range), false);
            range.start = point;
            range.end = endPoint;
            sel.setSelectionRange(range, reverse);
          }
        };
        this.moveLinesDown = function() {
          this.$moveLines(1, false);
        };
        this.moveLinesUp = function() {
          this.$moveLines(-1, false);
        };
        this.moveText = function(range, toPosition, copy) {
          return this.session.moveText(range, toPosition, copy);
        };
        this.copyLinesUp = function() {
          this.$moveLines(-1, true);
        };
        this.copyLinesDown = function() {
          this.$moveLines(1, true);
        };
        this.$moveLines = function(dir, copy) {
          var rows,
              moved;
          var selection = this.selection;
          if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
            var range = selection.toOrientedRange();
            rows = this.$getSelectedRows(range);
            moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
            if (copy && dir == -1)
              moved = 0;
            range.moveBy(moved, 0);
            selection.fromOrientedRange(range);
          } else {
            var ranges = selection.rangeList.ranges;
            selection.rangeList.detach(this.session);
            this.inVirtualSelectionMode = true;
            var diff = 0;
            var totalDiff = 0;
            var l = ranges.length;
            for (var i = 0; i < l; i++) {
              var rangeIndex = i;
              ranges[i].moveBy(diff, 0);
              rows = this.$getSelectedRows(ranges[i]);
              var first = rows.first;
              var last = rows.last;
              while (++i < l) {
                if (totalDiff)
                  ranges[i].moveBy(totalDiff, 0);
                var subRows = this.$getSelectedRows(ranges[i]);
                if (copy && subRows.first != last)
                  break;
                else if (!copy && subRows.first > last + 1)
                  break;
                last = subRows.last;
              }
              i--;
              diff = this.session.$moveLines(first, last, copy ? 0 : dir);
              if (copy && dir == -1)
                rangeIndex = i + 1;
              while (rangeIndex <= i) {
                ranges[rangeIndex].moveBy(diff, 0);
                rangeIndex++;
              }
              if (!copy)
                diff = 0;
              totalDiff += diff;
            }
            selection.fromOrientedRange(selection.ranges[0]);
            selection.rangeList.attach(this.session);
            this.inVirtualSelectionMode = false;
          }
        };
        this.$getSelectedRows = function(range) {
          range = (range || this.getSelectionRange()).collapseRows();
          return {
            first: this.session.getRowFoldStart(range.start.row),
            last: this.session.getRowFoldEnd(range.end.row)
          };
        };
        this.onCompositionStart = function(text) {
          this.renderer.showComposition(this.getCursorPosition());
        };
        this.onCompositionUpdate = function(text) {
          this.renderer.setCompositionText(text);
        };
        this.onCompositionEnd = function() {
          this.renderer.hideComposition();
        };
        this.getFirstVisibleRow = function() {
          return this.renderer.getFirstVisibleRow();
        };
        this.getLastVisibleRow = function() {
          return this.renderer.getLastVisibleRow();
        };
        this.isRowVisible = function(row) {
          return (row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow());
        };
        this.isRowFullyVisible = function(row) {
          return (row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow());
        };
        this.$getVisibleRowCount = function() {
          return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        };
        this.$moveByPage = function(dir, select) {
          var renderer = this.renderer;
          var config = this.renderer.layerConfig;
          var rows = dir * Math.floor(config.height / config.lineHeight);
          this.$blockScrolling++;
          if (select === true) {
            this.selection.$moveSelection(function() {
              this.moveCursorBy(rows, 0);
            });
          } else if (select === false) {
            this.selection.moveCursorBy(rows, 0);
            this.selection.clearSelection();
          }
          this.$blockScrolling--;
          var scrollTop = renderer.scrollTop;
          renderer.scrollBy(0, rows * config.lineHeight);
          if (select != null)
            renderer.scrollCursorIntoView(null, 0.5);
          renderer.animateScrolling(scrollTop);
        };
        this.selectPageDown = function() {
          this.$moveByPage(1, true);
        };
        this.selectPageUp = function() {
          this.$moveByPage(-1, true);
        };
        this.gotoPageDown = function() {
          this.$moveByPage(1, false);
        };
        this.gotoPageUp = function() {
          this.$moveByPage(-1, false);
        };
        this.scrollPageDown = function() {
          this.$moveByPage(1);
        };
        this.scrollPageUp = function() {
          this.$moveByPage(-1);
        };
        this.scrollToRow = function(row) {
          this.renderer.scrollToRow(row);
        };
        this.scrollToLine = function(line, center, animate, callback) {
          this.renderer.scrollToLine(line, center, animate, callback);
        };
        this.centerSelection = function() {
          var range = this.getSelectionRange();
          var pos = {
            row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
            column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
          };
          this.renderer.alignCursor(pos, 0.5);
        };
        this.getCursorPosition = function() {
          return this.selection.getCursor();
        };
        this.getCursorPositionScreen = function() {
          return this.session.documentToScreenPosition(this.getCursorPosition());
        };
        this.getSelectionRange = function() {
          return this.selection.getRange();
        };
        this.selectAll = function() {
          this.$blockScrolling += 1;
          this.selection.selectAll();
          this.$blockScrolling -= 1;
        };
        this.clearSelection = function() {
          this.selection.clearSelection();
        };
        this.moveCursorTo = function(row, column) {
          this.selection.moveCursorTo(row, column);
        };
        this.moveCursorToPosition = function(pos) {
          this.selection.moveCursorToPosition(pos);
        };
        this.jumpToMatching = function(select, expand) {
          var cursor = this.getCursorPosition();
          var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
          var prevToken = iterator.getCurrentToken();
          var token = prevToken || iterator.stepForward();
          if (!token)
            return;
          var matchType;
          var found = false;
          var depth = {};
          var i = cursor.column - token.start;
          var bracketType;
          var brackets = {
            ")": "(",
            "(": "(",
            "]": "[",
            "[": "[",
            "{": "{",
            "}": "{"
          };
          do {
            if (token.value.match(/[{}()\[\]]/g)) {
              for (; i < token.value.length && !found; i++) {
                if (!brackets[token.value[i]]) {
                  continue;
                }
                bracketType = brackets[token.value[i]] + '.' + token.type.replace("rparen", "lparen");
                if (isNaN(depth[bracketType])) {
                  depth[bracketType] = 0;
                }
                switch (token.value[i]) {
                  case '(':
                  case '[':
                  case '{':
                    depth[bracketType]++;
                    break;
                  case ')':
                  case ']':
                  case '}':
                    depth[bracketType]--;
                    if (depth[bracketType] === -1) {
                      matchType = 'bracket';
                      found = true;
                    }
                    break;
                }
              }
            } else if (token && token.type.indexOf('tag-name') !== -1) {
              if (isNaN(depth[token.value])) {
                depth[token.value] = 0;
              }
              if (prevToken.value === '<') {
                depth[token.value]++;
              } else if (prevToken.value === '</') {
                depth[token.value]--;
              }
              if (depth[token.value] === -1) {
                matchType = 'tag';
                found = true;
              }
            }
            if (!found) {
              prevToken = token;
              token = iterator.stepForward();
              i = 0;
            }
          } while (token && !found);
          if (!matchType)
            return;
          var range,
              pos;
          if (matchType === 'bracket') {
            range = this.session.getBracketRange(cursor);
            if (!range) {
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
              pos = range.start;
              if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                range = this.session.getBracketRange(pos);
            }
          } else if (matchType === 'tag') {
            if (token && token.type.indexOf('tag-name') !== -1)
              var tag = token.value;
            else
              return;
            range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
            if (range.compare(cursor.row, cursor.column) === 0) {
              found = false;
              do {
                token = prevToken;
                prevToken = iterator.stepBackward();
                if (prevToken) {
                  if (prevToken.type.indexOf('tag-close') !== -1) {
                    range.setEnd(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                  }
                  if (token.value === tag && token.type.indexOf('tag-name') !== -1) {
                    if (prevToken.value === '<') {
                      depth[tag]++;
                    } else if (prevToken.value === '</') {
                      depth[tag]--;
                    }
                    if (depth[tag] === 0)
                      found = true;
                  }
                }
              } while (prevToken && !found);
            }
            if (token && token.type.indexOf('tag-name')) {
              pos = range.start;
              if (pos.row == cursor.row && Math.abs(pos.column - cursor.column) < 2)
                pos = range.end;
            }
          }
          pos = range && range.cursor || pos;
          if (pos) {
            if (select) {
              if (range && expand) {
                this.selection.setRange(range);
              } else if (range && range.isEqual(this.getSelectionRange())) {
                this.clearSelection();
              } else {
                this.selection.selectTo(pos.row, pos.column);
              }
            } else {
              this.selection.moveTo(pos.row, pos.column);
            }
          }
        };
        this.gotoLine = function(lineNumber, column, animate) {
          this.selection.clearSelection();
          this.session.unfold({
            row: lineNumber - 1,
            column: column || 0
          });
          this.$blockScrolling += 1;
          this.exitMultiSelectMode && this.exitMultiSelectMode();
          this.moveCursorTo(lineNumber - 1, column || 0);
          this.$blockScrolling -= 1;
          if (!this.isRowFullyVisible(lineNumber - 1))
            this.scrollToLine(lineNumber - 1, true, animate);
        };
        this.navigateTo = function(row, column) {
          this.selection.moveTo(row, column);
        };
        this.navigateUp = function(times) {
          if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var selectionStart = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionStart);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(-times || -1, 0);
        };
        this.navigateDown = function(times) {
          if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var selectionEnd = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(selectionEnd);
          }
          this.selection.clearSelection();
          this.selection.moveCursorBy(times || 1, 0);
        };
        this.navigateLeft = function(times) {
          if (!this.selection.isEmpty()) {
            var selectionStart = this.getSelectionRange().start;
            this.moveCursorToPosition(selectionStart);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorLeft();
            }
          }
          this.clearSelection();
        };
        this.navigateRight = function(times) {
          if (!this.selection.isEmpty()) {
            var selectionEnd = this.getSelectionRange().end;
            this.moveCursorToPosition(selectionEnd);
          } else {
            times = times || 1;
            while (times--) {
              this.selection.moveCursorRight();
            }
          }
          this.clearSelection();
        };
        this.navigateLineStart = function() {
          this.selection.moveCursorLineStart();
          this.clearSelection();
        };
        this.navigateLineEnd = function() {
          this.selection.moveCursorLineEnd();
          this.clearSelection();
        };
        this.navigateFileEnd = function() {
          this.selection.moveCursorFileEnd();
          this.clearSelection();
        };
        this.navigateFileStart = function() {
          this.selection.moveCursorFileStart();
          this.clearSelection();
        };
        this.navigateWordRight = function() {
          this.selection.moveCursorWordRight();
          this.clearSelection();
        };
        this.navigateWordLeft = function() {
          this.selection.moveCursorWordLeft();
          this.clearSelection();
        };
        this.replace = function(replacement, options) {
          if (options)
            this.$search.set(options);
          var range = this.$search.find(this.session);
          var replaced = 0;
          if (!range)
            return replaced;
          if (this.$tryReplace(range, replacement)) {
            replaced = 1;
          }
          if (range !== null) {
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
          }
          return replaced;
        };
        this.replaceAll = function(replacement, options) {
          if (options) {
            this.$search.set(options);
          }
          var ranges = this.$search.findAll(this.session);
          var replaced = 0;
          if (!ranges.length)
            return replaced;
          this.$blockScrolling += 1;
          var selection = this.getSelectionRange();
          this.selection.moveTo(0, 0);
          for (var i = ranges.length - 1; i >= 0; --i) {
            if (this.$tryReplace(ranges[i], replacement)) {
              replaced++;
            }
          }
          this.selection.setSelectionRange(selection);
          this.$blockScrolling -= 1;
          return replaced;
        };
        this.$tryReplace = function(range, replacement) {
          var input = this.session.getTextRange(range);
          replacement = this.$search.replace(input, replacement);
          if (replacement !== null) {
            range.end = this.session.replace(range, replacement);
            return range;
          } else {
            return null;
          }
        };
        this.getLastSearchOptions = function() {
          return this.$search.getOptions();
        };
        this.find = function(needle, options, animate) {
          if (!options)
            options = {};
          if (typeof needle == "string" || needle instanceof RegExp)
            options.needle = needle;
          else if (typeof needle == "object")
            oop.mixin(options, needle);
          var range = this.selection.getRange();
          if (options.needle == null) {
            needle = this.session.getTextRange(range) || this.$search.$options.needle;
            if (!needle) {
              range = this.session.getWordRange(range.start.row, range.start.column);
              needle = this.session.getTextRange(range);
            }
            this.$search.set({needle: needle});
          }
          this.$search.set(options);
          if (!options.start)
            this.$search.set({start: range});
          var newRange = this.$search.find(this.session);
          if (options.preventScroll)
            return newRange;
          if (newRange) {
            this.revealRange(newRange, animate);
            return newRange;
          }
          if (options.backwards)
            range.start = range.end;
          else
            range.end = range.start;
          this.selection.setRange(range);
        };
        this.findNext = function(options, animate) {
          this.find({
            skipCurrent: true,
            backwards: false
          }, options, animate);
        };
        this.findPrevious = function(options, animate) {
          this.find(options, {
            skipCurrent: true,
            backwards: true
          }, animate);
        };
        this.revealRange = function(range, animate) {
          this.$blockScrolling += 1;
          this.session.unfold(range);
          this.selection.setSelectionRange(range);
          this.$blockScrolling -= 1;
          var scrollTop = this.renderer.scrollTop;
          this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
          if (animate !== false)
            this.renderer.animateScrolling(scrollTop);
        };
        this.undo = function() {
          this.$blockScrolling++;
          this.session.getUndoManager().undo();
          this.$blockScrolling--;
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.redo = function() {
          this.$blockScrolling++;
          this.session.getUndoManager().redo();
          this.$blockScrolling--;
          this.renderer.scrollCursorIntoView(null, 0.5);
        };
        this.destroy = function() {
          this.renderer.destroy();
          this._signal("destroy", this);
          if (this.session) {
            this.session.destroy();
          }
        };
        this.setAutoScrollEditorIntoView = function(enable) {
          if (!enable)
            return;
          var rect;
          var self = this;
          var shouldScroll = false;
          if (!this.$scrollAnchor)
            this.$scrollAnchor = document.createElement("div");
          var scrollAnchor = this.$scrollAnchor;
          scrollAnchor.style.cssText = "position:absolute";
          this.container.insertBefore(scrollAnchor, this.container.firstChild);
          var onChangeSelection = this.on("changeSelection", function() {
            shouldScroll = true;
          });
          var onBeforeRender = this.renderer.on("beforeRender", function() {
            if (shouldScroll)
              rect = self.renderer.container.getBoundingClientRect();
          });
          var onAfterRender = this.renderer.on("afterRender", function() {
            if (shouldScroll && rect && (self.isFocused() || self.searchBox && self.searchBox.isFocused())) {
              var renderer = self.renderer;
              var pos = renderer.$cursorLayer.$pixelPos;
              var config = renderer.layerConfig;
              var top = pos.top - config.offset;
              if (pos.top >= 0 && top + rect.top < 0) {
                shouldScroll = true;
              } else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) {
                shouldScroll = false;
              } else {
                shouldScroll = null;
              }
              if (shouldScroll != null) {
                scrollAnchor.style.top = top + "px";
                scrollAnchor.style.left = pos.left + "px";
                scrollAnchor.style.height = config.lineHeight + "px";
                scrollAnchor.scrollIntoView(shouldScroll);
              }
              shouldScroll = rect = null;
            }
          });
          this.setAutoScrollEditorIntoView = function(enable) {
            if (enable)
              return;
            delete this.setAutoScrollEditorIntoView;
            this.off("changeSelection", onChangeSelection);
            this.renderer.off("afterRender", onAfterRender);
            this.renderer.off("beforeRender", onBeforeRender);
          };
        };
        this.$resetCursorStyle = function() {
          var style = this.$cursorStyle || "ace";
          var cursorLayer = this.renderer.$cursorLayer;
          if (!cursorLayer)
            return;
          cursorLayer.setSmoothBlinking(/smooth/.test(style));
          cursorLayer.isBlinking = !this.$readOnly && style != "wide";
          dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
        };
      }).call(Editor.prototype);
      config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", {data: style});
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function(readOnly) {
            this.$resetCursorStyle();
          },
          initialValue: false
        },
        cursorStyle: {
          set: function(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: {initialValue: true},
        wrapBehavioursEnabled: {initialValue: true},
        autoScrollEditorIntoView: {set: function(val) {
            this.setAutoScrollEditorIntoView(val);
          }},
        keyboardHandler: {
          set: function(val) {
            this.setKeyboardHandler(val);
          },
          get: function() {
            return this.keybindingId;
          },
          handlesSet: true
        },
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        showLineNumbers: "renderer",
        showGutter: "renderer",
        displayIndentGuides: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      exports.Editor = Editor;
    });
    ace.define("ace/undomanager", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var UndoManager = function() {
        this.reset();
      };
      (function() {
        this.execute = function(options) {
          var deltaSets = options.args[0];
          this.$doc = options.args[1];
          if (options.merge && this.hasUndo()) {
            this.dirtyCounter--;
            deltaSets = this.$undoStack.pop().concat(deltaSets);
          }
          this.$undoStack.push(deltaSets);
          this.$redoStack = [];
          if (this.dirtyCounter < 0) {
            this.dirtyCounter = NaN;
          }
          this.dirtyCounter++;
        };
        this.undo = function(dontSelect) {
          var deltaSets = this.$undoStack.pop();
          var undoSelectionRange = null;
          if (deltaSets) {
            undoSelectionRange = this.$doc.undoChanges(deltaSets, dontSelect);
            this.$redoStack.push(deltaSets);
            this.dirtyCounter--;
          }
          return undoSelectionRange;
        };
        this.redo = function(dontSelect) {
          var deltaSets = this.$redoStack.pop();
          var redoSelectionRange = null;
          if (deltaSets) {
            redoSelectionRange = this.$doc.redoChanges(this.$deserializeDeltas(deltaSets), dontSelect);
            this.$undoStack.push(deltaSets);
            this.dirtyCounter++;
          }
          return redoSelectionRange;
        };
        this.reset = function() {
          this.$undoStack = [];
          this.$redoStack = [];
          this.dirtyCounter = 0;
        };
        this.hasUndo = function() {
          return this.$undoStack.length > 0;
        };
        this.hasRedo = function() {
          return this.$redoStack.length > 0;
        };
        this.markClean = function() {
          this.dirtyCounter = 0;
        };
        this.isClean = function() {
          return this.dirtyCounter === 0;
        };
        this.$serializeDeltas = function(deltaSets) {
          return cloneDeltaSetsObj(deltaSets, $serializeDelta);
        };
        this.$deserializeDeltas = function(deltaSets) {
          return cloneDeltaSetsObj(deltaSets, $deserializeDelta);
        };
        function $serializeDelta(delta) {
          return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines.length == 1 ? null : delta.lines,
            text: delta.lines.length == 1 ? delta.lines[0] : null
          };
        }
        function $deserializeDelta(delta) {
          return {
            action: delta.action,
            start: delta.start,
            end: delta.end,
            lines: delta.lines || [delta.text]
          };
        }
        function cloneDeltaSetsObj(deltaSets_old, fnGetModifiedDelta) {
          var deltaSets_new = new Array(deltaSets_old.length);
          for (var i = 0; i < deltaSets_old.length; i++) {
            var deltaSet_old = deltaSets_old[i];
            var deltaSet_new = {
              group: deltaSet_old.group,
              deltas: new Array(deltaSet_old.length)
            };
            for (var j = 0; j < deltaSet_old.deltas.length; j++) {
              var delta_old = deltaSet_old.deltas[j];
              deltaSet_new.deltas[j] = fnGetModifiedDelta(delta_old);
            }
            deltaSets_new[i] = deltaSet_new;
          }
          return deltaSets_new;
        }
      }).call(UndoManager.prototype);
      exports.UndoManager = UndoManager;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter"], function(require, exports, module) {
      "use strict";
      var dom = require("../lib/dom");
      var oop = require("../lib/oop");
      var lang = require("../lib/lang");
      var EventEmitter = require("../lib/event_emitter").EventEmitter;
      var Gutter = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_gutter-layer";
        parentEl.appendChild(this.element);
        this.setShowFoldWidgets(this.$showFoldWidgets);
        this.gutterWidth = 0;
        this.$annotations = [];
        this.$updateAnnotations = this.$updateAnnotations.bind(this);
        this.$cells = [];
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setSession = function(session) {
          if (this.session)
            this.session.removeEventListener("change", this.$updateAnnotations);
          this.session = session;
          if (session)
            session.on("change", this.$updateAnnotations);
        };
        this.addGutterDecoration = function(row, className) {
          if (window.console)
            console.warn && console.warn("deprecated use session.addGutterDecoration");
          this.session.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function(row, className) {
          if (window.console)
            console.warn && console.warn("deprecated use session.removeGutterDecoration");
          this.session.removeGutterDecoration(row, className);
        };
        this.setAnnotations = function(annotations) {
          this.$annotations = [];
          for (var i = 0; i < annotations.length; i++) {
            var annotation = annotations[i];
            var row = annotation.row;
            var rowInfo = this.$annotations[row];
            if (!rowInfo)
              rowInfo = this.$annotations[row] = {text: []};
            var annoText = annotation.text;
            annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
            if (rowInfo.text.indexOf(annoText) === -1)
              rowInfo.text.push(annoText);
            var type = annotation.type;
            if (type == "error")
              rowInfo.className = " ace_error";
            else if (type == "warning" && rowInfo.className != " ace_error")
              rowInfo.className = " ace_warning";
            else if (type == "info" && (!rowInfo.className))
              rowInfo.className = " ace_info";
          }
        };
        this.$updateAnnotations = function(delta) {
          if (!this.$annotations.length)
            return;
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {} else if (delta.action == 'remove') {
            this.$annotations.splice(firstRow, len + 1, null);
          } else {
            var args = new Array(len + 1);
            args.unshift(firstRow, 1);
            this.$annotations.splice.apply(this.$annotations, args);
          }
        };
        this.update = function(config) {
          var session = this.session;
          var firstRow = config.firstRow;
          var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
          var fold = session.getNextFoldLine(firstRow);
          var foldStart = fold ? fold.start.row : Infinity;
          var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
          var breakpoints = session.$breakpoints;
          var decorations = session.$decorations;
          var firstLineNumber = session.$firstLineNumber;
          var lastLineNumber = 0;
          var gutterRenderer = session.gutterRenderer || this.$renderer;
          var cell = null;
          var index = -1;
          var row = firstRow;
          while (true) {
            if (row > foldStart) {
              row = fold.end.row + 1;
              fold = session.getNextFoldLine(row, fold);
              foldStart = fold ? fold.start.row : Infinity;
            }
            if (row > lastRow) {
              while (this.$cells.length > index + 1) {
                cell = this.$cells.pop();
                this.element.removeChild(cell.element);
              }
              break;
            }
            cell = this.$cells[++index];
            if (!cell) {
              cell = {
                element: null,
                textNode: null,
                foldWidget: null
              };
              cell.element = dom.createElement("div");
              cell.textNode = document.createTextNode('');
              cell.element.appendChild(cell.textNode);
              this.element.appendChild(cell.element);
              this.$cells[index] = cell;
            }
            var className = "ace_gutter-cell ";
            if (breakpoints[row])
              className += breakpoints[row];
            if (decorations[row])
              className += decorations[row];
            if (this.$annotations[row])
              className += this.$annotations[row].className;
            if (cell.element.className != className)
              cell.element.className = className;
            var height = session.getRowLength(row) * config.lineHeight + "px";
            if (height != cell.element.style.height)
              cell.element.style.height = height;
            if (foldWidgets) {
              var c = foldWidgets[row];
              if (c == null)
                c = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c) {
              if (!cell.foldWidget) {
                cell.foldWidget = dom.createElement("span");
                cell.element.appendChild(cell.foldWidget);
              }
              var className = "ace_fold-widget ace_" + c;
              if (c == "start" && row == foldStart && row < fold.end.row)
                className += " ace_closed";
              else
                className += " ace_open";
              if (cell.foldWidget.className != className)
                cell.foldWidget.className = className;
              var height = config.lineHeight + "px";
              if (cell.foldWidget.style.height != height)
                cell.foldWidget.style.height = height;
            } else {
              if (cell.foldWidget) {
                cell.element.removeChild(cell.foldWidget);
                cell.foldWidget = null;
              }
            }
            var text = lastLineNumber = gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber;
            if (text != cell.textNode.data)
              cell.textNode.data = text;
            row++;
          }
          this.element.style.height = config.minHeight + "px";
          if (this.$fixedWidth || session.$useWrapMode)
            lastLineNumber = session.getLength() + firstLineNumber;
          var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineNumber, config) : lastLineNumber.toString().length * config.characterWidth;
          var padding = this.$padding || this.$computePadding();
          gutterWidth += padding.left + padding.right;
          if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
            this.gutterWidth = gutterWidth;
            this.element.style.width = Math.ceil(this.gutterWidth) + "px";
            this._emit("changeGutterWidth", gutterWidth);
          }
        };
        this.$fixedWidth = false;
        this.$showLineNumbers = true;
        this.$renderer = "";
        this.setShowLineNumbers = function(show) {
          this.$renderer = !show && {
            getWidth: function() {
              return "";
            },
            getText: function() {
              return "";
            }
          };
        };
        this.getShowLineNumbers = function() {
          return this.$showLineNumbers;
        };
        this.$showFoldWidgets = true;
        this.setShowFoldWidgets = function(show) {
          if (show)
            dom.addCssClass(this.element, "ace_folding-enabled");
          else
            dom.removeCssClass(this.element, "ace_folding-enabled");
          this.$showFoldWidgets = show;
          this.$padding = null;
        };
        this.getShowFoldWidgets = function() {
          return this.$showFoldWidgets;
        };
        this.$computePadding = function() {
          if (!this.element.firstChild)
            return {
              left: 0,
              right: 0
            };
          var style = dom.computedStyle(this.element.firstChild);
          this.$padding = {};
          this.$padding.left = parseInt(style.paddingLeft) + 1 || 0;
          this.$padding.right = parseInt(style.paddingRight) || 0;
          return this.$padding;
        };
        this.getRegion = function(point) {
          var padding = this.$padding || this.$computePadding();
          var rect = this.element.getBoundingClientRect();
          if (point.x < padding.left + rect.left)
            return "markers";
          if (this.$showFoldWidgets && point.x > rect.right - padding.right)
            return "foldWidgets";
        };
      }).call(Gutter.prototype);
      exports.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require, exports, module) {
      "use strict";
      var Range = require("../range").Range;
      var dom = require("../lib/dom");
      var Marker = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_marker-layer";
        parentEl.appendChild(this.element);
      };
      (function() {
        this.$padding = 0;
        this.setPadding = function(padding) {
          this.$padding = padding;
        };
        this.setSession = function(session) {
          this.session = session;
        };
        this.setMarkers = function(markers) {
          this.markers = markers;
        };
        this.update = function(config) {
          var config = config || this.config;
          if (!config)
            return;
          this.config = config;
          var html = [];
          for (var key in this.markers) {
            var marker = this.markers[key];
            if (!marker.range) {
              marker.update(html, this, this.session, config);
              continue;
            }
            var range = marker.range.clipRows(config.firstRow, config.lastRow);
            if (range.isEmpty())
              continue;
            range = range.toScreenRange(this.session);
            if (marker.renderer) {
              var top = this.$getTop(range.start.row, config);
              var left = this.$padding + range.start.column * config.characterWidth;
              marker.renderer(html, range, left, top, config);
            } else if (marker.type == "fullLine") {
              this.drawFullLineMarker(html, range, marker.clazz, config);
            } else if (marker.type == "screenLine") {
              this.drawScreenLineMarker(html, range, marker.clazz, config);
            } else if (range.isMultiLine()) {
              if (marker.type == "text")
                this.drawTextMarker(html, range, marker.clazz, config);
              else
                this.drawMultiLineMarker(html, range, marker.clazz, config);
            } else {
              this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
          }
          this.element.innerHTML = html.join("");
        };
        this.$getTop = function(row, layerConfig) {
          return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
        };
        function getBorderClass(tl, tr, br, bl) {
          return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
        }
        this.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
          var session = this.session;
          var start = range.start.row;
          var end = range.end.row;
          var row = start;
          var prev = 0;
          var curr = 0;
          var next = session.getScreenLastRowColumn(row);
          var lineRange = new Range(row, range.start.column, row, curr);
          for (; row <= end; row++) {
            lineRange.start.row = lineRange.end.row = row;
            lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
            lineRange.end.column = next;
            prev = curr;
            curr = next;
            next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
            this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
          }
        };
        this.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var padding = this.$padding;
          var height = config.lineHeight;
          var top = this.$getTop(range.start.row, config);
          var left = padding + range.start.column * config.characterWidth;
          extraStyle = extraStyle || "";
          stringBuilder.push("<div class='", clazz, " ace_br1 ace_start' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", left, "px;", extraStyle, "'></div>");
          top = this.$getTop(range.end.row, config);
          var width = range.end.column * config.characterWidth;
          stringBuilder.push("<div class='", clazz, " ace_br12' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
          height = (range.end.row - range.start.row - 1) * config.lineHeight;
          if (height <= 0)
            return;
          top = this.$getTop(range.start.row + 1, config);
          var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
          stringBuilder.push("<div class='", clazz, (radiusClass ? " ace_br" + radiusClass : ""), "' style='", "height:", height, "px;", "right:0;", "top:", top, "px;", "left:", padding, "px;", extraStyle, "'></div>");
        };
        this.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
          var height = config.lineHeight;
          var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
          var top = this.$getTop(range.start.row, config);
          var left = this.$padding + range.start.column * config.characterWidth;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "width:", width, "px;", "top:", top, "px;", "left:", left, "px;", extraStyle || "", "'></div>");
        };
        this.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          if (range.start.row != range.end.row)
            height += this.$getTop(range.end.row, config) - top;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
        };
        this.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
          var top = this.$getTop(range.start.row, config);
          var height = config.lineHeight;
          stringBuilder.push("<div class='", clazz, "' style='", "height:", height, "px;", "top:", top, "px;", "left:0;right:0;", extraStyle || "", "'></div>");
        };
      }).call(Marker.prototype);
      exports.Marker = Marker;
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function(require, exports, module) {
      "use strict";
      var oop = require("../lib/oop");
      var dom = require("../lib/dom");
      var lang = require("../lib/lang");
      var useragent = require("../lib/useragent");
      var EventEmitter = require("../lib/event_emitter").EventEmitter;
      var Text = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_text-layer";
        parentEl.appendChild(this.element);
        this.$updateEolChar = this.$updateEolChar.bind(this);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.EOF_CHAR = "\xB6";
        this.EOL_CHAR_LF = "\xAC";
        this.EOL_CHAR_CRLF = "\xa4";
        this.EOL_CHAR = this.EOL_CHAR_LF;
        this.TAB_CHAR = "\u2014";
        this.SPACE_CHAR = "\xB7";
        this.$padding = 0;
        this.$updateEolChar = function() {
          var EOL_CHAR = this.session.doc.getNewLineCharacter() == "\n" ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
          if (this.EOL_CHAR != EOL_CHAR) {
            this.EOL_CHAR = EOL_CHAR;
            return true;
          }
        };
        this.setPadding = function(padding) {
          this.$padding = padding;
          this.element.style.padding = "0 " + padding + "px";
        };
        this.getLineHeight = function() {
          return this.$fontMetrics.$characterSize.height || 0;
        };
        this.getCharacterWidth = function() {
          return this.$fontMetrics.$characterSize.width || 0;
        };
        this.$setFontMetrics = function(measure) {
          this.$fontMetrics = measure;
          this.$fontMetrics.on("changeCharacterSize", function(e) {
            this._signal("changeCharacterSize", e);
          }.bind(this));
          this.$pollSizeChanges();
        };
        this.checkForSizeChanges = function() {
          this.$fontMetrics.checkForSizeChanges();
        };
        this.$pollSizeChanges = function() {
          return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        };
        this.setSession = function(session) {
          this.session = session;
          if (session)
            this.$computeTabString();
        };
        this.showInvisibles = false;
        this.setShowInvisibles = function(showInvisibles) {
          if (this.showInvisibles == showInvisibles)
            return false;
          this.showInvisibles = showInvisibles;
          this.$computeTabString();
          return true;
        };
        this.displayIndentGuides = true;
        this.setDisplayIndentGuides = function(display) {
          if (this.displayIndentGuides == display)
            return false;
          this.displayIndentGuides = display;
          this.$computeTabString();
          return true;
        };
        this.$tabStrings = [];
        this.onChangeTabSize = this.$computeTabString = function() {
          var tabSize = this.session.getTabSize();
          this.tabSize = tabSize;
          var tabStr = this.$tabStrings = [0];
          for (var i = 1; i < tabSize + 1; i++) {
            if (this.showInvisibles) {
              tabStr.push("<span class='ace_invisible ace_invisible_tab'>" + lang.stringRepeat(this.TAB_CHAR, i) + "</span>");
            } else {
              tabStr.push(lang.stringRepeat(" ", i));
            }
          }
          if (this.displayIndentGuides) {
            this.$indentGuideRe = /\s\S| \t|\t |\s$/;
            var className = "ace_indent-guide";
            var spaceClass = "";
            var tabClass = "";
            if (this.showInvisibles) {
              className += " ace_invisible";
              spaceClass = " ace_invisible_space";
              tabClass = " ace_invisible_tab";
              var spaceContent = lang.stringRepeat(this.SPACE_CHAR, this.tabSize);
              var tabContent = lang.stringRepeat(this.TAB_CHAR, this.tabSize);
            } else {
              var spaceContent = lang.stringRepeat(" ", this.tabSize);
              var tabContent = spaceContent;
            }
            this.$tabStrings[" "] = "<span class='" + className + spaceClass + "'>" + spaceContent + "</span>";
            this.$tabStrings["\t"] = "<span class='" + className + tabClass + "'>" + tabContent + "</span>";
          }
        };
        this.updateLines = function(config, firstRow, lastRow) {
          if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
            this.scrollLines(config);
          }
          this.config = config;
          var first = Math.max(firstRow, config.firstRow);
          var last = Math.min(lastRow, config.lastRow);
          var lineElements = this.element.childNodes;
          var lineElementsIdx = 0;
          for (var row = config.firstRow; row < first; row++) {
            var foldLine = this.session.getFoldLine(row);
            if (foldLine) {
              if (foldLine.containsRow(first)) {
                first = foldLine.start.row;
                break;
              } else {
                row = foldLine.end.row;
              }
            }
            lineElementsIdx++;
          }
          var row = first;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > last)
              break;
            var lineElement = lineElements[lineElementsIdx++];
            if (lineElement) {
              var html = [];
              this.$renderLine(html, row, !this.$useLineGroups(), row == foldStart ? foldLine : false);
              lineElement.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
              lineElement.innerHTML = html.join("");
            }
            row++;
          }
        };
        this.scrollLines = function(config) {
          var oldConfig = this.config;
          this.config = config;
          if (!oldConfig || oldConfig.lastRow < config.firstRow)
            return this.update(config);
          if (config.lastRow < oldConfig.firstRow)
            return this.update(config);
          var el = this.element;
          if (oldConfig.firstRow < config.firstRow)
            for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
              el.removeChild(el.firstChild);
          if (oldConfig.lastRow > config.lastRow)
            for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
              el.removeChild(el.lastChild);
          if (config.firstRow < oldConfig.firstRow) {
            var fragment = this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1);
            if (el.firstChild)
              el.insertBefore(fragment, el.firstChild);
            else
              el.appendChild(fragment);
          }
          if (config.lastRow > oldConfig.lastRow) {
            var fragment = this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow);
            el.appendChild(fragment);
          }
        };
        this.$renderLinesFragment = function(config, firstRow, lastRow) {
          var fragment = this.element.ownerDocument.createDocumentFragment();
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
              break;
            var container = dom.createElement("div");
            var html = [];
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            container.innerHTML = html.join("");
            if (this.$useLineGroups()) {
              container.className = 'ace_line_group';
              fragment.appendChild(container);
              container.style.height = config.lineHeight * this.session.getRowLength(row) + "px";
            } else {
              while (container.firstChild)
                fragment.appendChild(container.firstChild);
            }
            row++;
          }
          return fragment;
        };
        this.update = function(config) {
          this.config = config;
          var html = [];
          var firstRow = config.firstRow,
              lastRow = config.lastRow;
          var row = firstRow;
          var foldLine = this.session.getNextFoldLine(row);
          var foldStart = foldLine ? foldLine.start.row : Infinity;
          while (true) {
            if (row > foldStart) {
              row = foldLine.end.row + 1;
              foldLine = this.session.getNextFoldLine(row, foldLine);
              foldStart = foldLine ? foldLine.start.row : Infinity;
            }
            if (row > lastRow)
              break;
            if (this.$useLineGroups())
              html.push("<div class='ace_line_group' style='height:", config.lineHeight * this.session.getRowLength(row), "px'>");
            this.$renderLine(html, row, false, row == foldStart ? foldLine : false);
            if (this.$useLineGroups())
              html.push("</div>");
            row++;
          }
          this.element.innerHTML = html.join("");
        };
        this.$textToken = {
          "text": true,
          "rparen": true,
          "lparen": true
        };
        this.$renderToken = function(stringBuilder, screenColumn, token, value) {
          var self = this;
          var replaceReg = /\t|&|<|>|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\u3000\uFEFF\uFFF9-\uFFFC])|[\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3000-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]/g;
          var replaceFunc = function(c, a, b, tabIdx, idx4) {
            if (a) {
              return self.showInvisibles ? "<span class='ace_invisible ace_invisible_space'>" + lang.stringRepeat(self.SPACE_CHAR, c.length) + "</span>" : c;
            } else if (c == "&") {
              return "&#38;";
            } else if (c == "<") {
              return "&#60;";
            } else if (c == ">") {
              return "&#62;";
            } else if (c == "\t") {
              var tabSize = self.session.getScreenTabSize(screenColumn + tabIdx);
              screenColumn += tabSize - 1;
              return self.$tabStrings[tabSize];
            } else if (c == "\u3000") {
              var classToUse = self.showInvisibles ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
              var space = self.showInvisibles ? self.SPACE_CHAR : "";
              screenColumn += 1;
              return "<span class='" + classToUse + "' style='width:" + (self.config.characterWidth * 2) + "px'>" + space + "</span>";
            } else if (b) {
              return "<span class='ace_invisible ace_invisible_space ace_invalid'>" + self.SPACE_CHAR + "</span>";
            } else {
              screenColumn += 1;
              return "<span class='ace_cjk' style='width:" + (self.config.characterWidth * 2) + "px'>" + c + "</span>";
            }
          };
          var output = value.replace(replaceReg, replaceFunc);
          if (!this.$textToken[token.type]) {
            var classes = "ace_" + token.type.replace(/\./g, " ace_");
            var style = "";
            if (token.type == "fold")
              style = " style='width:" + (token.value.length * this.config.characterWidth) + "px;' ";
            stringBuilder.push("<span class='", classes, "'", style, ">", output, "</span>");
          } else {
            stringBuilder.push(output);
          }
          return screenColumn + value.length;
        };
        this.renderIndentGuide = function(stringBuilder, value, max) {
          var cols = value.search(this.$indentGuideRe);
          if (cols <= 0 || cols >= max)
            return value;
          if (value[0] == " ") {
            cols -= cols % this.tabSize;
            stringBuilder.push(lang.stringRepeat(this.$tabStrings[" "], cols / this.tabSize));
            return value.substr(cols);
          } else if (value[0] == "\t") {
            stringBuilder.push(lang.stringRepeat(this.$tabStrings["\t"], cols));
            return value.substr(cols);
          }
          return value;
        };
        this.$renderWrappedLine = function(stringBuilder, tokens, splits, onlyContents) {
          var chars = 0;
          var split = 0;
          var splitChars = splits[0];
          var screenColumn = 0;
          for (var i = 0; i < tokens.length; i++) {
            var token = tokens[i];
            var value = token.value;
            if (i == 0 && this.displayIndentGuides) {
              chars = value.length;
              value = this.renderIndentGuide(stringBuilder, value, splitChars);
              if (!value)
                continue;
              chars -= value.length;
            }
            if (chars + value.length < splitChars) {
              screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              chars += value.length;
            } else {
              while (chars + value.length >= splitChars) {
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value.substring(0, splitChars - chars));
                value = value.substring(splitChars - chars);
                chars = splitChars;
                if (!onlyContents) {
                  stringBuilder.push("</div>", "<div class='ace_line' style='height:", this.config.lineHeight, "px'>");
                }
                stringBuilder.push(lang.stringRepeat("\xa0", splits.indent));
                split++;
                screenColumn = 0;
                splitChars = splits[split] || Number.MAX_VALUE;
              }
              if (value.length != 0) {
                chars += value.length;
                screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
              }
            }
          }
        };
        this.$renderSimpleLine = function(stringBuilder, tokens) {
          var screenColumn = 0;
          var token = tokens[0];
          var value = token.value;
          if (this.displayIndentGuides)
            value = this.renderIndentGuide(stringBuilder, value);
          if (value)
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          for (var i = 1; i < tokens.length; i++) {
            token = tokens[i];
            value = token.value;
            screenColumn = this.$renderToken(stringBuilder, screenColumn, token, value);
          }
        };
        this.$renderLine = function(stringBuilder, row, onlyContents, foldLine) {
          if (!foldLine && foldLine != false)
            foldLine = this.session.getFoldLine(row);
          if (foldLine)
            var tokens = this.$getFoldLineTokens(row, foldLine);
          else
            var tokens = this.session.getTokens(row);
          if (!onlyContents) {
            stringBuilder.push("<div class='ace_line' style='height:", this.config.lineHeight * (this.$useLineGroups() ? 1 : this.session.getRowLength(row)), "px'>");
          }
          if (tokens.length) {
            var splits = this.session.getRowSplitData(row);
            if (splits && splits.length)
              this.$renderWrappedLine(stringBuilder, tokens, splits, onlyContents);
            else
              this.$renderSimpleLine(stringBuilder, tokens);
          }
          if (this.showInvisibles) {
            if (foldLine)
              row = foldLine.end.row;
            stringBuilder.push("<span class='ace_invisible ace_invisible_eol'>", row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, "</span>");
          }
          if (!onlyContents)
            stringBuilder.push("</div>");
        };
        this.$getFoldLineTokens = function(row, foldLine) {
          var session = this.session;
          var renderTokens = [];
          function addTokens(tokens, from, to) {
            var idx = 0,
                col = 0;
            while ((col + tokens[idx].value.length) < from) {
              col += tokens[idx].value.length;
              idx++;
              if (idx == tokens.length)
                return;
            }
            if (col != from) {
              var value = tokens[idx].value.substring(from - col);
              if (value.length > (to - from))
                value = value.substring(0, to - from);
              renderTokens.push({
                type: tokens[idx].type,
                value: value
              });
              col = from + value.length;
              idx += 1;
            }
            while (col < to && idx < tokens.length) {
              var value = tokens[idx].value;
              if (value.length + col > to) {
                renderTokens.push({
                  type: tokens[idx].type,
                  value: value.substring(0, to - col)
                });
              } else
                renderTokens.push(tokens[idx]);
              col += value.length;
              idx += 1;
            }
          }
          var tokens = session.getTokens(row);
          foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
            if (placeholder != null) {
              renderTokens.push({
                type: "fold",
                value: placeholder
              });
            } else {
              if (isNewRow)
                tokens = session.getTokens(row);
              if (tokens.length)
                addTokens(tokens, lastColumn, column);
            }
          }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
          return renderTokens;
        };
        this.$useLineGroups = function() {
          return this.session.getUseWrapMode();
        };
        this.destroy = function() {
          clearInterval(this.$pollSizeChangesTimer);
          if (this.$measureNode)
            this.$measureNode.parentNode.removeChild(this.$measureNode);
          delete this.$measureNode;
        };
      }).call(Text.prototype);
      exports.Text = Text;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require, exports, module) {
      "use strict";
      var dom = require("../lib/dom");
      var isIE8;
      var Cursor = function(parentEl) {
        this.element = dom.createElement("div");
        this.element.className = "ace_layer ace_cursor-layer";
        parentEl.appendChild(this.element);
        if (isIE8 === undefined)
          isIE8 = !("opacity" in this.element.style);
        this.isVisible = false;
        this.isBlinking = true;
        this.blinkInterval = 1000;
        this.smoothBlinking = false;
        this.cursors = [];
        this.cursor = this.addCursor();
        dom.addCssClass(this.element, "ace_hidden-cursors");
        this.$updateCursors = (isIE8 ? this.$updateVisibility : this.$updateOpacity).bind(this);
      };
      (function() {
        this.$updateVisibility = function(val) {
          var cursors = this.cursors;
          for (var i = cursors.length; i--; )
            cursors[i].style.visibility = val ? "" : "hidden";
        };
        this.$updateOpacity = function(val) {
          var cursors = this.cursors;
          for (var i = cursors.length; i--; )
            cursors[i].style.opacity = val ? "" : "0";
        };
        this.$padding = 0;
        this.setPadding = function(padding) {
          this.$padding = padding;
        };
        this.setSession = function(session) {
          this.session = session;
        };
        this.setBlinking = function(blinking) {
          if (blinking != this.isBlinking) {
            this.isBlinking = blinking;
            this.restartTimer();
          }
        };
        this.setBlinkInterval = function(blinkInterval) {
          if (blinkInterval != this.blinkInterval) {
            this.blinkInterval = blinkInterval;
            this.restartTimer();
          }
        };
        this.setSmoothBlinking = function(smoothBlinking) {
          if (smoothBlinking != this.smoothBlinking && !isIE8) {
            this.smoothBlinking = smoothBlinking;
            dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
            this.$updateCursors(true);
            this.$updateCursors = (this.$updateOpacity).bind(this);
            this.restartTimer();
          }
        };
        this.addCursor = function() {
          var el = dom.createElement("div");
          el.className = "ace_cursor";
          this.element.appendChild(el);
          this.cursors.push(el);
          return el;
        };
        this.removeCursor = function() {
          if (this.cursors.length > 1) {
            var el = this.cursors.pop();
            el.parentNode.removeChild(el);
            return el;
          }
        };
        this.hideCursor = function() {
          this.isVisible = false;
          dom.addCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        this.showCursor = function() {
          this.isVisible = true;
          dom.removeCssClass(this.element, "ace_hidden-cursors");
          this.restartTimer();
        };
        this.restartTimer = function() {
          var update = this.$updateCursors;
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
          if (this.smoothBlinking) {
            dom.removeCssClass(this.element, "ace_smooth-blinking");
          }
          update(true);
          if (!this.isBlinking || !this.blinkInterval || !this.isVisible)
            return;
          if (this.smoothBlinking) {
            setTimeout(function() {
              dom.addCssClass(this.element, "ace_smooth-blinking");
            }.bind(this));
          }
          var blink = function() {
            this.timeoutId = setTimeout(function() {
              update(false);
            }, 0.6 * this.blinkInterval);
          }.bind(this);
          this.intervalId = setInterval(function() {
            update(true);
            blink();
          }, this.blinkInterval);
          blink();
        };
        this.getPixelPosition = function(position, onScreen) {
          if (!this.config || !this.session)
            return {
              left: 0,
              top: 0
            };
          if (!position)
            position = this.session.selection.getCursor();
          var pos = this.session.documentToScreenPosition(position);
          var cursorLeft = this.$padding + pos.column * this.config.characterWidth;
          var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
          return {
            left: cursorLeft,
            top: cursorTop
          };
        };
        this.update = function(config) {
          this.config = config;
          var selections = this.session.$selectionMarkers;
          var i = 0,
              cursorIndex = 0;
          if (selections === undefined || selections.length === 0) {
            selections = [{cursor: null}];
          }
          for (var i = 0,
              n = selections.length; i < n; i++) {
            var pixelPos = this.getPixelPosition(selections[i].cursor, true);
            if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) {
              continue;
            }
            var style = (this.cursors[cursorIndex++] || this.addCursor()).style;
            if (!this.drawCursor) {
              style.left = pixelPos.left + "px";
              style.top = pixelPos.top + "px";
              style.width = config.characterWidth + "px";
              style.height = config.lineHeight + "px";
            } else {
              this.drawCursor(style, pixelPos, config, selections[i], this.session);
            }
          }
          while (this.cursors.length > cursorIndex)
            this.removeCursor();
          var overwrite = this.session.getOverwrite();
          this.$setOverwrite(overwrite);
          this.$pixelPos = pixelPos;
          this.restartTimer();
        };
        this.drawCursor = null;
        this.$setOverwrite = function(overwrite) {
          if (overwrite != this.overwrite) {
            this.overwrite = overwrite;
            if (overwrite)
              dom.addCssClass(this.element, "ace_overwrite-cursors");
            else
              dom.removeCssClass(this.element, "ace_overwrite-cursors");
          }
        };
        this.destroy = function() {
          clearInterval(this.intervalId);
          clearTimeout(this.timeoutId);
        };
      }).call(Cursor.prototype);
      exports.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var dom = require("./lib/dom");
      var event = require("./lib/event");
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var ScrollBar = function(parent) {
        this.element = dom.createElement("div");
        this.element.className = "ace_scrollbar ace_scrollbar" + this.classSuffix;
        this.inner = dom.createElement("div");
        this.inner.className = "ace_scrollbar-inner";
        this.element.appendChild(this.inner);
        parent.appendChild(this.element);
        this.setVisible(false);
        this.skipEvent = false;
        event.addListener(this.element, "scroll", this.onScroll.bind(this));
        event.addListener(this.element, "mousedown", event.preventDefault);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setVisible = function(isVisible) {
          this.element.style.display = isVisible ? "" : "none";
          this.isVisible = isVisible;
        };
      }).call(ScrollBar.prototype);
      var VScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollTop = 0;
        renderer.$scrollbarWidth = this.width = dom.scrollbarWidth(parent.ownerDocument);
        this.inner.style.width = this.element.style.width = (this.width || 15) + 5 + "px";
      };
      oop.inherits(VScrollBar, ScrollBar);
      (function() {
        this.classSuffix = '-v';
        this.onScroll = function() {
          if (!this.skipEvent) {
            this.scrollTop = this.element.scrollTop;
            this._emit("scroll", {data: this.scrollTop});
          }
          this.skipEvent = false;
        };
        this.getWidth = function() {
          return this.isVisible ? this.width : 0;
        };
        this.setHeight = function(height) {
          this.element.style.height = height + "px";
        };
        this.setInnerHeight = function(height) {
          this.inner.style.height = height + "px";
        };
        this.setScrollHeight = function(height) {
          this.inner.style.height = height + "px";
        };
        this.setScrollTop = function(scrollTop) {
          if (this.scrollTop != scrollTop) {
            this.skipEvent = true;
            this.scrollTop = this.element.scrollTop = scrollTop;
          }
        };
      }).call(VScrollBar.prototype);
      var HScrollBar = function(parent, renderer) {
        ScrollBar.call(this, parent);
        this.scrollLeft = 0;
        this.height = renderer.$scrollbarWidth;
        this.inner.style.height = this.element.style.height = (this.height || 15) + 5 + "px";
      };
      oop.inherits(HScrollBar, ScrollBar);
      (function() {
        this.classSuffix = '-h';
        this.onScroll = function() {
          if (!this.skipEvent) {
            this.scrollLeft = this.element.scrollLeft;
            this._emit("scroll", {data: this.scrollLeft});
          }
          this.skipEvent = false;
        };
        this.getHeight = function() {
          return this.isVisible ? this.height : 0;
        };
        this.setWidth = function(width) {
          this.element.style.width = width + "px";
        };
        this.setInnerWidth = function(width) {
          this.inner.style.width = width + "px";
        };
        this.setScrollWidth = function(width) {
          this.inner.style.width = width + "px";
        };
        this.setScrollLeft = function(scrollLeft) {
          if (this.scrollLeft != scrollLeft) {
            this.skipEvent = true;
            this.scrollLeft = this.element.scrollLeft = scrollLeft;
          }
        };
      }).call(HScrollBar.prototype);
      exports.ScrollBar = VScrollBar;
      exports.ScrollBarV = VScrollBar;
      exports.ScrollBarH = HScrollBar;
      exports.VScrollBar = VScrollBar;
      exports.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require, exports, module) {
      "use strict";
      var event = require("./lib/event");
      var RenderLoop = function(onRender, win) {
        this.onRender = onRender;
        this.pending = false;
        this.changes = 0;
        this.window = win || window;
      };
      (function() {
        this.schedule = function(change) {
          this.changes = this.changes | change;
          if (!this.pending && this.changes) {
            this.pending = true;
            var _self = this;
            event.nextFrame(function() {
              _self.pending = false;
              var changes;
              while (changes = _self.changes) {
                _self.changes = 0;
                _self.onRender(changes);
              }
            }, this.window);
          }
        };
      }).call(RenderLoop.prototype);
      exports.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/lib/event_emitter"], function(require, exports, module) {
      var oop = require("../lib/oop");
      var dom = require("../lib/dom");
      var lang = require("../lib/lang");
      var useragent = require("../lib/useragent");
      var EventEmitter = require("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 0;
      var FontMetrics = exports.FontMetrics = function(parentEl) {
        this.el = dom.createElement("div");
        this.$setMeasureNodeStyles(this.el.style, true);
        this.$main = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$main.style);
        this.$measureNode = dom.createElement("div");
        this.$setMeasureNodeStyles(this.$measureNode.style);
        this.el.appendChild(this.$main);
        this.el.appendChild(this.$measureNode);
        parentEl.appendChild(this.el);
        if (!CHAR_COUNT)
          this.$testFractionalRect();
        this.$measureNode.innerHTML = lang.stringRepeat("X", CHAR_COUNT);
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.checkForSizeChanges();
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$characterSize = {
          width: 0,
          height: 0
        };
        this.$testFractionalRect = function() {
          var el = dom.createElement("div");
          this.$setMeasureNodeStyles(el.style);
          el.style.width = "0.2px";
          document.documentElement.appendChild(el);
          var w = el.getBoundingClientRect().width;
          if (w > 0 && w < 1)
            CHAR_COUNT = 50;
          else
            CHAR_COUNT = 100;
          el.parentNode.removeChild(el);
        };
        this.$setMeasureNodeStyles = function(style, isRoot) {
          style.width = style.height = "auto";
          style.left = style.top = "0px";
          style.visibility = "hidden";
          style.position = "absolute";
          style.whiteSpace = "pre";
          if (useragent.isIE < 8) {
            style["font-family"] = "inherit";
          } else {
            style.font = "inherit";
          }
          style.overflow = isRoot ? "hidden" : "visible";
        };
        this.checkForSizeChanges = function() {
          var size = this.$measureSizes();
          if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var boldSize = this.$measureSizes();
            this.$measureNode.style.fontWeight = "";
            this.$characterSize = size;
            this.charSizes = Object.create(null);
            this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
            this._emit("changeCharacterSize", {data: size});
          }
        };
        this.$pollSizeChanges = function() {
          if (this.$pollSizeChangesTimer)
            return this.$pollSizeChangesTimer;
          var self = this;
          return this.$pollSizeChangesTimer = setInterval(function() {
            self.checkForSizeChanges();
          }, 500);
        };
        this.setPolling = function(val) {
          if (val) {
            this.$pollSizeChanges();
          } else if (this.$pollSizeChangesTimer) {
            clearInterval(this.$pollSizeChangesTimer);
            this.$pollSizeChangesTimer = 0;
          }
        };
        this.$measureSizes = function() {
          if (CHAR_COUNT === 50) {
            var rect = null;
            try {
              rect = this.$measureNode.getBoundingClientRect();
            } catch (e) {
              rect = {
                width: 0,
                height: 0
              };
            }
            var size = {
              height: rect.height,
              width: rect.width / CHAR_COUNT
            };
          } else {
            var size = {
              height: this.$measureNode.clientHeight,
              width: this.$measureNode.clientWidth / CHAR_COUNT
            };
          }
          if (size.width === 0 || size.height === 0)
            return null;
          return size;
        };
        this.$measureCharWidth = function(ch) {
          this.$main.innerHTML = lang.stringRepeat(ch, CHAR_COUNT);
          var rect = this.$main.getBoundingClientRect();
          return rect.width / CHAR_COUNT;
        };
        this.getCharacterWidth = function(ch) {
          var w = this.charSizes[ch];
          if (w === undefined) {
            w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
          }
          return w;
        };
        this.destroy = function() {
          clearInterval(this.$pollSizeChangesTimer);
          if (this.el && this.el.parentNode)
            this.el.parentNode.removeChild(this.el);
        };
      }).call(FontMetrics.prototype);
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/config", "ace/lib/useragent", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var dom = require("./lib/dom");
      var config = require("./config");
      var useragent = require("./lib/useragent");
      var GutterLayer = require("./layer/gutter").Gutter;
      var MarkerLayer = require("./layer/marker").Marker;
      var TextLayer = require("./layer/text").Text;
      var CursorLayer = require("./layer/cursor").Cursor;
      var HScrollBar = require("./scrollbar").HScrollBar;
      var VScrollBar = require("./scrollbar").VScrollBar;
      var RenderLoop = require("./renderloop").RenderLoop;
      var FontMetrics = require("./layer/font_metrics").FontMetrics;
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var editorCss = ".ace_editor {\
position: relative;\
overflow: hidden;\
font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'source-code-pro', monospace;\
direction: ltr;\
}\
.ace_scroller {\
position: absolute;\
overflow: hidden;\
top: 0;\
bottom: 0;\
background-color: inherit;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
cursor: text;\
}\
.ace_content {\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
min-width: 100%;\
}\
.ace_dragging .ace_scroller:before{\
position: absolute;\
top: 0;\
left: 0;\
right: 0;\
bottom: 0;\
content: '';\
background: rgba(250, 250, 250, 0.01);\
z-index: 1000;\
}\
.ace_dragging.ace_dark .ace_scroller:before{\
background: rgba(0, 0, 0, 0.01);\
}\
.ace_selecting, .ace_selecting * {\
cursor: text !important;\
}\
.ace_gutter {\
position: absolute;\
overflow : hidden;\
width: auto;\
top: 0;\
bottom: 0;\
left: 0;\
cursor: default;\
z-index: 4;\
-ms-user-select: none;\
-moz-user-select: none;\
-webkit-user-select: none;\
user-select: none;\
}\
.ace_gutter-active-line {\
position: absolute;\
left: 0;\
right: 0;\
}\
.ace_scroller.ace_scroll-left {\
box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\
}\
.ace_gutter-cell {\
padding-left: 19px;\
padding-right: 6px;\
background-repeat: no-repeat;\
}\
.ace_gutter-cell.ace_error {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_warning {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==\");\
background-position: 2px center;\
}\
.ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=\");\
background-position: 2px center;\
}\
.ace_dark .ace_gutter-cell.ace_info {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC\");\
}\
.ace_scrollbar {\
position: absolute;\
right: 0;\
bottom: 0;\
z-index: 6;\
}\
.ace_scrollbar-inner {\
position: absolute;\
cursor: text;\
left: 0;\
top: 0;\
}\
.ace_scrollbar-v{\
overflow-x: hidden;\
overflow-y: scroll;\
top: 0;\
}\
.ace_scrollbar-h {\
overflow-x: scroll;\
overflow-y: hidden;\
left: 0;\
}\
.ace_print-margin {\
position: absolute;\
height: 100%;\
}\
.ace_text-input {\
position: absolute;\
z-index: 0;\
width: 0.5em;\
height: 1em;\
opacity: 0;\
background: transparent;\
-moz-appearance: none;\
appearance: none;\
border: none;\
resize: none;\
outline: none;\
overflow: hidden;\
font: inherit;\
padding: 0 1px;\
margin: 0 -1px;\
text-indent: -1em;\
-ms-user-select: text;\
-moz-user-select: text;\
-webkit-user-select: text;\
user-select: text;\
white-space: pre!important;\
}\
.ace_text-input.ace_composition {\
background: inherit;\
color: inherit;\
z-index: 1000;\
opacity: 1;\
text-indent: 0;\
}\
.ace_layer {\
z-index: 1;\
position: absolute;\
overflow: hidden;\
word-wrap: normal;\
white-space: pre;\
height: 100%;\
width: 100%;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
pointer-events: none;\
}\
.ace_gutter-layer {\
position: relative;\
width: auto;\
text-align: right;\
pointer-events: auto;\
}\
.ace_text-layer {\
font: inherit !important;\
}\
.ace_cjk {\
display: inline-block;\
text-align: center;\
}\
.ace_cursor-layer {\
z-index: 4;\
}\
.ace_cursor {\
z-index: 4;\
position: absolute;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
border-left: 2px solid;\
transform: translatez(0);\
}\
.ace_slim-cursors .ace_cursor {\
border-left-width: 1px;\
}\
.ace_overwrite-cursors .ace_cursor {\
border-left-width: 0;\
border-bottom: 1px solid;\
}\
.ace_hidden-cursors .ace_cursor {\
opacity: 0.2;\
}\
.ace_smooth-blinking .ace_cursor {\
-webkit-transition: opacity 0.18s;\
transition: opacity 0.18s;\
}\
.ace_editor.ace_multiselect .ace_cursor {\
border-left-width: 1px;\
}\
.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\
position: absolute;\
z-index: 3;\
}\
.ace_marker-layer .ace_selection {\
position: absolute;\
z-index: 5;\
}\
.ace_marker-layer .ace_bracket {\
position: absolute;\
z-index: 6;\
}\
.ace_marker-layer .ace_active-line {\
position: absolute;\
z-index: 2;\
}\
.ace_marker-layer .ace_selected-word {\
position: absolute;\
z-index: 4;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
}\
.ace_line .ace_fold {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
display: inline-block;\
height: 11px;\
margin-top: -2px;\
vertical-align: middle;\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=\");\
background-repeat: no-repeat, repeat-x;\
background-position: center center, top left;\
color: transparent;\
border: 1px solid black;\
border-radius: 2px;\
cursor: pointer;\
pointer-events: auto;\
}\
.ace_dark .ace_fold {\
}\
.ace_fold:hover{\
background-image:\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII=\"),\
url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC\");\
}\
.ace_tooltip {\
background-color: #FFF;\
background-image: -webkit-linear-gradient(top, transparent, rgba(0, 0, 0, 0.1));\
background-image: linear-gradient(to bottom, transparent, rgba(0, 0, 0, 0.1));\
border: 1px solid gray;\
border-radius: 1px;\
box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\
color: black;\
max-width: 100%;\
padding: 3px 4px;\
position: fixed;\
z-index: 999999;\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
cursor: default;\
white-space: pre;\
word-wrap: break-word;\
line-height: normal;\
font-style: normal;\
font-weight: normal;\
letter-spacing: normal;\
pointer-events: none;\
}\
.ace_folding-enabled > .ace_gutter-cell {\
padding-right: 13px;\
}\
.ace_fold-widget {\
-moz-box-sizing: border-box;\
-webkit-box-sizing: border-box;\
box-sizing: border-box;\
margin: 0 -12px 0 1px;\
display: none;\
width: 11px;\
vertical-align: top;\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==\");\
background-repeat: no-repeat;\
background-position: center;\
border-radius: 3px;\
border: 1px solid transparent;\
cursor: pointer;\
}\
.ace_folding-enabled .ace_fold-widget {\
display: inline-block;   \
}\
.ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==\");\
}\
.ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==\");\
}\
.ace_fold-widget:hover {\
border: 1px solid rgba(0, 0, 0, 0.3);\
background-color: rgba(255, 255, 255, 0.2);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\
}\
.ace_fold-widget:active {\
border: 1px solid rgba(0, 0, 0, 0.4);\
background-color: rgba(0, 0, 0, 0.05);\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\
}\
.ace_dark .ace_fold-widget {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC\");\
}\
.ace_dark .ace_fold-widget.ace_end {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget.ace_closed {\
background-image: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==\");\
}\
.ace_dark .ace_fold-widget:hover {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
background-color: rgba(255, 255, 255, 0.1);\
}\
.ace_dark .ace_fold-widget:active {\
box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\
}\
.ace_fold-widget.ace_invalid {\
background-color: #FFB4B4;\
border-color: #DE5555;\
}\
.ace_fade-fold-widgets .ace_fold-widget {\
-webkit-transition: opacity 0.4s ease 0.05s;\
transition: opacity 0.4s ease 0.05s;\
opacity: 0;\
}\
.ace_fade-fold-widgets:hover .ace_fold-widget {\
-webkit-transition: opacity 0.05s ease 0.05s;\
transition: opacity 0.05s ease 0.05s;\
opacity:1;\
}\
.ace_underline {\
text-decoration: underline;\
}\
.ace_bold {\
font-weight: bold;\
}\
.ace_nobold .ace_bold {\
font-weight: normal;\
}\
.ace_italic {\
font-style: italic;\
}\
.ace_error-marker {\
background-color: rgba(255, 0, 0,0.2);\
position: absolute;\
z-index: 9;\
}\
.ace_highlight-marker {\
background-color: rgba(255, 255, 0,0.2);\
position: absolute;\
z-index: 8;\
}\
.ace_br1 {border-top-left-radius    : 3px;}\
.ace_br2 {border-top-right-radius   : 3px;}\
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\
.ace_br4 {border-bottom-right-radius: 3px;}\
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\
.ace_br8 {border-bottom-left-radius : 3px;}\
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\
";
      dom.importCssString(editorCss, "ace_editor.css");
      var VirtualRenderer = function(container, theme) {
        var _self = this;
        this.container = container || dom.createElement("div");
        this.$keepTextAreaAtCursor = !useragent.isOldIE;
        dom.addCssClass(this.container, "ace_editor");
        this.setTheme(theme);
        this.$gutter = dom.createElement("div");
        this.$gutter.className = "ace_gutter";
        this.container.appendChild(this.$gutter);
        this.scroller = dom.createElement("div");
        this.scroller.className = "ace_scroller";
        this.container.appendChild(this.scroller);
        this.content = dom.createElement("div");
        this.content.className = "ace_content";
        this.scroller.appendChild(this.content);
        this.$gutterLayer = new GutterLayer(this.$gutter);
        this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
        this.$markerBack = new MarkerLayer(this.content);
        var textLayer = this.$textLayer = new TextLayer(this.content);
        this.canvas = textLayer.element;
        this.$markerFront = new MarkerLayer(this.content);
        this.$cursorLayer = new CursorLayer(this.content);
        this.$horizScroll = false;
        this.$vScroll = false;
        this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
        this.scrollBarH = new HScrollBar(this.container, this);
        this.scrollBarV.addEventListener("scroll", function(e) {
          if (!_self.$scrollAnimation)
            _self.session.setScrollTop(e.data - _self.scrollMargin.top);
        });
        this.scrollBarH.addEventListener("scroll", function(e) {
          if (!_self.$scrollAnimation)
            _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
        });
        this.scrollTop = 0;
        this.scrollLeft = 0;
        this.cursorPos = {
          row: 0,
          column: 0
        };
        this.$fontMetrics = new FontMetrics(this.container);
        this.$textLayer.$setFontMetrics(this.$fontMetrics);
        this.$textLayer.addEventListener("changeCharacterSize", function(e) {
          _self.updateCharacterSize();
          _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
          _self._signal("changeCharacterSize", e);
        });
        this.$size = {
          width: 0,
          height: 0,
          scrollerHeight: 0,
          scrollerWidth: 0,
          $dirty: true
        };
        this.layerConfig = {
          width: 1,
          padding: 0,
          firstRow: 0,
          firstRowScreen: 0,
          lastRow: 0,
          lineHeight: 0,
          characterWidth: 0,
          minHeight: 1,
          maxHeight: 1,
          offset: 0,
          height: 1,
          gutterOffset: 1
        };
        this.scrollMargin = {
          left: 0,
          right: 0,
          top: 0,
          bottom: 0,
          v: 0,
          h: 0
        };
        this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
        this.$loop.schedule(this.CHANGE_FULL);
        this.updateCharacterSize();
        this.setPadding(4);
        config.resetOptions(this);
        config._emit("renderer", this);
      };
      (function() {
        this.CHANGE_CURSOR = 1;
        this.CHANGE_MARKER = 2;
        this.CHANGE_GUTTER = 4;
        this.CHANGE_SCROLL = 8;
        this.CHANGE_LINES = 16;
        this.CHANGE_TEXT = 32;
        this.CHANGE_SIZE = 64;
        this.CHANGE_MARKER_BACK = 128;
        this.CHANGE_MARKER_FRONT = 256;
        this.CHANGE_FULL = 512;
        this.CHANGE_H_SCROLL = 1024;
        oop.implement(this, EventEmitter);
        this.updateCharacterSize = function() {
          if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
            this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
            this.setStyle("ace_nobold", !this.$allowBoldFonts);
          }
          this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
          this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
          this.$updatePrintMargin();
        };
        this.setSession = function(session) {
          if (this.session)
            this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
          this.session = session;
          if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
            session.setScrollTop(-this.scrollMargin.top);
          this.$cursorLayer.setSession(session);
          this.$markerBack.setSession(session);
          this.$markerFront.setSession(session);
          this.$gutterLayer.setSession(session);
          this.$textLayer.setSession(session);
          if (!session)
            return;
          this.$loop.schedule(this.CHANGE_FULL);
          this.session.$setFontMetrics(this.$fontMetrics);
          this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
          this.onChangeNewLineMode();
          this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        };
        this.updateLines = function(firstRow, lastRow, force) {
          if (lastRow === undefined)
            lastRow = Infinity;
          if (!this.$changedLines) {
            this.$changedLines = {
              firstRow: firstRow,
              lastRow: lastRow
            };
          } else {
            if (this.$changedLines.firstRow > firstRow)
              this.$changedLines.firstRow = firstRow;
            if (this.$changedLines.lastRow < lastRow)
              this.$changedLines.lastRow = lastRow;
          }
          if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
            if (force)
              this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
              return;
          }
          if (this.$changedLines.firstRow > this.layerConfig.lastRow)
            return;
          this.$loop.schedule(this.CHANGE_LINES);
        };
        this.onChangeNewLineMode = function() {
          this.$loop.schedule(this.CHANGE_TEXT);
          this.$textLayer.$updateEolChar();
        };
        this.onChangeTabSize = function() {
          this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
          this.$textLayer.onChangeTabSize();
        };
        this.updateText = function() {
          this.$loop.schedule(this.CHANGE_TEXT);
        };
        this.updateFull = function(force) {
          if (force)
            this.$renderChanges(this.CHANGE_FULL, true);
          else
            this.$loop.schedule(this.CHANGE_FULL);
        };
        this.updateFontSize = function() {
          this.$textLayer.checkForSizeChanges();
        };
        this.$changes = 0;
        this.$updateSizeAsync = function() {
          if (this.$loop.pending)
            this.$size.$dirty = true;
          else
            this.onResize();
        };
        this.onResize = function(force, gutterWidth, width, height) {
          if (this.resizing > 2)
            return;
          else if (this.resizing > 0)
            this.resizing++;
          else
            this.resizing = force ? 1 : 0;
          var el = this.container;
          if (!height)
            height = el.clientHeight || el.scrollHeight;
          if (!width)
            width = el.clientWidth || el.scrollWidth;
          var changes = this.$updateCachedSize(force, gutterWidth, width, height);
          if (!this.$size.scrollerHeight || (!width && !height))
            return this.resizing = 0;
          if (force)
            this.$gutterLayer.$padding = null;
          if (force)
            this.$renderChanges(changes | this.$changes, true);
          else
            this.$loop.schedule(changes | this.$changes);
          if (this.resizing)
            this.resizing = 0;
          this.scrollBarV.scrollLeft = this.scrollBarV.scrollTop = null;
        };
        this.$updateCachedSize = function(force, gutterWidth, width, height) {
          height -= (this.$extraHeight || 0);
          var changes = 0;
          var size = this.$size;
          var oldSize = {
            width: size.width,
            height: size.height,
            scrollerHeight: size.scrollerHeight,
            scrollerWidth: size.scrollerWidth
          };
          if (height && (force || size.height != height)) {
            size.height = height;
            changes |= this.CHANGE_SIZE;
            size.scrollerHeight = size.height;
            if (this.$horizScroll)
              size.scrollerHeight -= this.scrollBarH.getHeight();
            this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
            changes = changes | this.CHANGE_SCROLL;
          }
          if (width && (force || size.width != width)) {
            changes |= this.CHANGE_SIZE;
            size.width = width;
            if (gutterWidth == null)
              gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
            this.gutterWidth = gutterWidth;
            this.scrollBarH.element.style.left = this.scroller.style.left = gutterWidth + "px";
            size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth());
            this.scrollBarH.element.style.right = this.scroller.style.right = this.scrollBarV.getWidth() + "px";
            this.scroller.style.bottom = this.scrollBarH.getHeight() + "px";
            if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force)
              changes |= this.CHANGE_FULL;
          }
          size.$dirty = !width || !height;
          if (changes)
            this._signal("resize", oldSize);
          return changes;
        };
        this.onGutterResize = function() {
          var gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
          if (gutterWidth != this.gutterWidth)
            this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
          if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else if (this.$size.$dirty) {
            this.$loop.schedule(this.CHANGE_FULL);
          } else {
            this.$computeLayerConfig();
            this.$loop.schedule(this.CHANGE_MARKER);
          }
        };
        this.adjustWrapLimit = function() {
          var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
          var limit = Math.floor(availableWidth / this.characterWidth);
          return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
        };
        this.setAnimatedScroll = function(shouldAnimate) {
          this.setOption("animatedScroll", shouldAnimate);
        };
        this.getAnimatedScroll = function() {
          return this.$animatedScroll;
        };
        this.setShowInvisibles = function(showInvisibles) {
          this.setOption("showInvisibles", showInvisibles);
        };
        this.getShowInvisibles = function() {
          return this.getOption("showInvisibles");
        };
        this.getDisplayIndentGuides = function() {
          return this.getOption("displayIndentGuides");
        };
        this.setDisplayIndentGuides = function(display) {
          this.setOption("displayIndentGuides", display);
        };
        this.setShowPrintMargin = function(showPrintMargin) {
          this.setOption("showPrintMargin", showPrintMargin);
        };
        this.getShowPrintMargin = function() {
          return this.getOption("showPrintMargin");
        };
        this.setPrintMarginColumn = function(showPrintMargin) {
          this.setOption("printMarginColumn", showPrintMargin);
        };
        this.getPrintMarginColumn = function() {
          return this.getOption("printMarginColumn");
        };
        this.getShowGutter = function() {
          return this.getOption("showGutter");
        };
        this.setShowGutter = function(show) {
          return this.setOption("showGutter", show);
        };
        this.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        };
        this.setFadeFoldWidgets = function(show) {
          this.setOption("fadeFoldWidgets", show);
        };
        this.setHighlightGutterLine = function(shouldHighlight) {
          this.setOption("highlightGutterLine", shouldHighlight);
        };
        this.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        };
        this.$updateGutterLineHighlight = function() {
          var pos = this.$cursorLayer.$pixelPos;
          var height = this.layerConfig.lineHeight;
          if (this.session.getUseWrapMode()) {
            var cursor = this.session.selection.getCursor();
            cursor.column = 0;
            pos = this.$cursorLayer.getPixelPosition(cursor, true);
            height *= this.session.getRowLength(cursor.row);
          }
          this.$gutterLineHighlight.style.top = pos.top - this.layerConfig.offset + "px";
          this.$gutterLineHighlight.style.height = height + "px";
        };
        this.$updatePrintMargin = function() {
          if (!this.$showPrintMargin && !this.$printMarginEl)
            return;
          if (!this.$printMarginEl) {
            var containerEl = dom.createElement("div");
            containerEl.className = "ace_layer ace_print-margin-layer";
            this.$printMarginEl = dom.createElement("div");
            this.$printMarginEl.className = "ace_print-margin";
            containerEl.appendChild(this.$printMarginEl);
            this.content.insertBefore(containerEl, this.content.firstChild);
          }
          var style = this.$printMarginEl.style;
          style.left = ((this.characterWidth * this.$printMarginColumn) + this.$padding) + "px";
          style.visibility = this.$showPrintMargin ? "visible" : "hidden";
          if (this.session && this.session.$wrap == -1)
            this.adjustWrapLimit();
        };
        this.getContainerElement = function() {
          return this.container;
        };
        this.getMouseEventTarget = function() {
          return this.scroller;
        };
        this.getTextAreaContainer = function() {
          return this.container;
        };
        this.$moveTextAreaToCursor = function() {
          if (!this.$keepTextAreaAtCursor)
            return;
          var config = this.layerConfig;
          var posTop = this.$cursorLayer.$pixelPos.top;
          var posLeft = this.$cursorLayer.$pixelPos.left;
          posTop -= config.offset;
          var style = this.textarea.style;
          var h = this.lineHeight;
          if (posTop < 0 || posTop > config.height - h) {
            style.top = style.left = "0";
            return;
          }
          var w = this.characterWidth;
          if (this.$composition) {
            var val = this.textarea.value.replace(/^\x01+/, "");
            w *= (this.session.$getStringScreenWidth(val)[0] + 2);
            h += 2;
          }
          posLeft -= this.scrollLeft;
          if (posLeft > this.$size.scrollerWidth - w)
            posLeft = this.$size.scrollerWidth - w;
          posLeft += this.gutterWidth;
          style.height = h + "px";
          style.width = w + "px";
          style.left = Math.min(posLeft, this.$size.scrollerWidth - w) + "px";
          style.top = Math.min(posTop, this.$size.height - h) + "px";
        };
        this.getFirstVisibleRow = function() {
          return this.layerConfig.firstRow;
        };
        this.getFirstFullyVisibleRow = function() {
          return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        };
        this.getLastFullyVisibleRow = function() {
          var config = this.layerConfig;
          var lastRow = config.lastRow;
          var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
          if (top - this.session.getScrollTop() > config.height - config.lineHeight)
            return lastRow - 1;
          return lastRow;
        };
        this.getLastVisibleRow = function() {
          return this.layerConfig.lastRow;
        };
        this.$padding = null;
        this.setPadding = function(padding) {
          this.$padding = padding;
          this.$textLayer.setPadding(padding);
          this.$cursorLayer.setPadding(padding);
          this.$markerFront.setPadding(padding);
          this.$markerBack.setPadding(padding);
          this.$loop.schedule(this.CHANGE_FULL);
          this.$updatePrintMargin();
        };
        this.setScrollMargin = function(top, bottom, left, right) {
          var sm = this.scrollMargin;
          sm.top = top | 0;
          sm.bottom = bottom | 0;
          sm.right = right | 0;
          sm.left = left | 0;
          sm.v = sm.top + sm.bottom;
          sm.h = sm.left + sm.right;
          if (sm.top && this.scrollTop <= 0 && this.session)
            this.session.setScrollTop(-sm.top);
          this.updateFull();
        };
        this.getHScrollBarAlwaysVisible = function() {
          return this.$hScrollBarAlwaysVisible;
        };
        this.setHScrollBarAlwaysVisible = function(alwaysVisible) {
          this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
        };
        this.getVScrollBarAlwaysVisible = function() {
          return this.$vScrollBarAlwaysVisible;
        };
        this.setVScrollBarAlwaysVisible = function(alwaysVisible) {
          this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
        };
        this.$updateScrollBarV = function() {
          var scrollHeight = this.layerConfig.maxHeight;
          var scrollerHeight = this.$size.scrollerHeight;
          if (!this.$maxLines && this.$scrollPastEnd) {
            scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
            if (this.scrollTop > scrollHeight - scrollerHeight) {
              scrollHeight = this.scrollTop + scrollerHeight;
              this.scrollBarV.scrollTop = null;
            }
          }
          this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
          this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        };
        this.$updateScrollBarH = function() {
          this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
          this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        };
        this.$frozen = false;
        this.freeze = function() {
          this.$frozen = true;
        };
        this.unfreeze = function() {
          this.$frozen = false;
        };
        this.$renderChanges = function(changes, force) {
          if (this.$changes) {
            changes |= this.$changes;
            this.$changes = 0;
          }
          if ((!this.session || !this.container.offsetWidth || this.$frozen) || (!changes && !force)) {
            this.$changes |= changes;
            return;
          }
          if (this.$size.$dirty) {
            this.$changes |= changes;
            return this.onResize(true);
          }
          if (!this.lineHeight) {
            this.$textLayer.checkForSizeChanges();
          }
          this._signal("beforeRender");
          var config = this.layerConfig;
          if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
            changes |= this.$computeLayerConfig();
            if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
              var st = this.scrollTop + (config.firstRow - this.layerConfig.firstRow) * this.lineHeight;
              if (st > 0) {
                this.scrollTop = st;
                changes = changes | this.CHANGE_SCROLL;
                changes |= this.$computeLayerConfig();
              }
            }
            config = this.layerConfig;
            this.$updateScrollBarV();
            if (changes & this.CHANGE_H_SCROLL)
              this.$updateScrollBarH();
            this.$gutterLayer.element.style.marginTop = (-config.offset) + "px";
            this.content.style.marginTop = (-config.offset) + "px";
            this.content.style.width = config.width + 2 * this.$padding + "px";
            this.content.style.height = config.minHeight + "px";
          }
          if (changes & this.CHANGE_H_SCROLL) {
            this.content.style.marginLeft = -this.scrollLeft + "px";
            this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller" : "ace_scroller ace_scroll-left";
          }
          if (changes & this.CHANGE_FULL) {
            this.$textLayer.update(config);
            if (this.$showGutter)
              this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this._signal("afterRender");
            return;
          }
          if (changes & this.CHANGE_SCROLL) {
            if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
              this.$textLayer.update(config);
            else
              this.$textLayer.scrollLines(config);
            if (this.$showGutter)
              this.$gutterLayer.update(config);
            this.$markerBack.update(config);
            this.$markerFront.update(config);
            this.$cursorLayer.update(config);
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
            this.$moveTextAreaToCursor();
            this._signal("afterRender");
            return;
          }
          if (changes & this.CHANGE_TEXT) {
            this.$textLayer.update(config);
            if (this.$showGutter)
              this.$gutterLayer.update(config);
          } else if (changes & this.CHANGE_LINES) {
            if (this.$updateLines() || (changes & this.CHANGE_GUTTER) && this.$showGutter)
              this.$gutterLayer.update(config);
          } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
            if (this.$showGutter)
              this.$gutterLayer.update(config);
          }
          if (changes & this.CHANGE_CURSOR) {
            this.$cursorLayer.update(config);
            this.$moveTextAreaToCursor();
            this.$highlightGutterLine && this.$updateGutterLineHighlight();
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
            this.$markerFront.update(config);
          }
          if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
            this.$markerBack.update(config);
          }
          this._signal("afterRender");
        };
        this.$autosize = function() {
          var height = this.session.getScreenLength() * this.lineHeight;
          var maxHeight = this.$maxLines * this.lineHeight;
          var desiredHeight = Math.max((this.$minLines || 1) * this.lineHeight, Math.min(maxHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
          if (this.$horizScroll)
            desiredHeight += this.scrollBarH.getHeight();
          var vScroll = height > maxHeight;
          if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
            if (vScroll != this.$vScroll) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var w = this.container.clientWidth;
            this.container.style.height = desiredHeight + "px";
            this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
            this.desiredHeight = desiredHeight;
            this._signal("autosize");
          }
        };
        this.$computeLayerConfig = function() {
          var session = this.session;
          var size = this.$size;
          var hideScrollbars = size.height <= 2 * this.lineHeight;
          var screenLines = this.session.getScreenLength();
          var maxHeight = screenLines * this.lineHeight;
          var longestLine = this.$getLongestLine();
          var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
          var hScrollChanged = this.$horizScroll !== horizScroll;
          if (hScrollChanged) {
            this.$horizScroll = horizScroll;
            this.scrollBarH.setVisible(horizScroll);
          }
          var vScrollBefore = this.$vScroll;
          if (this.$maxLines && this.lineHeight > 1)
            this.$autosize();
          var offset = this.scrollTop % this.lineHeight;
          var minHeight = size.scrollerHeight + this.lineHeight;
          var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
          maxHeight += scrollPastEnd;
          var sm = this.scrollMargin;
          this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
          this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
          var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
          var vScrollChanged = vScrollBefore !== vScroll;
          if (vScrollChanged) {
            this.$vScroll = vScroll;
            this.scrollBarV.setVisible(vScroll);
          }
          var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
          var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
          var lastRow = firstRow + lineCount;
          var firstRowScreen,
              firstRowHeight;
          var lineHeight = this.lineHeight;
          firstRow = session.screenToDocumentRow(firstRow, 0);
          var foldLine = session.getFoldLine(firstRow);
          if (foldLine) {
            firstRow = foldLine.start.row;
          }
          firstRowScreen = session.documentToScreenRow(firstRow, 0);
          firstRowHeight = session.getRowLength(firstRow) * lineHeight;
          lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
          minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
          offset = this.scrollTop - firstRowScreen * lineHeight;
          var changes = 0;
          if (this.layerConfig.width != longestLine)
            changes = this.CHANGE_H_SCROLL;
          if (hScrollChanged || vScrollChanged) {
            changes = this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
            this._signal("scrollbarVisibilityChanged");
            if (vScrollChanged)
              longestLine = this.$getLongestLine();
          }
          this.layerConfig = {
            width: longestLine,
            padding: this.$padding,
            firstRow: firstRow,
            firstRowScreen: firstRowScreen,
            lastRow: lastRow,
            lineHeight: lineHeight,
            characterWidth: this.characterWidth,
            minHeight: minHeight,
            maxHeight: maxHeight,
            offset: offset,
            gutterOffset: Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)),
            height: this.$size.scrollerHeight
          };
          return changes;
        };
        this.$updateLines = function() {
          var firstRow = this.$changedLines.firstRow;
          var lastRow = this.$changedLines.lastRow;
          this.$changedLines = null;
          var layerConfig = this.layerConfig;
          if (firstRow > layerConfig.lastRow + 1) {
            return;
          }
          if (lastRow < layerConfig.firstRow) {
            return;
          }
          if (lastRow === Infinity) {
            if (this.$showGutter)
              this.$gutterLayer.update(layerConfig);
            this.$textLayer.update(layerConfig);
            return;
          }
          this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
          return true;
        };
        this.$getLongestLine = function() {
          var charCount = this.session.getScreenWidth();
          if (this.showInvisibles && !this.session.$useWrapMode)
            charCount += 1;
          return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
        };
        this.updateFrontMarkers = function() {
          this.$markerFront.setMarkers(this.session.getMarkers(true));
          this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        };
        this.updateBackMarkers = function() {
          this.$markerBack.setMarkers(this.session.getMarkers());
          this.$loop.schedule(this.CHANGE_MARKER_BACK);
        };
        this.addGutterDecoration = function(row, className) {
          this.$gutterLayer.addGutterDecoration(row, className);
        };
        this.removeGutterDecoration = function(row, className) {
          this.$gutterLayer.removeGutterDecoration(row, className);
        };
        this.updateBreakpoints = function(rows) {
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.setAnnotations = function(annotations) {
          this.$gutterLayer.setAnnotations(annotations);
          this.$loop.schedule(this.CHANGE_GUTTER);
        };
        this.updateCursor = function() {
          this.$loop.schedule(this.CHANGE_CURSOR);
        };
        this.hideCursor = function() {
          this.$cursorLayer.hideCursor();
        };
        this.showCursor = function() {
          this.$cursorLayer.showCursor();
        };
        this.scrollSelectionIntoView = function(anchor, lead, offset) {
          this.scrollCursorIntoView(anchor, offset);
          this.scrollCursorIntoView(lead, offset);
        };
        this.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
          if (this.$size.scrollerHeight === 0)
            return;
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var left = pos.left;
          var top = pos.top;
          var topMargin = $viewMargin && $viewMargin.top || 0;
          var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
          var scrollTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
          if (scrollTop + topMargin > top) {
            if (offset && scrollTop + topMargin > top + this.lineHeight)
              top -= offset * this.$size.scrollerHeight;
            if (top === 0)
              top = -this.scrollMargin.top;
            this.session.setScrollTop(top);
          } else if (scrollTop + this.$size.scrollerHeight - bottomMargin < top + this.lineHeight) {
            if (offset && scrollTop + this.$size.scrollerHeight - bottomMargin < top - this.lineHeight)
              top += offset * this.$size.scrollerHeight;
            this.session.setScrollTop(top + this.lineHeight - this.$size.scrollerHeight);
          }
          var scrollLeft = this.scrollLeft;
          if (scrollLeft > left) {
            if (left < this.$padding + 2 * this.layerConfig.characterWidth)
              left = -this.scrollMargin.left;
            this.session.setScrollLeft(left);
          } else if (scrollLeft + this.$size.scrollerWidth < left + this.characterWidth) {
            this.session.setScrollLeft(Math.round(left + this.characterWidth - this.$size.scrollerWidth));
          } else if (scrollLeft <= this.$padding && left - scrollLeft < this.characterWidth) {
            this.session.setScrollLeft(0);
          }
        };
        this.getScrollTop = function() {
          return this.session.getScrollTop();
        };
        this.getScrollLeft = function() {
          return this.session.getScrollLeft();
        };
        this.getScrollTopRow = function() {
          return this.scrollTop / this.lineHeight;
        };
        this.getScrollBottomRow = function() {
          return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        };
        this.scrollToRow = function(row) {
          this.session.setScrollTop(row * this.lineHeight);
        };
        this.alignCursor = function(cursor, alignment) {
          if (typeof cursor == "number")
            cursor = {
              row: cursor,
              column: 0
            };
          var pos = this.$cursorLayer.getPixelPosition(cursor);
          var h = this.$size.scrollerHeight - this.lineHeight;
          var offset = pos.top - h * (alignment || 0);
          this.session.setScrollTop(offset);
          return offset;
        };
        this.STEPS = 8;
        this.$calcSteps = function(fromValue, toValue) {
          var i = 0;
          var l = this.STEPS;
          var steps = [];
          var func = function(t, x_min, dx) {
            return dx * (Math.pow(t - 1, 3) + 1) + x_min;
          };
          for (i = 0; i < l; ++i)
            steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
          return steps;
        };
        this.scrollToLine = function(line, center, animate, callback) {
          var pos = this.$cursorLayer.getPixelPosition({
            row: line,
            column: 0
          });
          var offset = pos.top;
          if (center)
            offset -= this.$size.scrollerHeight / 2;
          var initialScroll = this.scrollTop;
          this.session.setScrollTop(offset);
          if (animate !== false)
            this.animateScrolling(initialScroll, callback);
        };
        this.animateScrolling = function(fromValue, callback) {
          var toValue = this.scrollTop;
          if (!this.$animatedScroll)
            return;
          var _self = this;
          if (fromValue == toValue)
            return;
          if (this.$scrollAnimation) {
            var oldSteps = this.$scrollAnimation.steps;
            if (oldSteps.length) {
              fromValue = oldSteps[0];
              if (fromValue == toValue)
                return;
            }
          }
          var steps = _self.$calcSteps(fromValue, toValue);
          this.$scrollAnimation = {
            from: fromValue,
            to: toValue,
            steps: steps
          };
          clearInterval(this.$timer);
          _self.session.setScrollTop(steps.shift());
          _self.session.$scrollTop = toValue;
          this.$timer = setInterval(function() {
            if (steps.length) {
              _self.session.setScrollTop(steps.shift());
              _self.session.$scrollTop = toValue;
            } else if (toValue != null) {
              _self.session.$scrollTop = -1;
              _self.session.setScrollTop(toValue);
              toValue = null;
            } else {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              callback && callback();
            }
          }, 10);
        };
        this.scrollToY = function(scrollTop) {
          if (this.scrollTop !== scrollTop) {
            this.$loop.schedule(this.CHANGE_SCROLL);
            this.scrollTop = scrollTop;
          }
        };
        this.scrollToX = function(scrollLeft) {
          if (this.scrollLeft !== scrollLeft)
            this.scrollLeft = scrollLeft;
          this.$loop.schedule(this.CHANGE_H_SCROLL);
        };
        this.scrollTo = function(x, y) {
          this.session.setScrollTop(y);
          this.session.setScrollLeft(y);
        };
        this.scrollBy = function(deltaX, deltaY) {
          deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
          deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        };
        this.isScrollableBy = function(deltaX, deltaY) {
          if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
            return true;
          if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
            return true;
          if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
            return true;
          if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
            return true;
        };
        this.pixelToScreenCoordinates = function(x, y) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var offset = (x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth;
          var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
          var col = Math.round(offset);
          return {
            row: row,
            column: col,
            side: offset - col > 0 ? 1 : -1
          };
        };
        this.screenToTextCoordinates = function(x, y) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var col = Math.round((x + this.scrollLeft - canvasPos.left - this.$padding) / this.characterWidth);
          var row = (y + this.scrollTop - canvasPos.top) / this.lineHeight;
          return this.session.screenToDocumentPosition(row, Math.max(col, 0));
        };
        this.textToScreenCoordinates = function(row, column) {
          var canvasPos = this.scroller.getBoundingClientRect();
          var pos = this.session.documentToScreenPosition(row, column);
          var x = this.$padding + Math.round(pos.column * this.characterWidth);
          var y = pos.row * this.lineHeight;
          return {
            pageX: canvasPos.left + x - this.scrollLeft,
            pageY: canvasPos.top + y - this.scrollTop
          };
        };
        this.visualizeFocus = function() {
          dom.addCssClass(this.container, "ace_focus");
        };
        this.visualizeBlur = function() {
          dom.removeCssClass(this.container, "ace_focus");
        };
        this.showComposition = function(position) {
          if (!this.$composition)
            this.$composition = {
              keepTextAreaAtCursor: this.$keepTextAreaAtCursor,
              cssText: this.textarea.style.cssText
            };
          this.$keepTextAreaAtCursor = true;
          dom.addCssClass(this.textarea, "ace_composition");
          this.textarea.style.cssText = "";
          this.$moveTextAreaToCursor();
        };
        this.setCompositionText = function(text) {
          this.$moveTextAreaToCursor();
        };
        this.hideComposition = function() {
          if (!this.$composition)
            return;
          dom.removeCssClass(this.textarea, "ace_composition");
          this.$keepTextAreaAtCursor = this.$composition.keepTextAreaAtCursor;
          this.textarea.style.cssText = this.$composition.cssText;
          this.$composition = null;
        };
        this.setTheme = function(theme, cb) {
          var _self = this;
          this.$themeId = theme;
          _self._dispatchEvent('themeChange', {theme: theme});
          if (!theme || typeof theme == "string") {
            var moduleName = theme || this.$options.theme.initialValue;
            config.loadModule(["theme", moduleName], afterLoad);
          } else {
            afterLoad(theme);
          }
          function afterLoad(module) {
            if (_self.$themeId != theme)
              return cb && cb();
            if (!module.cssClass)
              return;
            dom.importCssString(module.cssText, module.cssClass, _self.container.ownerDocument);
            if (_self.theme)
              dom.removeCssClass(_self.container, _self.theme.cssClass);
            var padding = "padding" in module ? module.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
            if (_self.$padding && padding != _self.$padding)
              _self.setPadding(padding);
            _self.$theme = module.cssClass;
            _self.theme = module;
            dom.addCssClass(_self.container, module.cssClass);
            dom.setCssClass(_self.container, "ace_dark", module.isDark);
            if (_self.$size) {
              _self.$size.width = 0;
              _self.$updateSizeAsync();
            }
            _self._dispatchEvent('themeLoaded', {theme: module});
            cb && cb();
          }
        };
        this.getTheme = function() {
          return this.$themeId;
        };
        this.setStyle = function(style, include) {
          dom.setCssClass(this.container, style, include !== false);
        };
        this.unsetStyle = function(style) {
          dom.removeCssClass(this.container, style);
        };
        this.setCursorStyle = function(style) {
          if (this.scroller.style.cursor != style)
            this.scroller.style.cursor = style;
        };
        this.setMouseCursor = function(cursorStyle) {
          this.scroller.style.cursor = cursorStyle;
        };
        this.destroy = function() {
          this.$textLayer.destroy();
          this.$cursorLayer.destroy();
        };
      }).call(VirtualRenderer.prototype);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
        animatedScroll: {initialValue: false},
        showInvisibles: {
          set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function(val) {
            if (typeof val == "number")
              this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        fadeFoldWidgets: {
          set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
          },
          initialValue: true
        },
        showLineNumbers: {
          set: function(show) {
            this.$gutterLayer.setShowLineNumbers(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function(shouldHighlight) {
            if (!this.$gutterLineHighlight) {
              this.$gutterLineHighlight = dom.createElement("div");
              this.$gutterLineHighlight.className = "ace_gutter-active-line";
              this.$gutter.appendChild(this.$gutterLineHighlight);
              return;
            }
            this.$gutterLineHighlight.style.display = shouldHighlight ? "" : "none";
            if (this.$cursorLayer.$pixelPos)
              this.$updateGutterLineHighlight();
          },
          initialValue: false,
          value: true
        },
        hScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function(size) {
            if (typeof size == "number")
              size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }},
        maxLines: {set: function(val) {
            this.updateFull();
          }},
        minLines: {set: function(val) {
            this.updateFull();
          }},
        scrollPastEnd: {
          set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
              return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }},
        theme: {
          set: function(val) {
            this.setTheme(val);
          },
          get: function() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        }
      });
      exports.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require, exports, module) {
      "use strict";
      var oop = require("../lib/oop");
      var net = require("../lib/net");
      var EventEmitter = require("../lib/event_emitter").EventEmitter;
      var config = require("../config");
      var WorkerClient = function(topLevelNamespaces, mod, classname, workerUrl) {
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        if (require.nameToUrl && !require.toUrl)
          require.toUrl = require.nameToUrl;
        if (config.get("packaged") || !require.toUrl) {
          workerUrl = workerUrl || config.moduleUrl(mod, "worker");
        } else {
          var normalizePath = this.$normalizePath;
          workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));
          var tlns = {};
          topLevelNamespaces.forEach(function(ns) {
            tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
          });
        }
        try {
          this.$worker = new Worker(workerUrl);
        } catch (e) {
          if (e instanceof window.DOMException) {
            var blob = this.$workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);
            this.$worker = new Worker(blobURL);
            URL.revokeObjectURL(blobURL);
          } else {
            throw e;
          }
        }
        this.$worker.postMessage({
          init: true,
          tlns: tlns,
          module: mod,
          classname: classname
        });
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.onMessage = function(e) {
          var msg = e.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, {data: msg.data});
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function(err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path) {
          return net.qualifyURL(path);
        };
        this.terminate = function() {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker = null;
          if (this.$doc)
            this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function(cmd, args) {
          this.$worker.postMessage({
            command: cmd,
            args: args
          });
        };
        this.call = function(cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function(event, data) {
          try {
            this.$worker.postMessage({
              event: event,
              data: {data: data.data}
            });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function(doc) {
          if (this.$doc)
            this.terminate();
          this.$doc = doc;
          this.call("setValue", [doc.getValue()]);
          doc.on("change", this.changeListener);
        };
        this.changeListener = function(delta) {
          if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
          }
          if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
          else
            this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function() {
          var q = this.deltaQueue;
          if (!q)
            return;
          this.deltaQueue = null;
          if (q.length > 50 && q.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else
            this.emit("change", {data: q});
        };
        this.$workerBlob = function(workerUrl) {
          var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
          try {
            return new Blob([script], {"type": "application/javascript"});
          } catch (e) {
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
          }
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.messageBuffer = [];
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var _self = this;
        this.$worker = {};
        this.$worker.terminate = function() {};
        this.$worker.postMessage = function(e) {
          _self.messageBuffer.push(e);
          if (main) {
            if (emitSync)
              setTimeout(processNext);
            else
              processNext();
          }
        };
        this.setEmitSync = function(val) {
          emitSync = val;
        };
        var processNext = function() {
          var msg = _self.messageBuffer.shift();
          if (msg.command)
            main[msg.command].apply(main, msg.args);
          else if (msg.event)
            sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
          _self.onMessage({data: msg});
        };
        sender.callback = function(data, callbackId) {
          this.postMessage({
            type: "call",
            id: callbackId,
            data: data
          });
        };
        sender.emit = function(name, data) {
          this.postMessage({
            type: "event",
            name: name,
            data: data
          });
        };
        config.loadModule(["worker", mod], function(Main) {
          main = new Main[classname](sender);
          while (_self.messageBuffer.length)
            processNext();
        });
      };
      UIWorkerClient.prototype = WorkerClient.prototype;
      exports.UIWorkerClient = UIWorkerClient;
      exports.WorkerClient = WorkerClient;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require, exports, module) {
      "use strict";
      var Range = require("./range").Range;
      var EventEmitter = require("./lib/event_emitter").EventEmitter;
      var oop = require("./lib/oop");
      var PlaceHolder = function(session, length, pos, others, mainClass, othersClass) {
        var _self = this;
        this.length = length;
        this.session = session;
        this.doc = session.getDocument();
        this.mainClass = mainClass;
        this.othersClass = othersClass;
        this.$onUpdate = this.onUpdate.bind(this);
        this.doc.on("change", this.$onUpdate);
        this.$others = others;
        this.$onCursorChange = function() {
          setTimeout(function() {
            _self.onCursorChange();
          });
        };
        this.$pos = pos;
        var undoStack = session.getUndoManager().$undoStack || session.getUndoManager().$undostack || {length: -1};
        this.$undoStackDepth = undoStack.length;
        this.setup();
        session.selection.on("changeCursor", this.$onCursorChange);
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.setup = function() {
          var _self = this;
          var doc = this.doc;
          var session = this.session;
          this.selectionBefore = session.selection.toJSON();
          if (session.selection.inMultiSelectMode)
            session.selection.toSingleRange();
          this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
          var pos = this.pos;
          pos.$insertRight = true;
          pos.detach();
          pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
          this.others = [];
          this.$others.forEach(function(other) {
            var anchor = doc.createAnchor(other.row, other.column);
            anchor.$insertRight = true;
            anchor.detach();
            _self.others.push(anchor);
          });
          session.setUndoSelect(false);
        };
        this.showOtherMarkers = function() {
          if (this.othersActive)
            return;
          var session = this.session;
          var _self = this;
          this.othersActive = true;
          this.others.forEach(function(anchor) {
            anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
          });
        };
        this.hideOtherMarkers = function() {
          if (!this.othersActive)
            return;
          this.othersActive = false;
          for (var i = 0; i < this.others.length; i++) {
            this.session.removeMarker(this.others[i].markerId);
          }
        };
        this.onUpdate = function(delta) {
          if (this.$updating)
            return this.updateAnchors(delta);
          var range = delta;
          if (range.start.row !== range.end.row)
            return;
          if (range.start.row !== this.pos.row)
            return;
          this.$updating = true;
          var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
          var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
          var distanceFromStart = range.start.column - this.pos.column;
          this.updateAnchors(delta);
          if (inMainRange)
            this.length += lengthDiff;
          if (inMainRange && !this.session.$fromUndo) {
            if (delta.action === 'insert') {
              for (var i = this.others.length - 1; i >= 0; i--) {
                var otherPos = this.others[i];
                var newPos = {
                  row: otherPos.row,
                  column: otherPos.column + distanceFromStart
                };
                this.doc.insertMergedLines(newPos, delta.lines);
              }
            } else if (delta.action === 'remove') {
              for (var i = this.others.length - 1; i >= 0; i--) {
                var otherPos = this.others[i];
                var newPos = {
                  row: otherPos.row,
                  column: otherPos.column + distanceFromStart
                };
                this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
              }
            }
          }
          this.$updating = false;
          this.updateMarkers();
        };
        this.updateAnchors = function(delta) {
          this.pos.onChange(delta);
          for (var i = this.others.length; i--; )
            this.others[i].onChange(delta);
          this.updateMarkers();
        };
        this.updateMarkers = function() {
          if (this.$updating)
            return;
          var _self = this;
          var session = this.session;
          var updateMarker = function(pos, className) {
            session.removeMarker(pos.markerId);
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
          };
          updateMarker(this.pos, this.mainClass);
          for (var i = this.others.length; i--; )
            updateMarker(this.others[i], this.othersClass);
        };
        this.onCursorChange = function(event) {
          if (this.$updating || !this.session)
            return;
          var pos = this.session.selection.getCursor();
          if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
            this.showOtherMarkers();
            this._emit("cursorEnter", event);
          } else {
            this.hideOtherMarkers();
            this._emit("cursorLeave", event);
          }
        };
        this.detach = function() {
          this.session.removeMarker(this.pos && this.pos.markerId);
          this.hideOtherMarkers();
          this.doc.removeEventListener("change", this.$onUpdate);
          this.session.selection.removeEventListener("changeCursor", this.$onCursorChange);
          this.session.setUndoSelect(true);
          this.session = null;
        };
        this.cancel = function() {
          if (this.$undoStackDepth === -1)
            return;
          var undoManager = this.session.getUndoManager();
          var undosRequired = (undoManager.$undoStack || undoManager.$undostack).length - this.$undoStackDepth;
          for (var i = 0; i < undosRequired; i++) {
            undoManager.undo(true);
          }
          if (this.selectionBefore)
            this.session.selection.fromJSON(this.selectionBefore);
        };
      }).call(PlaceHolder.prototype);
      exports.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require, exports, module) {
      var event = require("../lib/event");
      var useragent = require("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        if (ctrl && useragent.isMac)
          button = ev.button;
        if (e.editor.inMultiSelectMode && button == 2) {
          e.editor.textInput.onContextMenu(e.domEvent);
          return;
        }
        if (!ctrl && !alt && !accel) {
          if (button === 0 && e.editor.inMultiSelectMode)
            e.editor.exitMultiSelectMode();
          return;
        }
        if (button !== 0)
          return;
        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || (selection.isEmpty() && isSamePoint(pos, cursor));
        var mouseX = e.x,
            mouseY = e.y;
        var onMouseSelection = function(e) {
          mouseX = e.clientX;
          mouseY = e.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
          else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
              return;
          } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection)
            return;
          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor.$blockScrolling++;
          editor.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
          }
          editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
              selection.substractPoint(tmpSel.cursor);
            else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor.$blockScrolling--;
            editor.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e.stop();
          editor.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead))
              return;
            screenCursor = newCursor;
            editor.$blockScrolling++;
            editor.selection.moveToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
              rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
            editor.$blockScrolling--;
          };
          editor.$blockScrolling++;
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
          }
          if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
          else
            selection.moveToPosition(pos);
          editor.$blockScrolling--;
          screenCursor = {
            row: -1,
            column: -1
          };
          var onMouseSelectionEnd = function(e) {
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
              rectSel = [selection.toOrientedRange()];
            editor.$blockScrolling++;
            if (initialRange) {
              editor.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i = 0; i < rectSel.length; i++)
              selection.addRange(rectSel[i]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
            editor.$blockScrolling--;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function() {
            onSelectionInterval();
          }, 20);
          return e.preventDefault();
        }
      }
      exports.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require, exports, module) {
      exports.defaultCommands = [{
        name: "addCursorAbove",
        exec: function(editor) {
          editor.selectMoreLines(-1);
        },
        bindKey: {
          win: "Ctrl-Alt-Up",
          mac: "Ctrl-Alt-Up"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelow",
        exec: function(editor) {
          editor.selectMoreLines(1);
        },
        bindKey: {
          win: "Ctrl-Alt-Down",
          mac: "Ctrl-Alt-Down"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        exec: function(editor) {
          editor.selectMoreLines(-1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Up",
          mac: "Ctrl-Alt-Shift-Up"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        exec: function(editor) {
          editor.selectMoreLines(1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Down",
          mac: "Ctrl-Alt-Shift-Down"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreBefore",
        exec: function(editor) {
          editor.selectMore(-1);
        },
        bindKey: {
          win: "Ctrl-Alt-Left",
          mac: "Ctrl-Alt-Left"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreAfter",
        exec: function(editor) {
          editor.selectMore(1);
        },
        bindKey: {
          win: "Ctrl-Alt-Right",
          mac: "Ctrl-Alt-Right"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextBefore",
        exec: function(editor) {
          editor.selectMore(-1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Left",
          mac: "Ctrl-Alt-Shift-Left"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextAfter",
        exec: function(editor) {
          editor.selectMore(1, true);
        },
        bindKey: {
          win: "Ctrl-Alt-Shift-Right",
          mac: "Ctrl-Alt-Shift-Right"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "splitIntoLines",
        exec: function(editor) {
          editor.multiSelect.splitIntoLines();
        },
        bindKey: {
          win: "Ctrl-Alt-L",
          mac: "Ctrl-Alt-L"
        },
        readOnly: true
      }, {
        name: "alignCursors",
        exec: function(editor) {
          editor.alignCursors();
        },
        bindKey: {
          win: "Ctrl-Alt-A",
          mac: "Ctrl-Alt-A"
        },
        scrollIntoView: "cursor"
      }, {
        name: "findAll",
        exec: function(editor) {
          editor.findAll();
        },
        bindKey: {
          win: "Ctrl-Alt-K",
          mac: "Ctrl-Alt-G"
        },
        scrollIntoView: "cursor",
        readOnly: true
      }];
      exports.multiSelectCommands = [{
        name: "singleSelection",
        bindKey: "esc",
        exec: function(editor) {
          editor.exitMultiSelectMode();
        },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor) {
          return editor && editor.inMultiSelectMode;
        }
      }];
      var HashHandler = require("../keyboard/hash_handler").HashHandler;
      exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require, exports, module) {
      var RangeList = require("./range_list").RangeList;
      var Range = require("./range").Range;
      var Selection = require("./selection").Selection;
      var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
      var event = require("./lib/event");
      var lang = require("./lib/lang");
      var commands = require("./commands/multi_select_commands");
      exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = require("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = require("./edit_session").EditSession;
      (function() {
        this.getSelectionMarkers = function() {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
          if (!range)
            return;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor)
            range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length)
            this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length)
            this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function() {
          var removed = this.rangeList.merge();
          if (removed.length)
            this.$onRemoveRange(removed);
          else if (this.ranges[0])
            this.fromOrientedRange(this.ranges[0]);
        };
        this.$onAddRange = function(range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", {range: range});
        };
        this.$onRemoveRange = function(removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i = removed.length; i--; ) {
            var index = this.ranges.indexOf(removed[i]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", {ranges: removed});
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
          if (this.rangeList)
            return;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function() {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var range = this.getRange();
            var isBackwards = this.isBackwards();
            var startRow = range.start.row;
            var endRow = range.end.row;
            if (startRow == endRow) {
              if (isBackwards)
                var start = range.end,
                    end = range.start;
              else
                var start = range.start,
                    end = range.end;
              this.addRange(Range.fromPoints(end, end));
              this.addRange(Range.fromPoints(start, start));
              return;
            }
            var rectSel = [];
            var r = this.getLineRange(startRow, true);
            r.start.column = range.start.column;
            rectSel.push(r);
            for (var i = startRow + 1; i < endRow; i++)
              rectSel.push(this.getLineRange(i, true));
            r = this.getLineRange(endRow, true);
            r.end.column = range.end.column;
            rectSel.push(r);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.toggleBlockSelection = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.selectionLead);
            var anchor = this.session.documentToScreenPosition(this.selectionAnchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0)
            startColumn = 0;
          if (startRow < 0)
            startRow = 0;
          if (startRow == endRow)
            includeEmptyLines = true;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn), this.session.screenToDocumentPosition(row, endColumn));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd))
                break;
              var docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards)
            rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
              end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty())
                start++;
            }
            for (var i = end; i >= start; i--) {
              if (rectSel[i].isEmpty())
                rectSel.splice(i, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = require("./editor").Editor;
      (function() {
        this.updateSelectionMarkers = function() {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
          if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
          if (!range.marker)
            return;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i = ranges.length; i--; ) {
            var range = ranges[i];
            if (!range.marker)
              continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
              markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e) {
          this.addSelectionMarker(e.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e) {
          this.removeSelectionMarkers(e.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e) {
          if (this.inMultiSelectMode)
            return;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e) {
          if (this.session.multiSelect.inVirtualMode)
            return;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e) {
          var command = e.command;
          var editor = e.editor;
          if (!editor.multiSelect)
            return;
          if (!command.multiSelectAction) {
            var result = command.exec(editor, e.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e.args, true);
          } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e.args || {});
          } else {
            result = command.multiSelectAction(editor, e.args || {});
          }
          return result;
        };
        this.forEachSelection = function(cmd, args, options) {
          if (this.inVirtualSelectionMode)
            return;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i = ranges.length; i--; ) {
            if ($byLines) {
              while (i > 0 && ranges[i].start.row == ranges[i - 1].end.row)
                i--;
            }
            tmpSel.fromOrientedRange(ranges[i]);
            tmpSel.index = i;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== undefined)
              result = cmdResult;
            tmpSel.toOrientedRange(ranges[i]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function() {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i = 0; i < ranges.length; i++) {
              buf.push(this.session.getTextRange(ranges[i]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
              text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function(e, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
              return;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
              this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
          }
        };
        this.findAll = function(needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == undefined) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length)
            return 0;
          this.$blockScrolling += 1;
          var selection = this.multiSelect;
          if (!additive)
            selection.toSingleRange(ranges[0]);
          for (var i = ranges.length; i--; )
            selection.addRange(ranges[i], true);
          if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
          this.$blockScrolling -= 1;
          return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip)
              var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove)
            this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i = all.length; i--; ) {
            var range = all[i];
            if (range.isEmpty()) {
              var tmp = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp.start.row;
              range.start.column = tmp.start.column;
              range.end.row = tmp.end.row;
              range.end.column = tmp.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i = all.length; i--; ) {
            var range = all[i];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0)
            words.unshift(words.pop());
          else
            words.push(words.shift());
          for (var i = all.length; i--; ) {
            var range = all[i];
            var tmp = range.clone();
            session.replace(range, words[i]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
              return;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.$blockScrolling += 1;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.$blockScrolling -= 1;
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip)
            this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row,
                lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr);
              } while (/[=:]/.test(line) && ++lr < max);
              do {
                line = this.session.getLine(fr);
              } while (/[=:]/.test(line) && --fr > 0);
              if (fr < 0)
                fr = 0;
              if (lr >= max)
                lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({
              row: fr,
              column: 0
            }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function(r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
              var p = r.cursor;
              var line = session.getLine(p.row);
              var spaceOffset = line.substr(p.column).search(/\S/g);
              if (spaceOffset == -1)
                spaceOffset = 0;
              if (p.column > maxCol)
                maxCol = p.column;
              if (spaceOffset < minSpace)
                minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function(r, i) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d = spaceOffsets[i] - minSpace;
              if (l > d)
                session.insert(p, lang.stringRepeat(" ", l - d));
              else
                session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function(lines, forceLeft) {
          var isLeftAligned = true,
              isRightAligned = true;
          var startW,
              textW,
              endW;
          return lines.map(function(line) {
            var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m)
              return [line];
            if (startW == null) {
              startW = m[1].length;
              textW = m[2].length;
              endW = m[3].length;
              return m;
            }
            if (startW + textW + endW != m[1].length + m[2].length + m[3].length)
              isRightAligned = false;
            if (startW != m[1].length)
              isLeftAligned = false;
            if (startW > m[1].length)
              startW = m[1].length;
            if (textW < m[2].length)
              textW = m[2].length;
            if (endW > m[3].length)
              endW = m[3].length;
            return m;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m) {
            return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW, " ") + m[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m) {
            return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports.onSessionChange = function(e) {
        var session = e.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
          else
            this.$onSingleSelect();
        }
      };
      function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
          return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e) {
          var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
          if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
              editor.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        });
        event.addListener(el, "keyup", reset);
        event.addListener(el, "blur", reset);
        function reset(e) {
          if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports.MultiSelect = MultiSelect;
      require("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
          set: function(val) {
            MultiSelect(this);
            if (val) {
              this.on("changeSession", this.$multiselectOnSessionChange);
              this.on("mousedown", onMouseDown);
            } else {
              this.off("changeSession", this.$multiselectOnSessionChange);
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        },
        enableBlockSelect: {
          set: function(val) {
            this.$blockSelectEnabled = val;
          },
          value: true
        }
      });
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require, exports, module) {
      "use strict";
      var Range = require("../../range").Range;
      var FoldMode = exports.FoldMode = function() {};
      (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line))
            return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
            return "end";
          return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function(session, row, column) {
          var re = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re);
          if (startLevel == -1)
            return;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re);
            if (level == -1)
              continue;
            if (level <= startLevel)
              break;
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
          var start = {
            row: row,
            column: column + 1
          };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end)
            return;
          var fw = session.foldWidgets[end.row];
          if (fw == null)
            fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
          var end = {
            row: row,
            column: column
          };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start)
            return;
          start.column++;
          end.column--;
          return Range.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/lib/dom"], function(require, exports, module) {
      "use strict";
      exports.isDark = false;
      exports.cssClass = "ace-tm";
      exports.cssText = ".ace-tm .ace_gutter {\
background: #f0f0f0;\
color: #333;\
}\
.ace-tm .ace_print-margin {\
width: 1px;\
background: #e8e8e8;\
}\
.ace-tm .ace_fold {\
background-color: #6B72E6;\
}\
.ace-tm {\
background-color: #FFFFFF;\
color: black;\
}\
.ace-tm .ace_cursor {\
color: black;\
}\
.ace-tm .ace_invisible {\
color: rgb(191, 191, 191);\
}\
.ace-tm .ace_storage,\
.ace-tm .ace_keyword {\
color: blue;\
}\
.ace-tm .ace_constant {\
color: rgb(197, 6, 11);\
}\
.ace-tm .ace_constant.ace_buildin {\
color: rgb(88, 72, 246);\
}\
.ace-tm .ace_constant.ace_language {\
color: rgb(88, 92, 246);\
}\
.ace-tm .ace_constant.ace_library {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_invalid {\
background-color: rgba(255, 0, 0, 0.1);\
color: red;\
}\
.ace-tm .ace_support.ace_function {\
color: rgb(60, 76, 114);\
}\
.ace-tm .ace_support.ace_constant {\
color: rgb(6, 150, 14);\
}\
.ace-tm .ace_support.ace_type,\
.ace-tm .ace_support.ace_class {\
color: rgb(109, 121, 222);\
}\
.ace-tm .ace_keyword.ace_operator {\
color: rgb(104, 118, 135);\
}\
.ace-tm .ace_string {\
color: rgb(3, 106, 7);\
}\
.ace-tm .ace_comment {\
color: rgb(76, 136, 107);\
}\
.ace-tm .ace_comment.ace_doc {\
color: rgb(0, 102, 255);\
}\
.ace-tm .ace_comment.ace_doc.ace_tag {\
color: rgb(128, 159, 191);\
}\
.ace-tm .ace_constant.ace_numeric {\
color: rgb(0, 0, 205);\
}\
.ace-tm .ace_variable {\
color: rgb(49, 132, 149);\
}\
.ace-tm .ace_xml-pe {\
color: rgb(104, 104, 91);\
}\
.ace-tm .ace_entity.ace_name.ace_function {\
color: #0000A2;\
}\
.ace-tm .ace_heading {\
color: rgb(12, 7, 255);\
}\
.ace-tm .ace_list {\
color:rgb(185, 6, 144);\
}\
.ace-tm .ace_meta.ace_tag {\
color:rgb(0, 22, 142);\
}\
.ace-tm .ace_string.ace_regex {\
color: rgb(255, 0, 0)\
}\
.ace-tm .ace_marker-layer .ace_selection {\
background: rgb(181, 213, 255);\
}\
.ace-tm.ace_multiselect .ace_selection.ace_start {\
box-shadow: 0 0 3px 0px white;\
}\
.ace-tm .ace_marker-layer .ace_step {\
background: rgb(252, 255, 0);\
}\
.ace-tm .ace_marker-layer .ace_stack {\
background: rgb(164, 229, 101);\
}\
.ace-tm .ace_marker-layer .ace_bracket {\
margin: -1px 0 0 -1px;\
border: 1px solid rgb(192, 192, 192);\
}\
.ace-tm .ace_marker-layer .ace_active-line {\
background: rgba(0, 0, 0, 0.07);\
}\
.ace-tm .ace_gutter-active-line {\
background-color : #dcdcdc;\
}\
.ace-tm .ace_marker-layer .ace_selected-word {\
background: rgb(250, 250, 255);\
border: 1px solid rgb(200, 200, 250);\
}\
.ace-tm .ace_indent-guide {\
background: url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==\") right repeat-y;\
}\
";
      var dom = require("../lib/dom");
      dom.importCssString(exports.cssText, exports.cssClass);
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/range"], function(require, exports, module) {
      "use strict";
      var oop = require("./lib/oop");
      var dom = require("./lib/dom");
      var Range = require("./range").Range;
      function LineWidgets(session) {
        this.session = session;
        this.session.widgetManager = this;
        this.session.getRowLength = this.getRowLength;
        this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
        this.updateOnChange = this.updateOnChange.bind(this);
        this.renderWidgets = this.renderWidgets.bind(this);
        this.measureWidgets = this.measureWidgets.bind(this);
        this.session._changedWidgets = [];
        this.$onChangeEditor = this.$onChangeEditor.bind(this);
        this.session.on("change", this.updateOnChange);
        this.session.on("changeFold", this.updateOnFold);
        this.session.on("changeEditor", this.$onChangeEditor);
      }
      (function() {
        this.getRowLength = function(row) {
          var h;
          if (this.lineWidgets)
            h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
          else
            h = 0;
          if (!this.$useWrapMode || !this.$wrapData[row]) {
            return 1 + h;
          } else {
            return this.$wrapData[row].length + 1 + h;
          }
        };
        this.$getWidgetScreenLength = function() {
          var screenRows = 0;
          this.lineWidgets.forEach(function(w) {
            if (w && w.rowCount && !w.hidden)
              screenRows += w.rowCount;
          });
          return screenRows;
        };
        this.$onChangeEditor = function(e) {
          this.attach(e.editor);
        };
        this.attach = function(editor) {
          if (editor && editor.widgetManager && editor.widgetManager != this)
            editor.widgetManager.detach();
          if (this.editor == editor)
            return;
          this.detach();
          this.editor = editor;
          if (editor) {
            editor.widgetManager = this;
            editor.renderer.on("beforeRender", this.measureWidgets);
            editor.renderer.on("afterRender", this.renderWidgets);
          }
        };
        this.detach = function(e) {
          var editor = this.editor;
          if (!editor)
            return;
          this.editor = null;
          editor.widgetManager = null;
          editor.renderer.off("beforeRender", this.measureWidgets);
          editor.renderer.off("afterRender", this.renderWidgets);
          var lineWidgets = this.session.lineWidgets;
          lineWidgets && lineWidgets.forEach(function(w) {
            if (w && w.el && w.el.parentNode) {
              w._inDocument = false;
              w.el.parentNode.removeChild(w.el);
            }
          });
        };
        this.updateOnFold = function(e, session) {
          var lineWidgets = session.lineWidgets;
          if (!lineWidgets || !e.action)
            return;
          var fold = e.data;
          var start = fold.start.row;
          var end = fold.end.row;
          var hide = e.action == "add";
          for (var i = start + 1; i < end; i++) {
            if (lineWidgets[i])
              lineWidgets[i].hidden = hide;
          }
          if (lineWidgets[end]) {
            if (hide) {
              if (!lineWidgets[start])
                lineWidgets[start] = lineWidgets[end];
              else
                lineWidgets[end].hidden = hide;
            } else {
              if (lineWidgets[start] == lineWidgets[end])
                lineWidgets[start] = undefined;
              lineWidgets[end].hidden = hide;
            }
          }
        };
        this.updateOnChange = function(delta) {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return;
          var startRow = delta.start.row;
          var len = delta.end.row - startRow;
          if (len === 0) {} else if (delta.action == 'remove') {
            var removed = lineWidgets.splice(startRow + 1, len);
            removed.forEach(function(w) {
              w && this.removeLineWidget(w);
            }, this);
            this.$updateRows();
          } else {
            var args = new Array(len);
            args.unshift(startRow, 0);
            lineWidgets.splice.apply(lineWidgets, args);
            this.$updateRows();
          }
        };
        this.$updateRows = function() {
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return;
          var noWidgets = true;
          lineWidgets.forEach(function(w, i) {
            if (w) {
              noWidgets = false;
              w.row = i;
              while (w.$oldWidget) {
                w.$oldWidget.row = i;
                w = w.$oldWidget;
              }
            }
          });
          if (noWidgets)
            this.session.lineWidgets = null;
        };
        this.addLineWidget = function(w) {
          if (!this.session.lineWidgets)
            this.session.lineWidgets = new Array(this.session.getLength());
          var old = this.session.lineWidgets[w.row];
          if (old) {
            w.$oldWidget = old;
            if (old.el && old.el.parentNode) {
              old.el.parentNode.removeChild(old.el);
              old._inDocument = false;
            }
          }
          this.session.lineWidgets[w.row] = w;
          w.session = this.session;
          var renderer = this.editor.renderer;
          if (w.html && !w.el) {
            w.el = dom.createElement("div");
            w.el.innerHTML = w.html;
          }
          if (w.el) {
            dom.addCssClass(w.el, "ace_lineWidgetContainer");
            w.el.style.position = "absolute";
            w.el.style.zIndex = 5;
            renderer.container.appendChild(w.el);
            w._inDocument = true;
          }
          if (!w.coverGutter) {
            w.el.style.zIndex = 3;
          }
          if (!w.pixelHeight) {
            w.pixelHeight = w.el.offsetHeight;
          }
          if (w.rowCount == null) {
            w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
          }
          var fold = this.session.getFoldAt(w.row, 0);
          w.$fold = fold;
          if (fold) {
            var lineWidgets = this.session.lineWidgets;
            if (w.row == fold.end.row && !lineWidgets[fold.start.row])
              lineWidgets[fold.start.row] = w;
            else
              w.hidden = true;
          }
          this.session._emit("changeFold", {data: {start: {row: w.row}}});
          this.$updateRows();
          this.renderWidgets(null, renderer);
          this.onWidgetChanged(w);
          return w;
        };
        this.removeLineWidget = function(w) {
          w._inDocument = false;
          w.session = null;
          if (w.el && w.el.parentNode)
            w.el.parentNode.removeChild(w.el);
          if (w.editor && w.editor.destroy)
            try {
              w.editor.destroy();
            } catch (e) {}
          if (this.session.lineWidgets) {
            var w1 = this.session.lineWidgets[w.row];
            if (w1 == w) {
              this.session.lineWidgets[w.row] = w.$oldWidget;
              if (w.$oldWidget)
                this.onWidgetChanged(w.$oldWidget);
            } else {
              while (w1) {
                if (w1.$oldWidget == w) {
                  w1.$oldWidget = w.$oldWidget;
                  break;
                }
                w1 = w1.$oldWidget;
              }
            }
          }
          this.session._emit("changeFold", {data: {start: {row: w.row}}});
          this.$updateRows();
        };
        this.getWidgetsAtRow = function(row) {
          var lineWidgets = this.session.lineWidgets;
          var w = lineWidgets && lineWidgets[row];
          var list = [];
          while (w) {
            list.push(w);
            w = w.$oldWidget;
          }
          return list;
        };
        this.onWidgetChanged = function(w) {
          this.session._changedWidgets.push(w);
          this.editor && this.editor.renderer.updateFull();
        };
        this.measureWidgets = function(e, renderer) {
          var changedWidgets = this.session._changedWidgets;
          var config = renderer.layerConfig;
          if (!changedWidgets || !changedWidgets.length)
            return;
          var min = Infinity;
          for (var i = 0; i < changedWidgets.length; i++) {
            var w = changedWidgets[i];
            if (!w || !w.el)
              continue;
            if (w.session != this.session)
              continue;
            if (!w._inDocument) {
              if (this.session.lineWidgets[w.row] != w)
                continue;
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            w.h = w.el.offsetHeight;
            if (!w.fixedWidth) {
              w.w = w.el.offsetWidth;
              w.screenWidth = Math.ceil(w.w / config.characterWidth);
            }
            var rowCount = w.h / config.lineHeight;
            if (w.coverLine) {
              rowCount -= this.session.getRowLineCount(w.row);
              if (rowCount < 0)
                rowCount = 0;
            }
            if (w.rowCount != rowCount) {
              w.rowCount = rowCount;
              if (w.row < min)
                min = w.row;
            }
          }
          if (min != Infinity) {
            this.session._emit("changeFold", {data: {start: {row: min}}});
            this.session.lineWidgetWidth = null;
          }
          this.session._changedWidgets = [];
        };
        this.renderWidgets = function(e, renderer) {
          var config = renderer.layerConfig;
          var lineWidgets = this.session.lineWidgets;
          if (!lineWidgets)
            return;
          var first = Math.min(this.firstRow, config.firstRow);
          var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
          while (first > 0 && !lineWidgets[first])
            first--;
          this.firstRow = config.firstRow;
          this.lastRow = config.lastRow;
          renderer.$cursorLayer.config = config;
          for (var i = first; i <= last; i++) {
            var w = lineWidgets[i];
            if (!w || !w.el)
              continue;
            if (w.hidden) {
              w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
              continue;
            }
            if (!w._inDocument) {
              w._inDocument = true;
              renderer.container.appendChild(w.el);
            }
            var top = renderer.$cursorLayer.getPixelPosition({
              row: i,
              column: 0
            }, true).top;
            if (!w.coverLine)
              top += config.lineHeight * this.session.getRowLineCount(w.row);
            w.el.style.top = top - config.offset + "px";
            var left = w.coverGutter ? 0 : renderer.gutterWidth;
            if (!w.fixedWidth)
              left -= renderer.scrollLeft;
            w.el.style.left = left + "px";
            if (w.fullWidth && w.screenWidth) {
              w.el.style.minWidth = config.width + 2 * config.padding + "px";
            }
            if (w.fixedWidth) {
              w.el.style.right = renderer.scrollBar.getWidth() + "px";
            } else {
              w.el.style.right = "";
            }
          }
        };
      }).call(LineWidgets.prototype);
      exports.LineWidgets = LineWidgets;
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range"], function(require, exports, module) {
      "use strict";
      var LineWidgets = require("../line_widgets").LineWidgets;
      var dom = require("../lib/dom");
      var Range = require("../range").Range;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = (first + last) >> 1;
          var c = comparator(needle, array[mid]);
          if (c > 0)
            first = mid + 1;
          else if (c < 0)
            last = mid - 1;
          else
            return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
          return;
        var i = binarySearch(annotations, {
          row: row,
          column: -1
        }, Range.comparePoints);
        if (i < 0)
          i = -i - 1;
        if (i >= annotations.length)
          i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0)
          i = annotations.length - 1;
        var annotation = annotations[i];
        if (!annotation || !dir)
          return;
        if (annotation.row === row) {
          do {
            annotation = annotations[i += dir];
          } while (annotation && annotation.row === row);
          if (!annotation)
            return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        if (!session.widgetManager) {
          session.widgetManager = new LineWidgets(session);
          session.widgetManager.attach(editor);
        }
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
          return w.type == "errorMarker";
        })[0];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return;
        } else {
          gutterAnno = {
            text: ["Looks good!"],
            className: "ace_ok"
          };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div"),
          type: "errorMarker"
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        el.innerHTML = gutterAnno.text.join("<br>");
        el.appendChild(dom.createElement("div"));
        var kb = function(_, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w.destroy();
            return {command: "null"};
          }
        };
        w.destroy = function() {
          if (editor.$mouseHandler.isMousePressed)
            return;
          editor.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w);
          editor.off("changeSelection", w.destroy);
          editor.off("changeSession", w.destroy);
          editor.off("mouseup", w.destroy);
          editor.off("change", w.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w.destroy);
        editor.on("changeSession", w.destroy);
        editor.on("mouseup", w.destroy);
        editor.on("change", w.destroy);
        editor.session.widgetManager.addLineWidget(w);
        w.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, {bottom: w.el.offsetHeight});
      };
      dom.importCssString("\
    .error_widget_wrapper {\
        background: inherit;\
        color: inherit;\
        border:none\
    }\
    .error_widget {\
        border-top: solid 2px;\
        border-bottom: solid 2px;\
        margin: 5px 0;\
        padding: 10px 40px;\
        white-space: pre-wrap;\
    }\
    .error_widget.ace_error, .error_widget_arrow.ace_error{\
        border-color: #ff5a5a\
    }\
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\
        border-color: #F1D817\
    }\
    .error_widget.ace_info, .error_widget_arrow.ace_info{\
        border-color: #5a5a5a\
    }\
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\
        border-color: #5aaa5a\
    }\
    .error_widget_arrow {\
        position: absolute;\
        border: solid 5px;\
        border-top-color: transparent!important;\
        border-right-color: transparent!important;\
        border-left-color: transparent!important;\
        top: -5px;\
    }\
", "");
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/lib/dom", "ace/lib/event", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config"], function(require, exports, module) {
      "use strict";
      require("./lib/fixoldbrowsers");
      var dom = require("./lib/dom");
      var event = require("./lib/event");
      var Editor = require("./editor").Editor;
      var EditSession = require("./edit_session").EditSession;
      var UndoManager = require("./undomanager").UndoManager;
      var Renderer = require("./virtual_renderer").VirtualRenderer;
      require("./worker/worker_client");
      require("./keyboard/hash_handler");
      require("./placeholder");
      require("./multi_select");
      require("./mode/folding/fold_mode");
      require("./theme/textmate");
      require("./ext/error_marker");
      exports.config = require("./config");
      exports.require = require;
      exports.edit = function(el) {
        if (typeof el == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el)
            throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor)
          return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
          value = dom.getInnerText(el);
          el.innerHTML = "";
        }
        var doc = exports.createEditSession(value);
        var editor = new Editor(new Renderer(el));
        editor.setSession(doc);
        var env = {
          document: doc,
          editor: editor,
          onResize: editor.resize.bind(editor, null)
        };
        if (oldNode)
          env.textarea = oldNode;
        event.addListener(window, "resize", env.onResize);
        editor.on("destroy", function() {
          event.removeListener(window, "resize", env.onResize);
          env.editor.container.env = null;
        });
        editor.container.env = editor.env = env;
        return editor;
      };
      exports.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
      };
      exports.EditSession = EditSession;
      exports.UndoManager = UndoManager;
      exports.version = "1.2.3";
    });
    (function() {
      ace.require(["ace/ace"], function(a) {
        a && a.config.init(true);
        if (!window.ace)
          window.ace = a;
        for (var key in a)
          if (a.hasOwnProperty(key))
            window.ace[key] = a[key];
      });
    })();
  })();
  return _retrieveGlobal();
});

System.registerDynamic("github:ajaxorg/ace-builds@1.2.3", ["github:ajaxorg/ace-builds@1.2.3/ace"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("github:ajaxorg/ace-builds@1.2.3/ace");
  global.define = __define;
  return module.exports;
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-framework@1.0.0-beta.1.0.8/aurelia-framework", ["exports", "npm:core-js@1.2.6", "npm:aurelia-logging@1.0.0-beta.1.1.1", "npm:aurelia-templating@1.0.0-beta.1.0.3", "npm:aurelia-path@1.0.0-beta.1", "npm:aurelia-dependency-injection@1.0.0-beta.1.0.1", "npm:aurelia-loader@1.0.0-beta.1.0.1", "npm:aurelia-pal@1.0.0-beta.1.0.2", "npm:aurelia-binding@1.0.0-beta.1.0.5", "npm:aurelia-metadata@1.0.0-beta.1", "npm:aurelia-task-queue@1.0.0-beta.1.0.1"], function(exports, _coreJs, _aureliaLogging, _aureliaTemplating, _aureliaPath, _aureliaDependencyInjection, _aureliaLoader, _aureliaPal, _aureliaBinding, _aureliaMetadata, _aureliaTaskQueue) {
  'use strict';
  exports.__esModule = true;
  function _interopExportWildcard(obj, defaults) {
    var newObj = defaults({}, obj);
    delete newObj['default'];
    return newObj;
  }
  function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var value = Object.getOwnPropertyDescriptor(defaults, key);
      if (value && value.configurable && obj[key] === undefined) {
        Object.defineProperty(obj, key, value);
      }
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  var logger = _aureliaLogging.getLogger('aurelia');
  function runTasks(config, tasks) {
    var current = undefined;
    var next = function next() {
      if (current = tasks.shift()) {
        return Promise.resolve(current(config)).then(next);
      }
      return Promise.resolve();
    };
    return next();
  }
  function loadPlugin(config, loader, info) {
    logger.debug('Loading plugin ' + info.moduleId + '.');
    config.resourcesRelativeTo = info.resourcesRelativeTo;
    return loader.loadModule(info.moduleId).then(function(m) {
      if ('configure' in m) {
        return Promise.resolve(m.configure(config, info.config || {})).then(function() {
          config.resourcesRelativeTo = null;
          logger.debug('Configured plugin ' + info.moduleId + '.');
        });
      }
      config.resourcesRelativeTo = null;
      logger.debug('Loaded plugin ' + info.moduleId + '.');
    });
  }
  function loadResources(container, resourcesToLoad, appResources) {
    var viewEngine = container.get(_aureliaTemplating.ViewEngine);
    var importIds = Object.keys(resourcesToLoad);
    var names = new Array(importIds.length);
    for (var i = 0,
        ii = importIds.length; i < ii; ++i) {
      names[i] = resourcesToLoad[importIds[i]];
    }
    return viewEngine.importViewResources(importIds, names, appResources);
  }
  function assertProcessed(plugins) {
    if (plugins.processed) {
      throw new Error('This config instance has already been applied. To load more plugins or global resources, create a new FrameworkConfiguration instance.');
    }
  }
  var FrameworkConfiguration = (function() {
    function FrameworkConfiguration(aurelia) {
      var _this = this;
      _classCallCheck(this, FrameworkConfiguration);
      this.aurelia = aurelia;
      this.container = aurelia.container;
      this.info = [];
      this.processed = false;
      this.preTasks = [];
      this.postTasks = [];
      this.resourcesToLoad = {};
      this.preTask(function() {
        return aurelia.loader.normalize('aurelia-bootstrapper').then(function(name) {
          return _this.bootstrapperName = name;
        });
      });
      this.postTask(function() {
        return loadResources(aurelia.container, _this.resourcesToLoad, aurelia.resources);
      });
    }
    FrameworkConfiguration.prototype.instance = function instance(type, _instance) {
      this.container.registerInstance(type, _instance);
      return this;
    };
    FrameworkConfiguration.prototype.singleton = function singleton(type, implementation) {
      this.container.registerSingleton(type, implementation);
      return this;
    };
    FrameworkConfiguration.prototype.transient = function transient(type, implementation) {
      this.container.registerTransient(type, implementation);
      return this;
    };
    FrameworkConfiguration.prototype.preTask = function preTask(task) {
      assertProcessed(this);
      this.preTasks.push(task);
      return this;
    };
    FrameworkConfiguration.prototype.postTask = function postTask(task) {
      assertProcessed(this);
      this.postTasks.push(task);
      return this;
    };
    FrameworkConfiguration.prototype.feature = function feature(plugin, config) {
      plugin = plugin.endsWith('.js') || plugin.endsWith('.ts') ? plugin.substring(0, plugin.length - 3) : plugin;
      return this.plugin({
        moduleId: plugin + '/index',
        resourcesRelativeTo: plugin,
        config: config || {}
      });
    };
    FrameworkConfiguration.prototype.globalResources = function globalResources(resources) {
      assertProcessed(this);
      var toAdd = Array.isArray(resources) ? resources : arguments;
      var resource = undefined;
      var path = undefined;
      var resourcesRelativeTo = this.resourcesRelativeTo || '';
      for (var i = 0,
          ii = toAdd.length; i < ii; ++i) {
        resource = toAdd[i];
        if (typeof resource !== 'string') {
          throw new Error('Invalid resource path [' + resource + ']. Resources must be specified as relative module IDs.');
        }
        path = _aureliaPath.join(resourcesRelativeTo, resource);
        this.resourcesToLoad[path] = this.resourcesToLoad[path];
      }
      return this;
    };
    FrameworkConfiguration.prototype.globalName = function globalName(resourcePath, newName) {
      assertProcessed(this);
      this.resourcesToLoad[resourcePath] = newName;
      return this;
    };
    FrameworkConfiguration.prototype.plugin = function plugin(_plugin, config) {
      assertProcessed(this);
      if (typeof _plugin === 'string') {
        _plugin = _plugin.endsWith('.js') || _plugin.endsWith('.ts') ? _plugin.substring(0, _plugin.length - 3) : _plugin;
        return this.plugin({
          moduleId: _plugin,
          resourcesRelativeTo: _plugin,
          config: config || {}
        });
      }
      this.info.push(_plugin);
      return this;
    };
    FrameworkConfiguration.prototype._addNormalizedPlugin = function _addNormalizedPlugin(name, config) {
      var _this2 = this;
      var plugin = {
        moduleId: name,
        resourcesRelativeTo: name,
        config: config || {}
      };
      this.plugin(plugin);
      this.preTask(function() {
        return _this2.aurelia.loader.normalize(name, _this2.bootstrapperName).then(function(normalizedName) {
          normalizedName = normalizedName.endsWith('.js') || normalizedName.endsWith('.ts') ? normalizedName.substring(0, normalizedName.length - 3) : normalizedName;
          plugin.moduleId = normalizedName;
          plugin.resourcesRelativeTo = normalizedName;
          _this2.aurelia.loader.map(name, normalizedName);
        });
      });
      return this;
    };
    FrameworkConfiguration.prototype.defaultBindingLanguage = function defaultBindingLanguage() {
      return this._addNormalizedPlugin('aurelia-templating-binding');
    };
    FrameworkConfiguration.prototype.router = function router() {
      return this._addNormalizedPlugin('aurelia-templating-router');
    };
    FrameworkConfiguration.prototype.history = function history() {
      return this._addNormalizedPlugin('aurelia-history-browser');
    };
    FrameworkConfiguration.prototype.defaultResources = function defaultResources() {
      return this._addNormalizedPlugin('aurelia-templating-resources');
    };
    FrameworkConfiguration.prototype.eventAggregator = function eventAggregator() {
      return this._addNormalizedPlugin('aurelia-event-aggregator');
    };
    FrameworkConfiguration.prototype.standardConfiguration = function standardConfiguration() {
      return this.defaultBindingLanguage().defaultResources().history().router().eventAggregator();
    };
    FrameworkConfiguration.prototype.developmentLogging = function developmentLogging() {
      var _this3 = this;
      this.preTask(function() {
        return _this3.aurelia.loader.normalize('aurelia-logging-console', _this3.bootstrapperName).then(function(name) {
          return _this3.aurelia.loader.loadModule(name).then(function(m) {
            _aureliaLogging.addAppender(new m.ConsoleAppender());
            _aureliaLogging.setLevel(_aureliaLogging.logLevel.debug);
          });
        });
      });
      return this;
    };
    FrameworkConfiguration.prototype.apply = function apply() {
      var _this4 = this;
      if (this.processed) {
        return Promise.resolve();
      }
      return runTasks(this, this.preTasks).then(function() {
        var loader = _this4.aurelia.loader;
        var info = _this4.info;
        var current = undefined;
        var next = function next() {
          if (current = info.shift()) {
            return loadPlugin(_this4, loader, current).then(next);
          }
          _this4.processed = true;
          return Promise.resolve();
        };
        return next().then(function() {
          return runTasks(_this4, _this4.postTasks);
        });
      });
    };
    return FrameworkConfiguration;
  })();
  exports.FrameworkConfiguration = FrameworkConfiguration;
  function preventActionlessFormSubmit() {
    _aureliaPal.DOM.addEventListener('submit', function(evt) {
      var target = evt.target;
      var action = target.action;
      if (target.tagName.toLowerCase() === 'form' && !action) {
        evt.preventDefault();
      }
    });
  }
  var Aurelia = (function() {
    function Aurelia(loader, container, resources) {
      _classCallCheck(this, Aurelia);
      this.loader = loader || new _aureliaPal.PLATFORM.Loader();
      this.container = container || new _aureliaDependencyInjection.Container().makeGlobal();
      this.resources = resources || new _aureliaTemplating.ViewResources();
      this.use = new FrameworkConfiguration(this);
      this.logger = _aureliaLogging.getLogger('aurelia');
      this.hostConfigured = false;
      this.host = null;
      this.use.instance(Aurelia, this);
      this.use.instance(_aureliaLoader.Loader, this.loader);
      this.use.instance(_aureliaTemplating.ViewResources, this.resources);
    }
    Aurelia.prototype.start = function start() {
      var _this5 = this;
      if (this.started) {
        return Promise.resolve(this);
      }
      this.started = true;
      this.logger.info('Aurelia Starting');
      return this.use.apply().then(function() {
        preventActionlessFormSubmit();
        if (!_this5.container.hasResolver(_aureliaTemplating.BindingLanguage)) {
          var message = 'You must configure Aurelia with a BindingLanguage implementation.';
          _this5.logger.error(message);
          throw new Error(message);
        }
        _this5.logger.info('Aurelia Started');
        var evt = _aureliaPal.DOM.createCustomEvent('aurelia-started', {
          bubbles: true,
          cancelable: true
        });
        _aureliaPal.DOM.dispatchEvent(evt);
        return _this5;
      });
    };
    Aurelia.prototype.enhance = function enhance() {
      var _this6 = this;
      var bindingContext = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
      var applicationHost = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      this._configureHost(applicationHost);
      return new Promise(function(resolve) {
        var engine = _this6.container.get(_aureliaTemplating.TemplatingEngine);
        _this6.root = engine.enhance({
          container: _this6.container,
          element: _this6.host,
          resources: _this6.resources,
          bindingContext: bindingContext
        });
        _this6.root.attached();
        _this6._onAureliaComposed();
        return _this6;
      });
    };
    Aurelia.prototype.setRoot = function setRoot() {
      var _this7 = this;
      var root = arguments.length <= 0 || arguments[0] === undefined ? 'app' : arguments[0];
      var applicationHost = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
      var engine = undefined;
      var instruction = {};
      if (this.root && this.root.viewModel && this.root.viewModel.router) {
        this.root.viewModel.router.deactivate();
        this.root.viewModel.router.reset();
      }
      this._configureHost(applicationHost);
      engine = this.container.get(_aureliaTemplating.TemplatingEngine);
      instruction.viewModel = root;
      instruction.container = instruction.childContainer = this.container;
      instruction.viewSlot = this.hostSlot;
      instruction.host = this.host;
      return engine.compose(instruction).then(function(r) {
        _this7.root = r;
        instruction.viewSlot.attached();
        _this7._onAureliaComposed();
        return _this7;
      });
    };
    Aurelia.prototype._configureHost = function _configureHost(applicationHost) {
      if (this.hostConfigured) {
        return;
      }
      applicationHost = applicationHost || this.host;
      if (!applicationHost || typeof applicationHost === 'string') {
        this.host = _aureliaPal.DOM.getElementById(applicationHost || 'applicationHost');
      } else {
        this.host = applicationHost;
      }
      if (!this.host) {
        throw new Error('No applicationHost was specified.');
      }
      this.hostConfigured = true;
      this.host.aurelia = this;
      this.hostSlot = new _aureliaTemplating.ViewSlot(this.host, true);
      this.hostSlot.transformChildNodesIntoView();
      this.container.registerInstance(_aureliaPal.DOM.boundary, this.host);
    };
    Aurelia.prototype._onAureliaComposed = function _onAureliaComposed() {
      var evt = _aureliaPal.DOM.createCustomEvent('aurelia-composed', {
        bubbles: true,
        cancelable: true
      });
      setTimeout(function() {
        return _aureliaPal.DOM.dispatchEvent(evt);
      }, 1);
    };
    return Aurelia;
  })();
  exports.Aurelia = Aurelia;
  _defaults(exports, _interopExportWildcard(_aureliaDependencyInjection, _defaults));
  _defaults(exports, _interopExportWildcard(_aureliaBinding, _defaults));
  _defaults(exports, _interopExportWildcard(_aureliaMetadata, _defaults));
  _defaults(exports, _interopExportWildcard(_aureliaTemplating, _defaults));
  _defaults(exports, _interopExportWildcard(_aureliaLoader, _defaults));
  _defaults(exports, _interopExportWildcard(_aureliaTaskQueue, _defaults));
  _defaults(exports, _interopExportWildcard(_aureliaPath, _defaults));
  _defaults(exports, _interopExportWildcard(_aureliaPal, _defaults));
  var LogManager = _aureliaLogging;
  exports.LogManager = LogManager;
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("npm:aurelia-framework@1.0.0-beta.1.0.8", ["npm:aurelia-framework@1.0.0-beta.1.0.8/aurelia-framework"], function(main) {
  return main;
});

_removeDefine();
})();
System.register("ui/ace-editor", ["github:ajaxorg/ace-builds@1.2.3", "npm:aurelia-framework@1.0.0-beta.1.0.8", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(_export) {
  'use strict';
  var ace,
      inject,
      inlineView,
      bindable,
      bindingMode,
      DOM,
      base,
      AceEditor;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_ace) {
      ace = _ace['default'];
    }, function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
      inlineView = _aureliaFramework.inlineView;
      bindable = _aureliaFramework.bindable;
      bindingMode = _aureliaFramework.bindingMode;
    }, function(_aureliaPal) {
      DOM = _aureliaPal.DOM;
    }],
    execute: function() {
      base = System.normalizeSync('ace');
      base = base.substr(0, base.length - 3);
      ace.config.set('basePath', base);
      AceEditor = (function() {
        function AceEditor(element) {
          _classCallCheck(this, _AceEditor);
          this.element = element;
          element.focus = this.focus.bind(this);
        }
        _createClass(AceEditor, [{
          key: 'themeChanged',
          value: function themeChanged() {
            if (this.editor) {
              this.editor.setTheme('ace/theme/' + this.theme);
            }
          }
        }, {
          key: 'modeChanged',
          value: function modeChanged() {
            if (this.editor) {
              this.editor.getSession().setMode('ace/mode/' + this.mode);
            }
          }
        }, {
          key: 'resetUndo',
          value: function resetUndo() {
            this.editor.getSession().setUndoManager(new ace.UndoManager());
          }
        }, {
          key: 'valueChanged',
          value: function valueChanged() {
            if (this.editor && this.editor.getValue() !== this.value) {
              this.editor.setValue(this.value, -1);
              this.resetUndo();
            }
          }
        }, {
          key: 'resize',
          value: function resize() {
            if (this.editor) {
              this.editor.resize();
            }
          }
        }, {
          key: 'attached',
          value: function attached() {
            var _this = this;
            this.editor = ace.edit(this.element);
            this.editor.renderer.setPadding(5);
            this.editor.$blockScrolling = Infinity;
            this.editor.setOptions({
              showPrintMargin: false,
              showGutter: false,
              cursorStyle: 'slim',
              useSoftTabs: true,
              tabSize: 2,
              displayIndentGuides: false,
              showInvisibles: false
            });
            this.themeChanged();
            this.modeChanged();
            this.valueChanged();
            this.editor.getSession().on('change', function(e) {
              _this.value = _this.editor.getValue();
              var changeEvent = DOM.createCustomEvent('change', {
                bubbles: true,
                detail: _this.value
              });
              _this.element.dispatchEvent(changeEvent);
            });
          }
        }, {
          key: 'detached',
          value: function detached() {
            this.editor.getSession().off('change');
            this.editor.destroy();
            this.editor = null;
          }
        }, {
          key: 'focus',
          value: function focus() {
            if (this.editor) {
              this.editor.focus();
            }
          }
        }]);
        var _AceEditor = AceEditor;
        AceEditor = bindable({
          name: 'value',
          defaultValue: '',
          defaultBindingMode: bindingMode.twoWay
        })(AceEditor) || AceEditor;
        AceEditor = bindable({
          name: 'mode',
          defaultValue: 'javascript'
        })(AceEditor) || AceEditor;
        AceEditor = bindable({
          name: 'theme',
          defaultValue: 'chrome'
        })(AceEditor) || AceEditor;
        AceEditor = inlineView('<template></template>')(AceEditor) || AceEditor;
        AceEditor = inject(Element)(AceEditor) || AceEditor;
        return AceEditor;
      })();
      _export('AceEditor', AceEditor);
    }
  };
});

System.register("github/access-token", [], function(_export) {
  'use strict';
  var storageKey,
      AccessToken;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [],
    execute: function() {
      storageKey = 'github-oauth-token';
      AccessToken = (function() {
        function AccessToken() {
          _classCallCheck(this, AccessToken);
          this._token = null;
          var json = localStorage.getItem(storageKey);
          if (json) {
            this._token = JSON.parse(json);
          }
        }
        _createClass(AccessToken, [{
          key: 'setToken',
          value: function setToken(token) {
            this._token = token;
            if (token) {
              localStorage.setItem(storageKey, JSON.stringify(token));
            } else {
              localStorage.removeItem(storageKey);
            }
          }
        }, {
          key: 'value',
          get: function get() {
            return this._token ? this._token.access_token : null;
          }
        }, {
          key: 'scope',
          get: function get() {
            return this._token ? this._token.scope : null;
          }
        }]);
        return AccessToken;
      })();
      _export('AccessToken', AccessToken);
    }
  };
});

System.register("github/rate-limit", [], function(_export) {
  'use strict';
  var RateLimit;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [],
    execute: function() {
      RateLimit = (function() {
        function RateLimit() {
          _classCallCheck(this, RateLimit);
          this.limit = 99999;
          this.remaining = 99999;
          this.reset = null;
        }
        _createClass(RateLimit, [{
          key: 'readHeaders',
          value: function readHeaders(response) {
            this.limit = parseInt(response.headers.get('X-RateLimit-Limit'), 10), this.remaining = parseInt(response.headers.get('X-RateLimit-Remaining'), 10), this.reset = new Date(parseInt(response.headers.get('X-RateLimit-Reset'), 10) * 1000);
          }
        }]);
        return RateLimit;
      })();
      _export('RateLimit', RateLimit);
    }
  };
});

System.register("github/api-client", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "github/access-token", "github/rate-limit"], function(_export) {
  'use strict';
  var inject,
      AccessToken,
      RateLimit,
      base,
      ApiClient;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_accessToken) {
      AccessToken = _accessToken.AccessToken;
    }, function(_rateLimit) {
      RateLimit = _rateLimit.RateLimit;
    }],
    execute: function() {
      base = 'https://api.github.com';
      ApiClient = (function() {
        function ApiClient(accessToken, rateLimit) {
          _classCallCheck(this, _ApiClient);
          this.accessToken = accessToken;
          this.rateLimit = rateLimit;
        }
        _createClass(ApiClient, [{
          key: 'fetch',
          value: (function(_fetch) {
            function fetch(_x, _x2) {
              return _fetch.apply(this, arguments);
            }
            fetch.toString = function() {
              return _fetch.toString();
            };
            return fetch;
          })(function(path, init) {
            var _this = this;
            var url = base + '/' + path;
            init = init || {};
            init.headers = init.headers || {};
            if (this.accessToken.value) {
              init.headers.Authorization = 'token ' + this.accessToken.value;
            }
            return fetch(url, init).then(function(response) {
              _this.rateLimit.readHeaders(response);
              return response;
            });
          })
        }]);
        var _ApiClient = ApiClient;
        ApiClient = inject(AccessToken, RateLimit)(ApiClient) || ApiClient;
        return ApiClient;
      })();
      _export('ApiClient', ApiClient);
    }
  };
});

System.register("util", [], function(_export) {
  'use strict';
  var contentTypeMap;
  _export('deparam', deparam);
  _export('param', param);
  _export('stringComparisonOrdinalIgnoreCase', stringComparisonOrdinalIgnoreCase);
  _export('getExtension', getExtension);
  _export('getContentType', getContentType);
  _export('copyTextToClipboard', copyTextToClipboard);
  function deparam(query) {
    var match = undefined,
        plus = /\+/g,
        search = /([^&=]+)=?([^&]*)/g,
        decode = function decode(s) {
          return decodeURIComponent(s.replace(plus, ' '));
        },
        params = {};
    while (match = search.exec(query)) {
      params[decode(match[1])] = decode(match[2]);
    }
    return params;
  }
  function param(obj) {
    var parts = [];
    for (var name in obj) {
      if (obj.hasOwnProperty(name)) {
        parts.push(encodeURIComponent(name) + '=' + encodeURIComponent(obj[name]));
      }
    }
    return parts.join('&');
  }
  function stringComparisonOrdinalIgnoreCase(a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    if (a > b) {
      return 1;
    }
    if (a < b) {
      return -1;
    }
    return 0;
  }
  function getExtension(name) {
    var parts = name.split('.');
    var extension = undefined;
    if (parts.length === 1) {
      return '';
    }
    return parts[parts.length - 1];
  }
  function getContentType(name) {
    var extension = getExtension(name);
    if (extension === '') {
      return 'text/plain';
    }
    return contentTypeMap[extension] || 'text/plain';
  }
  function copyTextToClipboard(text) {
    var textArea = document.createElement("textarea");
    textArea.style.position = 'fixed';
    textArea.style.top = 0;
    textArea.style.left = 0;
    textArea.style.width = '2em';
    textArea.style.height = '2em';
    textArea.style.padding = 0;
    textArea.style.border = 'none';
    textArea.style.outline = 'none';
    textArea.style.boxShadow = 'none';
    textArea.style.background = 'transparent';
    textArea.value = text;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      var successful = document.execCommand('copy');
      var msg = successful ? 'successful' : 'unsuccessful';
      console.log('Copying text command was ' + msg);
    } catch (err) {
      console.log('Oops, unable to copy');
    }
    document.body.removeChild(textArea);
  }
  return {
    setters: [],
    execute: function() {
      contentTypeMap = {
        css: 'text/css',
        js: 'application/javascript',
        json: 'application/json',
        html: 'text/html'
      };
    }
  };
});

System.register("github/gists", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "github/api-client", "util"], function(_export) {
  'use strict';
  var inject,
      ApiClient,
      param,
      deparam,
      Gists;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_apiClient) {
      ApiClient = _apiClient.ApiClient;
    }, function(_util) {
      param = _util.param;
      deparam = _util.deparam;
    }],
    execute: function() {
      Gists = (function() {
        function Gists(api) {
          _classCallCheck(this, _Gists);
          this.api = api;
        }
        _createClass(Gists, [{
          key: 'load',
          value: function load(id, sha) {
            var url = undefined;
            if (sha) {
              url = 'gists/' + id + '/' + sha;
            } else {
              url = 'gists/' + id;
            }
            return this.api.fetch(url).then(function(response) {
              if (response.ok) {
                return response.json();
              }
              if (response.status === 404) {
                return Promise.reject('Gist not found.');
              }
              return Promise.reject('Error loading Gist.');
            });
          }
        }, {
          key: 'update',
          value: function update(id, gist) {
            var init = {
              method: 'PATCH',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(gist)
            };
            return this.api.fetch('gists/' + id, init).then(function(response) {
              if (response.ok) {
                return response.json();
              }
              throw new Error('unable to patch gist');
            });
          }
        }, {
          key: 'create',
          value: function create(gist) {
            var init = {
              method: 'POST',
              headers: {'Content-Type': 'application/json'},
              body: JSON.stringify(gist)
            };
            return this.api.fetch('gists', init).then(function(response) {
              if (response.ok) {
                return response.json();
              }
              throw new Error('unable to create gist');
            });
          }
        }, {
          key: 'fork',
          value: function fork(id) {
            var _this = this;
            return this.api.fetch('gists/' + id + '/forks', {method: 'POST'}).then(function(response) {
              if (response.ok) {
                return response.json();
              }
              throw new Error('unable to fork gist');
            }).then(function(fork) {
              return _this.load(fork.id);
            });
          }
        }]);
        var _Gists = Gists;
        Gists = inject(ApiClient)(Gists) || Gists;
        return Gists;
      })();
      _export('Gists', Gists);
    }
  };
});

System.register("config", [], function(_export) {
  'use strict';
  var isDev,
      workerOrigin,
      workerPage,
      authorizationCodeUri,
      accessTokenUri,
      redirect_uri,
      client_id;
  return {
    setters: [],
    execute: function() {
      isDev = /^http:\/\/localhost/.test(location.origin);
      workerOrigin = isDev ? 'http://localhost:3000' : 'https://gist.host';
      _export('workerOrigin', workerOrigin);
      workerPage = workerOrigin + '/';
      _export('workerPage', workerPage);
      authorizationCodeUri = 'https://github.com/login/oauth/authorize';
      _export('authorizationCodeUri', authorizationCodeUri);
      accessTokenUri = 'https://gist-run-auth.herokuapp.com/access-token';
      _export('accessTokenUri', accessTokenUri);
      redirect_uri = 'https://gist.run/redirect-target.html';
      _export('redirect_uri', redirect_uri);
      client_id = '13b6e534ab9bc9953506';
      _export('client_id', client_id);
    }
  };
});

System.register("github/oauth", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "util", "github/access-token", "config"], function(_export) {
  'use strict';
  var inject,
      param,
      deparam,
      AccessToken,
      authorizationCodeUri,
      accessTokenUri,
      redirect_uri,
      client_id,
      OAuth;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function popup(url) {
    var resolve = null;
    window.resolveOpenWindow = function(query) {
      window.resolveOpenWindow = null;
      resolve(deparam(query));
    };
    var promise = new Promise(function(r) {
      return resolve = r;
    });
    window.open(url);
    return promise;
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_util) {
      param = _util.param;
      deparam = _util.deparam;
    }, function(_accessToken) {
      AccessToken = _accessToken.AccessToken;
    }, function(_config) {
      authorizationCodeUri = _config.authorizationCodeUri;
      accessTokenUri = _config.accessTokenUri;
      redirect_uri = _config.redirect_uri;
      client_id = _config.client_id;
    }],
    execute: function() {
      OAuth = (function() {
        function OAuth(accessToken) {
          _classCallCheck(this, _OAuth);
          this.accessToken = accessToken;
        }
        _createClass(OAuth, [{
          key: 'requestAuthorizationCode',
          value: function requestAuthorizationCode() {
            var args = {
              client_id: client_id,
              redirect_uri: redirect_uri,
              scope: 'gist',
              state: Math.floor(Math.random() * 100000).toString()
            };
            var url = authorizationCodeUri + '?' + param(args);
            return popup(url).then(function(result) {
              if (!(result.code && result.state)) {
                throw new Error('Redirect did not include code and state parameters.');
              }
              if (result.state !== args.state) {
                throw new Error('State mismatch.');
              }
              return result;
            });
          }
        }, {
          key: 'requestAccessToken',
          value: function requestAccessToken(_ref) {
            var code = _ref.code;
            var state = _ref.state;
            var args = {
              code: code,
              state: state
            };
            var url = accessTokenUri + '?' + param(args);
            return fetch(url).then(function(response) {
              return response.text();
            }).then(function(body) {
              return deparam(body);
            });
          }
        }, {
          key: 'login',
          value: function login() {
            var _this = this;
            return this.requestAuthorizationCode().then(this.requestAccessToken.bind(this)).then(function(token) {
              return _this.accessToken.setToken(token);
            })['catch'](function(reason) {
              _this.accessToken.setToken(null);
              throw reason;
            });
          }
        }]);
        var _OAuth = OAuth;
        OAuth = inject(AccessToken)(OAuth) || OAuth;
        return OAuth;
      })();
      _export('OAuth', OAuth);
    }
  };
});

System.register("github/user", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "github/access-token", "github/api-client", "github/oauth"], function(_export) {
  'use strict';
  var inject,
      AccessToken,
      ApiClient,
      OAuth,
      User;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_accessToken) {
      AccessToken = _accessToken.AccessToken;
    }, function(_apiClient) {
      ApiClient = _apiClient.ApiClient;
    }, function(_githubOauth) {
      OAuth = _githubOauth.OAuth;
    }],
    execute: function() {
      User = (function() {
        function User(accessToken, api, oauth) {
          _classCallCheck(this, _User);
          this.loading = false;
          this.accessToken = accessToken;
          this.api = api;
          this.oauth = oauth;
          this.load();
        }
        _createClass(User, [{
          key: 'setAnonymous',
          value: function setAnonymous() {
            this.authenticated = false;
            this.login = null;
            this.gists_url = null;
            this.avatar_url = null;
          }
        }, {
          key: 'load',
          value: function load() {
            var _this = this;
            if (this.accessToken.value) {
              this.loading = true;
              return this.api.fetch('user').then(function(response) {
                if (response.ok) {
                  return response.json();
                }
                return null;
              }).then(function(user) {
                if (user) {
                  _this.authenticated = true;
                  _this.login = user.login;
                  _this.gists_url = user.gists_url;
                  _this.avatar_url = user.avatar_url;
                } else {
                  _this.setAnonymous();
                }
              })['catch']().then(function() {
                return _this.loading = false;
              });
            }
            this.setAnonymous();
            return Promise.resolve(null);
          }
        }, {
          key: 'signIn',
          value: function signIn() {
            var _this2 = this;
            this.loading = true;
            this.oauth.login().then(function() {
              return _this2.load();
            })['catch']().then(function() {
              return _this2.loading = false;
            });
          }
        }]);
        var _User = User;
        User = inject(AccessToken, ApiClient, OAuth)(User) || User;
        return User;
      })();
      _export('User', User);
    }
  };
});

System.register("github/default-gist", [], function(_export) {
  'use strict';
  var defaultGist,
      defaultIndexHtml;
  return {
    setters: [],
    execute: function() {
      defaultGist = {
        description: '',
        files: {
          'index.html': {
            type: 'text/html',
            content: '<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>GistRun</title>\n  <link rel="stylesheet" href="styles.css">\n</head>\n<body>\n  <h1>Hello world!</h1>\n  <script src="script.js"></script>\n</body>\n</html>'
          },
          'script.js': {
            type: 'application/javascript',
            content: 'console.log(\'Hello World!\');'
          },
          'styles.css': {
            contentType: 'text/css',
            content: '/* todo: add styles */'
          }
        }
      };
      _export('defaultGist', defaultGist);
      defaultIndexHtml = '<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>GistRun</title>\n  <!--<link rel="stylesheet" href="styles.css">-->\n</head>\n<body>\n  <h1>Hello world!</h1>\n  <!--<script src="script.js"></script>-->\n</body>\n</html>';
      _export('defaultIndexHtml', defaultIndexHtml);
    }
  };
});

System.registerDynamic("github:ajaxorg/ace-builds@1.2.3/ext-modelist", [], false, function(__require, __exports, __module) {
  var _retrieveGlobal = System.get("@@global-helpers").prepareGlobal(__module.id, null, null);
  (function() {
    "format global";
    ace.define("ace/ext/modelist", ["require", "exports", "module"], function(require, exports, module) {
      "use strict";
      var modes = [];
      function getModeForPath(path) {
        var mode = modesByName.text;
        var fileName = path.split(/[\/\\]/).pop();
        for (var i = 0; i < modes.length; i++) {
          if (modes[i].supportsFile(fileName)) {
            mode = modes[i];
            break;
          }
        }
        return mode;
      }
      var Mode = function(name, caption, extensions) {
        this.name = name;
        this.caption = caption;
        this.mode = "ace/mode/" + name;
        this.extensions = extensions;
        var re;
        if (/\^/.test(extensions)) {
          re = extensions.replace(/\|(\^)?/g, function(a, b) {
            return "$|" + (b ? "^" : "^.*\\.");
          }) + "$";
        } else {
          re = "^.*\\.(" + extensions + ")$";
        }
        this.extRe = new RegExp(re, "gi");
      };
      Mode.prototype.supportsFile = function(filename) {
        return filename.match(this.extRe);
      };
      var supportedModes = {
        ABAP: ["abap"],
        ABC: ["abc"],
        ActionScript: ["as"],
        ADA: ["ada|adb"],
        Apache_Conf: ["^htaccess|^htgroups|^htpasswd|^conf|htaccess|htgroups|htpasswd"],
        AsciiDoc: ["asciidoc|adoc"],
        Assembly_x86: ["asm|a"],
        AutoHotKey: ["ahk"],
        BatchFile: ["bat|cmd"],
        C_Cpp: ["cpp|c|cc|cxx|h|hh|hpp|ino"],
        C9Search: ["c9search_results"],
        Cirru: ["cirru|cr"],
        Clojure: ["clj|cljs"],
        Cobol: ["CBL|COB"],
        coffee: ["coffee|cf|cson|^Cakefile"],
        ColdFusion: ["cfm"],
        CSharp: ["cs"],
        CSS: ["css"],
        Curly: ["curly"],
        D: ["d|di"],
        Dart: ["dart"],
        Diff: ["diff|patch"],
        Dockerfile: ["^Dockerfile"],
        Dot: ["dot"],
        Dummy: ["dummy"],
        DummySyntax: ["dummy"],
        Eiffel: ["e|ge"],
        EJS: ["ejs"],
        Elixir: ["ex|exs"],
        Elm: ["elm"],
        Erlang: ["erl|hrl"],
        Forth: ["frt|fs|ldr"],
        FTL: ["ftl"],
        Gcode: ["gcode"],
        Gherkin: ["feature"],
        Gitignore: ["^.gitignore"],
        Glsl: ["glsl|frag|vert"],
        Gobstones: ["gbs"],
        golang: ["go"],
        Groovy: ["groovy"],
        HAML: ["haml"],
        Handlebars: ["hbs|handlebars|tpl|mustache"],
        Haskell: ["hs"],
        haXe: ["hx"],
        HTML: ["html|htm|xhtml"],
        HTML_Elixir: ["eex|html.eex"],
        HTML_Ruby: ["erb|rhtml|html.erb"],
        INI: ["ini|conf|cfg|prefs"],
        Io: ["io"],
        Jack: ["jack"],
        Jade: ["jade"],
        Java: ["java"],
        JavaScript: ["js|jsm|jsx"],
        JSON: ["json"],
        JSONiq: ["jq"],
        JSP: ["jsp"],
        JSX: ["jsx"],
        Julia: ["jl"],
        LaTeX: ["tex|latex|ltx|bib"],
        Lean: ["lean|hlean"],
        LESS: ["less"],
        Liquid: ["liquid"],
        Lisp: ["lisp"],
        LiveScript: ["ls"],
        LogiQL: ["logic|lql"],
        LSL: ["lsl"],
        Lua: ["lua"],
        LuaPage: ["lp"],
        Lucene: ["lucene"],
        Makefile: ["^Makefile|^GNUmakefile|^makefile|^OCamlMakefile|make"],
        Markdown: ["md|markdown"],
        Mask: ["mask"],
        MATLAB: ["matlab"],
        Maze: ["mz"],
        MEL: ["mel"],
        MUSHCode: ["mc|mush"],
        MySQL: ["mysql"],
        Nix: ["nix"],
        NSIS: ["nsi|nsh"],
        ObjectiveC: ["m|mm"],
        OCaml: ["ml|mli"],
        Pascal: ["pas|p"],
        Perl: ["pl|pm"],
        pgSQL: ["pgsql"],
        PHP: ["php|phtml|shtml|php3|php4|php5|phps|phpt|aw|ctp|module"],
        Powershell: ["ps1"],
        Praat: ["praat|praatscript|psc|proc"],
        Prolog: ["plg|prolog"],
        Properties: ["properties"],
        Protobuf: ["proto"],
        Python: ["py"],
        R: ["r"],
        Razor: ["cshtml"],
        RDoc: ["Rd"],
        RHTML: ["Rhtml"],
        RST: ["rst"],
        Ruby: ["rb|ru|gemspec|rake|^Guardfile|^Rakefile|^Gemfile"],
        Rust: ["rs"],
        SASS: ["sass"],
        SCAD: ["scad"],
        Scala: ["scala"],
        Scheme: ["scm|sm|rkt|oak|scheme"],
        SCSS: ["scss"],
        SH: ["sh|bash|^.bashrc"],
        SJS: ["sjs"],
        Smarty: ["smarty|tpl"],
        snippets: ["snippets"],
        Soy_Template: ["soy"],
        Space: ["space"],
        SQL: ["sql"],
        SQLServer: ["sqlserver"],
        Stylus: ["styl|stylus"],
        SVG: ["svg"],
        Swift: ["swift"],
        Tcl: ["tcl"],
        Tex: ["tex"],
        Text: ["txt"],
        Textile: ["textile"],
        Toml: ["toml"],
        Twig: ["twig|swig"],
        Typescript: ["ts|typescript|str"],
        Vala: ["vala"],
        VBScript: ["vbs|vb"],
        Velocity: ["vm"],
        Verilog: ["v|vh|sv|svh"],
        VHDL: ["vhd|vhdl"],
        Wollok: ["wlk|wpgm|wtest"],
        XML: ["xml|rdf|rss|wsdl|xslt|atom|mathml|mml|xul|xbl|xaml"],
        XQuery: ["xq"],
        YAML: ["yaml|yml"],
        Django: ["html"]
      };
      var nameOverrides = {
        ObjectiveC: "Objective-C",
        CSharp: "C#",
        golang: "Go",
        C_Cpp: "C and C++",
        coffee: "CoffeeScript",
        HTML_Ruby: "HTML (Ruby)",
        HTML_Elixir: "HTML (Elixir)",
        FTL: "FreeMarker"
      };
      var modesByName = {};
      for (var name in supportedModes) {
        var data = supportedModes[name];
        var displayName = (nameOverrides[name] || name).replace(/_/g, " ");
        var filename = name.toLowerCase();
        var mode = new Mode(filename, displayName, data[0]);
        modesByName[filename] = mode;
        modes.push(mode);
      }
      module.exports = {
        getModeForPath: getModeForPath,
        modes: modes,
        modesByName: modesByName
      };
    });
    (function() {
      ace.require(["ace/ext/modelist"], function() {});
    })();
  })();
  return _retrieveGlobal();
});

System.register("editing/editor-mode", ["github:ajaxorg/ace-builds@1.2.3", "github:ajaxorg/ace-builds@1.2.3/ext-modelist"], function(_export) {
  'use strict';
  var ace,
      modelist;
  _export('getEditorMode', getEditorMode);
  function getEditorMode(name) {
    return modelist.getModeForPath(name).name;
  }
  return {
    setters: [function(_ace) {
      ace = _ace['default'];
    }, function(_aceExtModelist) {}],
    execute: function() {
      modelist = ace.require('ace/ext/modelist');
    }
  };
});

System.register("editing/file", ["util", "editing/editor-mode"], function(_export) {
  'use strict';
  var getContentType,
      getEditorMode,
      File;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_util) {
      getContentType = _util.getContentType;
    }, function(_editorMode) {
      getEditorMode = _editorMode.getEditorMode;
    }],
    execute: function() {
      File = (function() {
        function File(name) {
          var type = arguments.length <= 1 || arguments[1] === undefined ? getContentType(name) : arguments[1];
          var content = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];
          return (function() {
            _classCallCheck(this, File);
            this.name = name;
            this.originalName = name;
            this.type = type;
            this.content = content;
            this.editorMode = getEditorMode(name);
          }).apply(this, arguments);
        }
        _createClass(File, [{
          key: 'rename',
          value: function rename(name) {
            this.name = name;
            this.type = getContentType(name);
            this.editorMode = getEditorMode(name);
          }
        }, {
          key: 'clone',
          value: function clone() {
            return {
              name: this.name,
              type: this.type,
              content: this.content
            };
          }
        }]);
        return File;
      })();
      _export('File', File);
    }
  };
});

System.register("editing/gist-adapter", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "github/gists", "github/user", "github/default-gist", "editing/file"], function(_export) {
  'use strict';
  var inject,
      Gists,
      User,
      defaultIndexHtml,
      File,
      saveAction,
      GistAdapter;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function toFilename(name) {
    return name.replace(/\//g, '\\');
  }
  function toUrl(name) {
    return name.replace(/\\/g, '/');
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_githubGists) {
      Gists = _githubGists.Gists;
    }, function(_githubUser) {
      User = _githubUser.User;
    }, function(_githubDefaultGist) {
      defaultIndexHtml = _githubDefaultGist.defaultIndexHtml;
    }, function(_file) {
      File = _file.File;
    }],
    execute: function() {
      saveAction = {
        fork: 'Fork',
        create: 'Create',
        update: 'Update'
      };
      _export('saveAction', saveAction);
      GistAdapter = (function() {
        function GistAdapter(gists, user) {
          _classCallCheck(this, _GistAdapter);
          this.gists = gists;
          this.user = user;
        }
        _createClass(GistAdapter, [{
          key: 'filesMapToArray',
          value: function filesMapToArray(filesMap) {
            var files = [];
            for (var _name in filesMap) {
              var gistFile = filesMap[_name];
              var file = new File(toUrl(_name), gistFile.type, gistFile.content);
              files.push(file);
            }
            if (!files.find(function(f) {
              return f.name === 'index.html';
            })) {
              files.push(new File('index.html', 'text/html', defaultIndexHtml));
            }
            return files;
          }
        }, {
          key: 'getCreateFiles',
          value: function getCreateFiles(filesArray) {
            var files = filesArray.filter(function(f) {
              return f.content !== '';
            });
            var map = {};
            for (var i = 0; i < files.length; i++) {
              var file = files[i];
              var filename = toFilename(file.name);
              map[filename] = {content: file.content};
            }
            return map;
          }
        }, {
          key: 'getUpdateFiles',
          value: function getUpdateFiles(filesMap, filesArray) {
            var files = filesArray.filter(function(f) {
              return f.content !== '';
            });
            var map = {};
            var _loop = function(_name2) {
              var index = files.findIndex(function(f) {
                return f.originalName === _name2;
              });
              var filename = toFilename(_name2);
              if (index === -1) {
                map[filename] = null;
              } else {
                var file = files.splice(index, 1)[0];
                map[filename] = {content: file.content};
                if (file.name !== file.originalName) {
                  map[filename].filename = toFilename(file.name);
                }
              }
            };
            for (var _name2 in filesMap) {
              _loop(_name2);
            }
            for (var i = 0; i < files.length; i++) {
              var file = files[i];
              var filename = toFilename(file.name);
              if (map[filename]) {
                map[map[filename].filename] = {content: map[filename].content};
              }
              map[filename] = {content: file.content};
            }
            return map;
          }
        }, {
          key: 'getSaveAction',
          value: function getSaveAction(gist, forceFork) {
            var existingGist = !!gist.id;
            if (this.user.authenticated && existingGist && gist.owner) {
              if (gist.owner.login === this.user.login) {
                if (forceFork) {
                  return saveAction.create;
                }
                return saveAction.update;
              } else {
                return saveAction.fork;
              }
            } else {
              return saveAction.create;
            }
          }
        }, {
          key: 'save',
          value: function save(gist, filesArray, forceFork, secret) {
            var _this = this;
            var files = undefined;
            var description = gist.description;
            switch (this.getSaveAction(gist, forceFork)) {
              case saveAction.update:
                files = this.getUpdateFiles(gist.files, filesArray);
                return this.gists.update(gist.id, {
                  description: description,
                  files: files
                });
              case saveAction.fork:
                return this.gists.fork(gist.id).then(function(gist) {
                  files = _this.getUpdateFiles(gist.files, filesArray);
                  return _this.gists.update(gist.id, {
                    'public': !secret,
                    description: description,
                    files: files
                  });
                });
              case saveAction.create:
                files = this.getCreateFiles(filesArray);
                return this.gists.create({
                  'public': !secret,
                  description: description,
                  files: files
                });
              default:
                return Promise.reject('Unexpected save action.');
            }
          }
        }]);
        var _GistAdapter = GistAdapter;
        GistAdapter = inject(Gists, User)(GistAdapter) || GistAdapter;
        return GistAdapter;
      })();
      _export('GistAdapter', GistAdapter);
    }
  };
});

System.register("worker/worker-activator", ["config"], function(_export) {
  'use strict';
  var workerOrigin,
      workerPage,
      iframe,
      resolveWorkerPage,
      workerPageReady;
  _export('postMessageToWorker', postMessageToWorker);
  function handleMessage(event) {
    if (event.origin !== workerOrigin || event.data !== 'worker page ready') {
      return;
    }
    removeEventListener('message', handleMessage);
    resolveWorkerPage();
  }
  function postMessageToWorker(message, responsePort) {
    workerPageReady.then(function() {
      return iframe.contentWindow.postMessage(message, workerOrigin, [responsePort]);
    });
  }
  return {
    setters: [function(_config) {
      workerOrigin = _config.workerOrigin;
      workerPage = _config.workerPage;
    }],
    execute: function() {
      iframe = document.createElement('iframe');
      iframe.setAttribute('src', workerPage);
      iframe.setAttribute('style', 'display: none');
      document.body.appendChild(iframe);
      resolveWorkerPage = null;
      workerPageReady = new Promise(function(resolve) {
        return resolveWorkerPage = resolve;
      });
      addEventListener('message', handleMessage);
    }
  };
});

System.register("worker/worker-client", ["worker/worker-activator", "config"], function(_export) {
  'use strict';
  var postMessageToWorker,
      workerPage,
      clientID,
      runUrl,
      WorkerClient;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_workerActivator) {
      postMessageToWorker = _workerActivator.postMessageToWorker;
    }, function(_config) {
      workerPage = _config.workerPage;
    }],
    execute: function() {
      clientID = +new Date();
      runUrl = workerPage + 'run/' + clientID + '/index.html';
      _export('runUrl', runUrl);
      WorkerClient = (function() {
        function WorkerClient() {
          _classCallCheck(this, WorkerClient);
        }
        _createClass(WorkerClient, [{
          key: 'sendMessage',
          value: function sendMessage(message) {
            message.clientID = clientID;
            return new Promise(function(resolve, reject) {
              var channel = new MessageChannel();
              channel.port1.onmessage = function(event) {
                if (event.data.error) {
                  reject(event.data.error);
                  return;
                }
                resolve(event.data);
              };
              postMessageToWorker(message, channel.port2);
            });
          }
        }, {
          key: 'updateFile',
          value: function updateFile(file) {
            return this.sendMessage({
              action: 'updateFile',
              file: file
            });
          }
        }, {
          key: 'deleteFile',
          value: function deleteFile(file) {
            return this.sendMessage({
              action: 'deleteFile',
              file: file
            });
          }
        }, {
          key: 'resetFiles',
          value: function resetFiles(files) {
            return this.sendMessage({
              action: 'resetFiles',
              files: files
            });
          }
        }]);
        return WorkerClient;
      })();
      _export('WorkerClient', WorkerClient);
    }
  };
});

System.register("editing/run-event", ["npm:aurelia-event-aggregator@1.0.0-beta.1.1.1"], function(_export) {
  'use strict';
  var EventAggregator,
      bus,
      RunEvent;
  return {
    setters: [function(_aureliaEventAggregator) {
      EventAggregator = _aureliaEventAggregator.EventAggregator;
    }],
    execute: function() {
      bus = new EventAggregator();
      RunEvent = {
        publish: function publish() {
          return bus.publish('run');
        },
        subscribe: function subscribe(callback) {
          return bus.subscribe('run', callback);
        }
      };
      _export('RunEvent', RunEvent);
    }
  };
});

System.register("editing/current-file-changed-event", [], function(_export) {
  "use strict";
  var CurrentFileChangedEvent;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  return {
    setters: [],
    execute: function() {
      CurrentFileChangedEvent = function CurrentFileChangedEvent(file) {
        _classCallCheck(this, CurrentFileChangedEvent);
        this.file = file;
      };
      _export("CurrentFileChangedEvent", CurrentFileChangedEvent);
    }
  };
});

System.register("editing/edit-session", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "npm:aurelia-event-aggregator@1.0.0-beta.1.1.1", "editing/run-event", "editing/current-file-changed-event", "editing/file", "util"], function(_export) {
  'use strict';
  var computedFrom,
      includeEventsIn,
      RunEvent,
      CurrentFileChangedEvent,
      File,
      stringComparisonOrdinalIgnoreCase,
      EditSession;
  var _createDecoratedClass = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === 'function') {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        Object.defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      computedFrom = _aureliaFramework.computedFrom;
    }, function(_aureliaEventAggregator) {
      includeEventsIn = _aureliaEventAggregator.includeEventsIn;
    }, function(_runEvent) {
      RunEvent = _runEvent.RunEvent;
    }, function(_currentFileChangedEvent) {
      CurrentFileChangedEvent = _currentFileChangedEvent.CurrentFileChangedEvent;
    }, function(_file) {
      File = _file.File;
    }, function(_util) {
      stringComparisonOrdinalIgnoreCase = _util.stringComparisonOrdinalIgnoreCase;
    }],
    execute: function() {
      EditSession = (function() {
        function EditSession(gist, worker, gistAdapter, queryString) {
          _classCallCheck(this, EditSession);
          this._currentFile = null;
          includeEventsIn(this);
          this.gist = gist;
          this.worker = worker;
          this.gistAdapter = gistAdapter;
          this.queryString = queryString;
          this.autoRun = true;
          this.files = gistAdapter.filesMapToArray(gist.files);
          this.sortFiles();
          this._currentFile = this.files[0];
          this.dirty = false;
        }
        _createDecoratedClass(EditSession, [{
          key: 'sortFiles',
          value: function sortFiles() {
            this.files.sort(function(a, b) {
              return stringComparisonOrdinalIgnoreCase(a.name, b.name);
            });
          }
        }, {
          key: 'run',
          value: function run() {
            if (this.autoRun) {
              RunEvent.publish();
            }
          }
        }, {
          key: 'toggleAutoRun',
          value: function toggleAutoRun() {
            this.autoRun = !this.autoRun;
            if (this.autoRun) {
              this.run();
            }
          }
        }, {
          key: 'addFile',
          value: function addFile(name) {
            var file = new File(name);
            this.files.push(file);
            this.currentFile = file;
            this.worker.updateFile(file.clone()).then(this.run.bind(this));
          }
        }, {
          key: 'deleteFile',
          value: function deleteFile(file) {
            if (this.currentFile === file) {
              this.currentFile = this.files[0];
            }
            this.files.splice(this.files.indexOf(file), 1);
            this.worker.deleteFile(file.clone()).then(this.run.bind(this));
          }
        }, {
          key: 'renameFile',
          value: function renameFile(file, name) {
            var _this = this;
            this.worker.deleteFile(file.clone()).then(function() {
              return file.rename(name);
            }).then(function() {
              return _this.sortFiles();
            }).then(function() {
              return _this.worker.updateFile(file.clone());
            }).then(this.run.bind(this));
          }
        }, {
          key: 'updateFile',
          value: function updateFile(file, content) {
            if (file.content === content) {
              return;
            }
            file.content = content;
            this.dirty = true;
            this.worker.updateFile(file.clone()).then(this.run.bind(this));
          }
        }, {
          key: 'resetWorker',
          value: function resetWorker() {
            return this.worker.resetFiles(this.files.map(function(f) {
              return f.clone();
            })).then(this.run.bind(this));
          }
        }, {
          key: 'save',
          value: function save(forceFork, secret) {
            var _this2 = this;
            var selected = this.currentFile.name;
            return this.gistAdapter.save(this.gist, this.files, forceFork, secret).then(function(gist) {
              _this2.dirty = false;
              _this2.gist = gist;
              _this2.files = _this2.gistAdapter.filesMapToArray(gist.files);
              _this2.queryString.write(gist, false);
              return _this2.resetWorker();
            }).then(function() {
              return _this2.currentFile = _this2.files.find(function(f) {
                return f.name === selected;
              }) || _this2.files[0];
            });
          }
        }, {
          key: 'currentFile',
          decorators: [computedFrom('_currentFile')],
          get: function get() {
            return this._currentFile;
          },
          set: function set(file) {
            this._currentFile = file;
            this.publish(new CurrentFileChangedEvent(file));
          }
        }, {
          key: 'description',
          get: function get() {
            return this.gist.description;
          },
          set: function set(newValue) {
            this.gist.description = newValue;
          }
        }, {
          key: 'saveAction',
          get: function get() {
            return this.gistAdapter.getSaveAction(this.gist, false);
          }
        }]);
        return EditSession;
      })();
      _export('EditSession', EditSession);
    }
  };
});

System.register("editing/query-string", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "util", "github/gists", "github/default-gist"], function(_export) {
  'use strict';
  var inject,
      param,
      deparam,
      Gists,
      defaultGist,
      QueryString;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_util) {
      param = _util.param;
      deparam = _util.deparam;
    }, function(_githubGists) {
      Gists = _githubGists.Gists;
    }, function(_githubDefaultGist) {
      defaultGist = _githubDefaultGist.defaultGist;
    }],
    execute: function() {
      QueryString = (function() {
        function QueryString(gists) {
          _classCallCheck(this, _QueryString);
          this.gists = gists;
        }
        _createClass(QueryString, [{
          key: 'clear',
          value: function clear() {
            history.replaceState(null, document.title, '/');
          }
        }, {
          key: 'read',
          value: function read() {
            var _this = this;
            var query = location.search;
            if (query.length) {
              var args = deparam(query.substring(1));
              if (args.id) {
                return this.gists.load(args.id, args.sha)['catch'](function(reason) {
                  _this.clear();
                  return defaultGist;
                });
              } else {
                this.clear();
              }
            }
            return Promise.resolve(defaultGist);
          }
        }, {
          key: 'write',
          value: function write(gist, withSha) {
            if (!gist.id || !gist.history) {
              this.clear();
              return;
            }
            var query = undefined;
            if (withSha) {
              query = param({
                id: gist.id,
                sha: gist.history[0].version
              });
            } else {
              query = param({id: gist.id});
            }
            history.pushState(null, window.title, '?' + query);
          }
        }]);
        var _QueryString = QueryString;
        QueryString = inject(Gists)(QueryString) || QueryString;
        return QueryString;
      })();
      _export('QueryString', QueryString);
    }
  };
});

System.register("editing/edit-session-factory", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "editing/gist-adapter", "worker/worker-client", "editing/edit-session", "editing/query-string"], function(_export) {
  'use strict';
  var inject,
      GistAdapter,
      WorkerClient,
      EditSession,
      QueryString,
      EditSessionFactory;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_gistAdapter) {
      GistAdapter = _gistAdapter.GistAdapter;
    }, function(_workerWorkerClient) {
      WorkerClient = _workerWorkerClient.WorkerClient;
    }, function(_editSession) {
      EditSession = _editSession.EditSession;
    }, function(_queryString) {
      QueryString = _queryString.QueryString;
    }],
    execute: function() {
      EditSessionFactory = (function() {
        function EditSessionFactory(worker, gistAdapter, queryString) {
          _classCallCheck(this, _EditSessionFactory);
          this.worker = worker;
          this.gistAdapter = gistAdapter;
          this.queryString = queryString;
        }
        _createClass(EditSessionFactory, [{
          key: 'create',
          value: function create(gist) {
            var editSesson = new EditSession(gist, this.worker, this.gistAdapter, this.queryString);
            return editSesson.resetWorker().then(function() {
              return editSesson;
            });
          }
        }]);
        var _EditSessionFactory = EditSessionFactory;
        EditSessionFactory = inject(WorkerClient, GistAdapter, QueryString)(EditSessionFactory) || EditSessionFactory;
        return EditSessionFactory;
      })();
      _export('EditSessionFactory', EditSessionFactory);
    }
  };
});

System.register("import/gist", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "github/gists"], function(_export) {
  'use strict';
  var inject,
      Gists,
      gistUrlRegex,
      GistImporter;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_githubGists) {
      Gists = _githubGists.Gists;
    }],
    execute: function() {
      gistUrlRegex = /(?:^|\/)([\da-f]{20})(?:\/([\da-f]{40})){0,1}$/;
      GistImporter = (function() {
        function GistImporter(gists) {
          _classCallCheck(this, _GistImporter);
          this.gists = gists;
        }
        _createClass(GistImporter, [{
          key: 'canImport',
          value: function canImport(urlOrId) {
            return gistUrlRegex.test(urlOrId);
          }
        }, {
          key: 'import',
          value: function _import(urlOrId) {
            var match = gistUrlRegex.exec(urlOrId);
            var id = match[1];
            var sha = match[2];
            return this.gists.load(id, sha);
          }
        }]);
        var _GistImporter = GistImporter;
        GistImporter = inject(Gists)(GistImporter) || GistImporter;
        return GistImporter;
      })();
      _export('GistImporter', GistImporter);
    }
  };
});

System.register("import/jsfiddle", [], function(_export) {
  'use strict';
  var JSFiddleImporter;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [],
    execute: function() {
      JSFiddleImporter = (function() {
        function JSFiddleImporter() {
          _classCallCheck(this, JSFiddleImporter);
        }
        _createClass(JSFiddleImporter, [{
          key: 'fiddleHtmlToGist',
          value: function fiddleHtmlToGist(page) {
            var div = document.createElement('div');
            div.innerHTML = /<input id="id_title".*\/>/.exec(page)[0];
            var title = div.firstElementChild.value;
            div.innerHTML = /<textarea id="id_description".*<\/textarea>/.exec(page)[0];
            var description = div.firstElementChild.value;
            div.innerHTML = /<fieldset class="column left">(.|\n)*<\/fieldset>/.exec(page)[0];
            var html = div.querySelector('#id_code_html').value;
            var css = div.querySelector('#id_code_css').value;
            var js = div.querySelector('#id_code_js').value;
            return {
              description: (title + ' - ' + description).replace(/(^ - )|( - )$/, ''),
              files: {
                'index.html': {
                  type: 'text/html',
                  content: '<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>GistRun</title>\n  <link rel="stylesheet" href="styles.css">\n</head>\n<body>\n' + html + '\n  <script src="script.js"></script>\n</body>\n</html>'
                },
                'script.js': {
                  type: 'application/javascript',
                  content: js
                },
                'styles.css': {
                  contentType: 'text/css',
                  content: css
                }
              }
            };
          }
        }, {
          key: 'canImport',
          value: function canImport(urlOrId) {
            return (/^http(?:s)?:\/\/jsfiddle.net(?:\/[^\\]+)?\/[\da-z]+(\/\d+)?\/?$/.test(urlOrId));
          }
        }, {
          key: 'import',
          value: function _import(urlOrId) {
            var _this = this;
            return fetch('https://crossorigin.me/' + urlOrId).then(function(response) {
              if (response.ok) {
                return response.text();
              }
              if (response.status === 404) {
                return Promise.reject('jsFiddle not found.');
              }
              return Promise.reject('Error loading jsFiddle.');
            }).then(function(page) {
              return _this.fiddleHtmlToGist(page);
            });
          }
        }]);
        return JSFiddleImporter;
      })();
      _export('JSFiddleImporter', JSFiddleImporter);
    }
  };
});

System.register("import/plunker", [], function(_export) {
  'use strict';
  var urlRegex,
      PlunkerImporter;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [],
    execute: function() {
      urlRegex = /^http(?:s)?:\/\/(?:embed.)?plnkr.co\/(?:edit\/)?([\da-zA-Z]{6,})/;
      PlunkerImporter = (function() {
        function PlunkerImporter() {
          _classCallCheck(this, PlunkerImporter);
        }
        _createClass(PlunkerImporter, [{
          key: 'canImport',
          value: function canImport(urlOrId) {
            return urlRegex.test(urlOrId);
          }
        }, {
          key: 'import',
          value: function _import(urlOrId) {
            var plunkerID = urlRegex.exec(urlOrId)[1];
            return fetch('https://api.plnkr.co/plunks/' + plunkerID).then(function(response) {
              if (response.ok) {
                return response.json();
              }
              if (response.status === 404) {
                return Promise.reject('Plunk not found.');
              }
              return Promise.reject('Error loading plunk.');
            }).then(function(plunk) {
              var gist = {
                description: plunk.description,
                files: {}
              };
              for (var _name in plunk.files) {
                gist.files[_name] = {content: plunk.files[_name].content};
              }
              return gist;
            });
          }
        }]);
        return PlunkerImporter;
      })();
      _export('PlunkerImporter', PlunkerImporter);
    }
  };
});

System.register("import/importer", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "import/gist", "import/jsfiddle", "import/plunker"], function(_export) {
  'use strict';
  var inject,
      GistImporter,
      JSFiddleImporter,
      PlunkerImporter,
      Importer;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_gist) {
      GistImporter = _gist.GistImporter;
    }, function(_jsfiddle) {
      JSFiddleImporter = _jsfiddle.JSFiddleImporter;
    }, function(_plunker) {
      PlunkerImporter = _plunker.PlunkerImporter;
    }],
    execute: function() {
      Importer = (function() {
        function Importer() {
          _classCallCheck(this, _Importer);
          for (var _len = arguments.length,
              importers = Array(_len),
              _key = 0; _key < _len; _key++) {
            importers[_key] = arguments[_key];
          }
          this.importers = importers;
        }
        _createClass(Importer, [{
          key: 'import',
          value: function _import(urlOrId) {
            var importer = this.importers.find(function(x) {
              return x.canImport(urlOrId);
            });
            if (importer) {
              return importer['import'](urlOrId);
            }
            return Promise.reject('Unrecognized URL or ID');
          }
        }]);
        var _Importer = Importer;
        Importer = inject(GistImporter, JSFiddleImporter, PlunkerImporter)(Importer) || Importer;
        return Importer;
      })();
      _export('Importer', Importer);
    }
  };
});

System.register("ui/focus", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "npm:aurelia-event-aggregator@1.0.0-beta.1.1.1"], function(_export) {
  'use strict';
  var inject,
      EventAggregator,
      Focus,
      SetFocusEvent;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_aureliaEventAggregator) {
      EventAggregator = _aureliaEventAggregator.EventAggregator;
    }],
    execute: function() {
      Focus = (function() {
        function Focus(eventAggregator) {
          _classCallCheck(this, _Focus);
          this.eventAggregator = eventAggregator;
        }
        _createClass(Focus, [{
          key: 'set',
          value: function set(name) {
            var e = new SetFocusEvent(name);
            this.eventAggregator.publish(e);
            return e.handled;
          }
        }]);
        var _Focus = Focus;
        Focus = inject(EventAggregator)(Focus) || Focus;
        return Focus;
      })();
      _export('Focus', Focus);
      SetFocusEvent = function SetFocusEvent(name) {
        _classCallCheck(this, SetFocusEvent);
        this.name = name;
        this.handled = false;
      };
      _export('SetFocusEvent', SetFocusEvent);
    }
  };
});

System.registerDynamic("npm:alertify.js@1.0.9/dist/js/alertify", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  "format cjs";
  !function() {
    "use strict";
    function t() {
      var t = {
        version: "1.0.8",
        defaultOkLabel: "Ok",
        okLabel: "Ok",
        defaultCancelLabel: "Cancel",
        cancelLabel: "Cancel",
        defaultMaxLogItems: 2,
        maxLogItems: 2,
        promptValue: "",
        promptPlaceholder: "",
        closeLogOnClick: !1,
        closeLogOnClickDefault: !1,
        delay: 5e3,
        defaultDelay: 5e3,
        logContainerClass: "alertify-logs",
        logContainerDefaultClass: "alertify-logs",
        dialogs: {
          buttons: {
            holder: "<nav>{{buttons}}</nav>",
            ok: "<button class='ok' tabindex='1'>{{ok}}</button>",
            cancel: "<button class='cancel' tabindex='2'>{{cancel}}</button>"
          },
          input: "<input type='text'>",
          message: "<p class='msg'>{{message}}</p>",
          log: "<div class='{{class}}'>{{message}}</div>"
        },
        defaultDialogs: {
          buttons: {
            holder: "<nav>{{buttons}}</nav>",
            ok: "<button class='ok' tabindex='1'>{{ok}}</button>",
            cancel: "<button class='cancel' tabindex='2'>{{cancel}}</button>"
          },
          input: "<input type='text'>",
          message: "<p class='msg'>{{message}}</p>",
          log: "<div class='{{class}}'>{{message}}</div>"
        },
        build: function(t) {
          var e = this.dialogs.buttons.ok,
              o = "<div class='dialog'><div>" + this.dialogs.message.replace("{{message}}", t.message);
          return "confirm" !== t.type && "prompt" !== t.type || (e = this.dialogs.buttons.cancel + this.dialogs.buttons.ok), "prompt" === t.type && (o += this.dialogs.input), o = (o + this.dialogs.buttons.holder + "</div></div>").replace("{{buttons}}", e).replace("{{ok}}", this.okLabel).replace("{{cancel}}", this.cancelLabel);
        },
        setCloseLogOnClick: function(t) {
          this.closeLogOnClick = !!t;
        },
        close: function(t, e) {
          this.closeLogOnClick && t.addEventListener("click", function(t) {
            o(t.srcElement);
          }), e = e && !isNaN(+e) ? +e : this.delay, 0 > e ? o(t) : e > 0 && setTimeout(function() {
            o(t);
          }, e);
        },
        dialog: function(t, e, o, n) {
          return this.setup({
            type: e,
            message: t,
            onOkay: o,
            onCancel: n
          });
        },
        log: function(t, e, o) {
          var n = document.querySelectorAll(".alertify-logs > div");
          if (n) {
            var i = n.length - this.maxLogItems;
            if (i >= 0)
              for (var a = 0,
                  l = i + 1; l > a; a++)
                this.close(n[a], -1);
          }
          this.notify(t, e, o);
        },
        setLogPosition: function(t) {
          this.logContainerClass = "alertify-logs " + t;
        },
        setupLogContainer: function() {
          var t = document.querySelector(".alertify-logs"),
              e = this.logContainerClass;
          return t || (t = document.createElement("div"), t.className = e, document.body.appendChild(t)), t.className !== e && (t.className = e), t;
        },
        notify: function(e, o, n) {
          var i = this.setupLogContainer(),
              a = document.createElement("div");
          a.className = o || "default", t.logTemplateMethod ? a.innerHTML = t.logTemplateMethod(e) : a.innerHTML = e, "function" == typeof n && a.addEventListener("click", n), i.appendChild(a), setTimeout(function() {
            a.className += " show";
          }, 10), this.close(a, this.delay);
        },
        setup: function(t) {
          function e(e) {
            "function" != typeof e && (e = function() {}), i && i.addEventListener("click", function(i) {
              t.onOkay && "function" == typeof t.onOkay && (l ? t.onOkay(l.value, i) : t.onOkay(i)), e(l ? {
                buttonClicked: "ok",
                inputValue: l.value,
                event: i
              } : {
                buttonClicked: "ok",
                event: i
              }), o(n);
            }), a && a.addEventListener("click", function(i) {
              t.onCancel && "function" == typeof t.onCancel && t.onCancel(i), e({
                buttonClicked: "cancel",
                event: i
              }), o(n);
            });
          }
          var n = document.createElement("div");
          n.className = "alertify hide", n.innerHTML = this.build(t);
          var i = n.querySelector(".ok"),
              a = n.querySelector(".cancel"),
              l = n.querySelector("input"),
              s = n.querySelector("label");
          l && ("string" == typeof this.promptPlaceholder && (s ? s.textContent = this.promptPlaceholder : l.placeholder = this.promptPlaceholder), "string" == typeof this.promptValue && (l.value = this.promptValue));
          var r;
          return "function" == typeof Promise ? r = new Promise(e) : e(), document.body.appendChild(n), setTimeout(function() {
            n.classList.remove("hide"), l && t.type && "prompt" === t.type ? (l.select(), l.focus()) : i && i.focus();
          }, 100), r;
        },
        okBtn: function(t) {
          return this.okLabel = t, this;
        },
        setDelay: function(t) {
          var e = parseInt(t || 0, 10);
          return this.delay = isNaN(e) ? this.defultDelay : t, this;
        },
        cancelBtn: function(t) {
          return this.cancelLabel = t, this;
        },
        setMaxLogItems: function(t) {
          this.maxLogItems = parseInt(t || this.defaultMaxLogItems);
        },
        theme: function(t) {
          switch (t.toLowerCase()) {
            case "bootstrap":
              this.dialogs.buttons.ok = "<button class='ok btn btn-primary' tabindex='1'>{{ok}}</button>", this.dialogs.buttons.cancel = "<button class='cancel btn btn-default' tabindex='2'>{{cancel}}</button>", this.dialogs.input = "<input type='text' class='form-control'>";
              break;
            case "purecss":
              this.dialogs.buttons.ok = "<button class='ok pure-button' tabindex='1'>{{ok}}</button>", this.dialogs.buttons.cancel = "<button class='cancel pure-button' tabindex='2'>{{cancel}}</button>";
              break;
            case "mdl":
            case "material-design-light":
              this.dialogs.buttons.ok = "<button class='ok mdl-button mdl-js-button mdl-js-ripple-effect'  tabindex='1'>{{ok}}</button>", this.dialogs.buttons.cancel = "<button class='cancel mdl-button mdl-js-button mdl-js-ripple-effect' tabindex='2'>{{cancel}}</button>", this.dialogs.input = "<div class='mdl-textfield mdl-js-textfield'><input class='mdl-textfield__input'><label class='md-textfield__label'></label></div>";
              break;
            case "angular-material":
              this.dialogs.buttons.ok = "<button class='ok md-primary md-button' tabindex='1'>{{ok}}</button>", this.dialogs.buttons.cancel = "<button class='cancel md-button' tabindex='2'>{{cancel}}</button>", this.dialogs.input = "<div layout='column'><md-input-container md-no-float><input type='text'></md-input-container></div>";
              break;
            case "default":
            default:
              this.dialogs.buttons.ok = this.defaultDialogs.buttons.ok, this.dialogs.buttons.cancel = this.defaultDialogs.buttons.cancel, this.dialogs.input = this.defaultDialogs.input;
          }
        },
        reset: function() {
          this.theme("default"), this.okBtn(this.defaultOkLabel), this.cancelBtn(this.defaultCancelLabel), this.setMaxLogItems(), this.promptValue = "", this.promptPlaceholder = "", this.delay = this.defaultDelay, this.setCloseLogOnClick(this.closeLogOnClickDefault), this.setLogPosition("bottom left"), this.logTemplateMethod = null;
        },
        injectCSS: function() {
          if (!document.querySelector("#alertifyCSS")) {
            var t = document.getElementsByTagName("head")[0],
                e = document.createElement("style");
            e.type = "text/css", e.id = "alertifyCSS", e.innerHTML = ".alertify-logs>*{padding:12px 24px;color:#fff;box-shadow:0 2px 5px 0 rgba(0,0,0,.2);border-radius:1px}.alertify-logs>*,.alertify-logs>.default{background:rgba(0,0,0,.8)}.alertify-logs>.error{background:rgba(244,67,54,.8)}.alertify-logs>.success{background:rgba(76,175,80,.9)}.alertify{position:fixed;background-color:rgba(0,0,0,.3);left:0;right:0;top:0;bottom:0;width:100%;height:100%;z-index:2}.alertify.hide{opacity:0;pointer-events:none}.alertify,.alertify.show{box-sizing:border-box;transition:all .33s cubic-bezier(.25,.8,.25,1)}.alertify,.alertify *{box-sizing:border-box}.alertify .dialog{padding:12px}.alertify .alert,.alertify .dialog{width:100%;margin:0 auto;position:relative;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.alertify .alert>*,.alertify .dialog>*{width:400px;max-width:95%;margin:0 auto;text-align:center;padding:12px;background:#fff;box-shadow:0 2px 4px -1px rgba(0,0,0,.14),0 4px 5px 0 rgba(0,0,0,.098),0 1px 10px 0 rgba(0,0,0,.084)}.alertify .alert .msg,.alertify .dialog .msg{padding:12px;margin-bottom:12px;margin:0;text-align:left}.alertify .alert input:not(.form-control),.alertify .dialog input:not(.form-control){margin-bottom:15px;width:100%;font-size:100%;padding:12px}.alertify .alert input:not(.form-control):focus,.alertify .dialog input:not(.form-control):focus{outline-offset:-2px}.alertify .alert nav,.alertify .dialog nav{text-align:right}.alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button),.alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button){background:transparent;box-sizing:border-box;color:rgba(0,0,0,.87);position:relative;outline:0;border:0;display:inline-block;-webkit-align-items:center;-ms-flex-align:center;-ms-grid-row-align:center;align-items:center;padding:0 6px;margin:6px 8px;line-height:36px;min-height:36px;white-space:nowrap;min-width:88px;text-align:center;text-transform:uppercase;font-size:14px;text-decoration:none;cursor:pointer;border:1px solid transparent;border-radius:2px}.alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):active,.alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):hover,.alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):active,.alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):hover{background-color:rgba(0,0,0,.05)}.alertify .alert nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):focus,.alertify .dialog nav button:not(.btn):not(.pure-button):not(.md-button):not(.mdl-button):focus{border:1px solid rgba(0,0,0,.1)}.alertify .alert nav button.btn,.alertify .dialog nav button.btn{margin:6px 4px}.alertify-logs{position:fixed;z-index:1}.alertify-logs.bottom,.alertify-logs:not(.top){bottom:16px}.alertify-logs.left,.alertify-logs:not(.right){left:16px}.alertify-logs.left>*,.alertify-logs:not(.right)>*{float:left;-webkit-transform:translateZ(0);transform:translateZ(0);height:auto}.alertify-logs.left>.show,.alertify-logs:not(.right)>.show{left:0}.alertify-logs.left>*,.alertify-logs.left>.hide,.alertify-logs:not(.right)>*,.alertify-logs:not(.right)>.hide{left:-110%}.alertify-logs.right{right:16px}.alertify-logs.right>*{float:right;-webkit-transform:translateZ(0);transform:translateZ(0)}.alertify-logs.right>.show{right:0;opacity:1}.alertify-logs.right>*,.alertify-logs.right>.hide{right:-110%;opacity:0}.alertify-logs.top{top:0}.alertify-logs>*{box-sizing:border-box;transition:all .4s cubic-bezier(.25,.8,.25,1);position:relative;clear:both;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000;perspective:1000;max-height:0;margin:0;padding:0;overflow:hidden;opacity:0;pointer-events:none}.alertify-logs>.show{margin-top:12px;opacity:1;max-height:1000px;padding:12px;pointer-events:auto}", t.insertBefore(e, t.firstChild);
          }
        },
        removeCSS: function() {
          var t = document.querySelector("#alertifyCSS");
          t && t.parentNode && t.parentNode.removeChild(t);
        }
      };
      return t.injectCSS(), {
        _$$alertify: t,
        reset: function() {
          return t.reset(), this;
        },
        alert: function(e, o, n) {
          return t.dialog(e, "alert", o, n) || this;
        },
        confirm: function(e, o, n) {
          return t.dialog(e, "confirm", o, n) || this;
        },
        prompt: function(e, o, n) {
          return t.dialog(e, "prompt", o, n) || this;
        },
        log: function(e, o) {
          return t.log(e, "default", o), this;
        },
        theme: function(e) {
          return t.theme(e), this;
        },
        success: function(e, o) {
          return t.log(e, "success", o), this;
        },
        error: function(e, o) {
          return t.log(e, "error", o), this;
        },
        cancelBtn: function(e) {
          return t.cancelBtn(e), this;
        },
        okBtn: function(e) {
          return t.okBtn(e), this;
        },
        delay: function(e) {
          return t.setDelay(e), this;
        },
        placeholder: function(e) {
          return t.promptPlaceholder = e, this;
        },
        defaultValue: function(e) {
          return t.promptValue = e, this;
        },
        maxLogItems: function(e) {
          return t.setMaxLogItems(e), this;
        },
        closeLogOnClick: function(e) {
          return t.setCloseLogOnClick(!!e), this;
        },
        logPosition: function(e) {
          return t.setLogPosition(e || ""), this;
        },
        setLogTemplate: function(e) {
          return t.logTemplateMethod = e, this;
        },
        clearLogs: function() {
          return t.setupLogContainer().innerHTML = "", this;
        },
        version: t.version
      };
    }
    var e = 500,
        o = function(t) {
          if (t) {
            var o = function() {
              t && t.parentNode && t.parentNode.removeChild(t);
            };
            t.classList.remove("show"), t.classList.add("hide"), t.addEventListener("transitionend", o), setTimeout(o, e);
          }
        };
    if ("undefined" != typeof module && module && module.exports) {
      module.exports = function() {
        return new t;
      };
      var n = new t;
      for (var i in n)
        module.exports[i] = n[i];
    } else
      "function" == typeof define && define.amd ? define(function() {
        return new t;
      }) : window.alertify = new t;
  }();
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:alertify.js@1.0.9", ["npm:alertify.js@1.0.9/dist/js/alertify"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:alertify.js@1.0.9/dist/js/alertify");
  global.define = __define;
  return module.exports;
});

System.register("ui/app", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "editing/edit-session-factory", "editing/current-file-changed-event", "editing/query-string", "github/default-gist", "import/importer", "ui/focus", "npm:alertify.js@1.0.9"], function(_export) {
  'use strict';
  var inject,
      EditSessionFactory,
      CurrentFileChangedEvent,
      QueryString,
      defaultGist,
      Importer,
      Focus,
      alertify,
      App;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_editingEditSessionFactory) {
      EditSessionFactory = _editingEditSessionFactory.EditSessionFactory;
    }, function(_editingCurrentFileChangedEvent) {
      CurrentFileChangedEvent = _editingCurrentFileChangedEvent.CurrentFileChangedEvent;
    }, function(_editingQueryString) {
      QueryString = _editingQueryString.QueryString;
    }, function(_githubDefaultGist) {
      defaultGist = _githubDefaultGist.defaultGist;
    }, function(_importImporter) {
      Importer = _importImporter.Importer;
    }, function(_focus) {
      Focus = _focus.Focus;
    }, function(_alertifyJs) {
      alertify = _alertifyJs['default'];
    }],
    execute: function() {
      App = (function() {
        function App(editSessionFactory, importer, queryString, focus) {
          _classCallCheck(this, _App);
          this.editSession = null;
          this.editSessionFactory = editSessionFactory;
          this.importer = importer;
          this.queryString = queryString;
          this.focus = focus;
          addEventListener('beforeunload', this.beforeUnload.bind(this));
        }
        _createClass(App, [{
          key: 'beforeUnload',
          value: function beforeUnload(event) {
            if (this.editSession && this.editSession.dirty) {
              event.returnValue = 'You have unsaved work in this Gist.';
            }
          }
        }, {
          key: 'currentFileChanged',
          value: function currentFileChanged(event) {
            if (event.file.name === '') {
              this.focus.set('filename');
            } else {
              this.focus.set('editor');
            }
          }
        }, {
          key: 'setEditSession',
          value: function setEditSession(editSession) {
            if (this.fileChangedSub) {
              this.fileChangedSub.dispose();
            }
            this.editSession = editSession;
            this.fileChangedSub = editSession.subscribe(CurrentFileChangedEvent, this.currentFileChanged.bind(this));
          }
        }, {
          key: 'activate',
          value: function activate() {
            var _this = this;
            return this.queryString.read().then(function(gist) {
              return _this.editSessionFactory.create(gist);
            }).then(function(editSesson) {
              return _this.setEditSession(editSesson);
            });
          }
        }, {
          key: 'attached',
          value: function attached() {
            var _this2 = this;
            setTimeout(function() {
              _this2.editSession.run();
              _this2.focus.set('editor');
            });
          }
        }, {
          key: 'newGist',
          value: function newGist() {
            var _this3 = this;
            this.queryString.clear();
            return this.editSessionFactory.create(defaultGist).then(function(editSesson) {
              return _this3.setEditSession(editSesson);
            });
          }
        }, {
          key: 'import',
          value: function _import(urlOrId) {
            var _this4 = this;
            this.importer['import'](urlOrId).then(function(gist) {
              _this4.queryString.write(gist, true);
              return _this4.editSessionFactory.create(gist);
            }).then(function(editSesson) {
              return _this4.setEditSession(editSesson);
            }).then(function() {
              return alertify.success('Import successful.');
            }, function(reason) {
              return alertify.error(reason);
            });
          }
        }]);
        var _App = App;
        App = inject(EditSessionFactory, Importer, QueryString, Focus)(App) || App;
        return App;
      })();
      _export('App', App);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/app.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <require from=\"./header\"></require>\r\n  <require from=\"./rate-alert\"></require>\r\n  <require from=\"./edit-session-commands.html\"></require>\r\n  <require from=\"./split-panel\"></require>\r\n  <require from=\"./nav-panel\"></require>\r\n  <require from=\"./edit-file-panel.html\"></require>\r\n  <require from=\"./result-panel\"></require>\r\n\r\n  <header import.call=\"import(urlOrId)\" new.call=\"newGist()\"></header>\r\n\r\n  <rate-alert></rate-alert>\r\n\r\n  <edit-session-commands edit-session.bind=\"editSession\"></edit-session-commands>\r\n\r\n  <split-panel>\r\n    <template replace-part=\"left\">\r\n      <nav-panel edit-session.bind=\"editSession\"></nav-panel>\r\n    </template>\r\n\r\n    <template replace-part=\"center\">\r\n      <edit-file-panel edit-session.bind=\"editSession\"></edit-file-panel>\r\n    </template>\r\n\r\n    <template replace-part=\"right\">\r\n      <result-panel></result-panel>\r\n    </template>\r\n  </split-panel>\r\n</template>\r\n";
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/edit-file-panel.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template bindables=\"editSession\">\r\n  <require from=\"./ace-editor\"></require>\r\n  <require from=\"./focus-target\"></require>\r\n  <require from=\"./ga\"></require>\r\n\r\n  <div class=\"file-header\" with.bind=\"editSession\">\r\n    <form submit.trigger=\"aceEditor.focus()\">\r\n      <div class=\"input-group filename\" show.bind=\"currentFile.name !== 'index.html'\">\r\n        <input type=\"text\" placeholder=\"Filename including extension...\"\r\n               focus-target=\"filename\"\r\n               value.one-way=\"currentFile.name\"\r\n               input.delegate=\"renameFile(currentFile, $event.target.value) & debounce:500\">\r\n        <span class=\"input-group-button\">\r\n          <button type=\"button\" class=\"btn\" click.delegate=\"deleteFile(currentFile)\"\r\n                  ga ga-category=\"editor\" ga-action=\"delete-file\">\r\n            <span class=\"octicon octicon-trashcan text-closed\"></span>\r\n          </button>\r\n        </span>\r\n      </div>\r\n      <input type=\"text\" disabled value=\"index.html\" show.bind=\"currentFile.name === 'index.html'\">\r\n\r\n      <!-- need a submit button to make enter-key submit form -->\r\n      <button type=\"submit\" style=\"display:none\">Submit</button>\r\n    </form>\r\n  </div>\r\n  <ace-editor view-model.ref=\"aceEditor\"\r\n              focus-target=\"editor\"\r\n              value.one-way=\"editSession.currentFile.content\"\r\n              change.delegate=\"editSession.updateFile(editSession.currentFile, $event.detail) & debounce:800\"\r\n              mode.bind=\"editSession.currentFile.editorMode\">\r\n  </ace-editor>\r\n</template>\r\n";
});

_removeDefine();
})();
(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/edit-session-commands.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template bindable=\"editSession\">\r\n  <require from=\"./save-buttons\"></require>\r\n  <require from=\"./ga\"></require>\r\n\r\n  <button class=\"btn\" click.delegate=\"editSession.addFile('')\"\r\n          ga ga-category=\"editor-commands\" ga-action=\"new-file\">\r\n    Add File\r\n  </button>\r\n\r\n  <button class=\"btn ${editSession.autoRun ? 'btn-danger' : 'btn-primary'} m-l-5\"\r\n          click.delegate=\"editSession.toggleAutoRun()\"\r\n          ga ga-category=\"editor-commands\" ga-action=\"run-stop\">\r\n    ${editSession.autoRun ? 'Stop' : 'Run'}\r\n  </button>\r\n\r\n  <input class=\"gist-description input-contrast\" type=\"text\" placeholder=\"Gist description...\"\r\n         value.bind=\"editSession.description\">\r\n\r\n  <save-buttons save.call=\"editSession.save(fork, secret)\"\r\n                public.bind=\"editSession.gist.public\"\r\n                save-action.bind=\"editSession.saveAction\">\r\n  </save-buttons>\r\n</template>\r\n";
});

_removeDefine();
})();
System.register("ui/embed/app", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "editing/edit-session-factory", "editing/query-string", "ui/focus"], function(_export) {
  'use strict';
  var inject,
      EditSessionFactory,
      QueryString,
      Focus,
      App;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_editingEditSessionFactory) {
      EditSessionFactory = _editingEditSessionFactory.EditSessionFactory;
    }, function(_editingQueryString) {
      QueryString = _editingQueryString.QueryString;
    }, function(_focus) {
      Focus = _focus.Focus;
    }],
    execute: function() {
      App = (function() {
        function App(editSessionFactory, queryString, focus) {
          _classCallCheck(this, _App);
          this.editSession = null;
          this.showResult = true;
          this._currentItem = null;
          this.editSessionFactory = editSessionFactory;
          this.queryString = queryString;
          this.focus = focus;
        }
        _createClass(App, [{
          key: 'activate',
          value: function activate() {
            var _this = this;
            return this.queryString.read().then(function(gist) {
              _this.gist = gist;
              return _this.editSessionFactory.create(gist);
            }).then(function(editSession) {
              return _this.editSession = editSession;
            });
          }
        }, {
          key: 'attached',
          value: function attached() {
            var _this2 = this;
            setTimeout(function() {
              return _this2.editSession.run();
            });
          }
        }, {
          key: 'reset',
          value: function reset() {
            var _this3 = this;
            this.editSessionFactory.create(this.gist).then(function(editSession) {
              return _this3.editSession = editSession;
            }).then(function() {
              return _this3.editSession.run();
            });
          }
        }, {
          key: 'currentItem',
          get: function get() {
            return this._currentItem;
          },
          set: function set(item) {
            this._currentItem = item;
            if (item === null) {
              this.showResult = true;
            } else {
              this.showResult = false;
              this.editSession.currentFile = item;
              this.focus.set('editor');
            }
          }
        }]);
        var _App = App;
        App = inject(EditSessionFactory, QueryString, Focus)(App) || App;
        return App;
      })();
      _export('App', App);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/embed/app.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <require from=\"../rate-alert\"></require>\r\n  <require from=\"../ace-editor\"></require>\r\n  <require from=\"../focus-target\"></require>\r\n  <require from=\"../result-panel\"></require>\r\n  <require from=\"../ga\"></require>\r\n\r\n  <div class=\"embed-header\" with.bind=\"editSession\">\r\n    <img class=\"header-logo\" src=\"img/logo.png\">\r\n\r\n    <a class=\"header-title\" href=\"https://gist.run?id=${gist.id}\" target=\"_blank\"\r\n       ga ga-category=\"embed-header\" ga-action=\"link\">\r\n      ${gist.description.length ? gist.description : 'untitled gist'}\r\n    </a>\r\n\r\n    <div class=\"right\">\r\n      <select class=\"select-sm\" value.bind=\"currentItem\"\r\n              ga ga-category=\"embed-header\" ga-action=\"picker\">\r\n        <option model.bind=\"null\">Result</option>\r\n        <optgroup label=\"Files:\">\r\n          <option repeat.for=\"file of files\" model.bind=\"file\">${file.name}</option>\r\n        </optgroup>\r\n      </select>\r\n\r\n      <button class=\"btn btn-sm\" click.delegate=\"reset()\"\r\n              ga ga-category=\"embed-header\" ga-action=\"reset\">\r\n        Reset\r\n      </button>\r\n    </div>\r\n  </div>\r\n\r\n  <ace-editor with.bind=\"editSession\"\r\n              show.bind=\"!showResult\"\r\n              focus-target=\"editor\"\r\n              value.one-way=\"currentFile.content\"\r\n              change.delegate=\"updateFile(currentFile, $event.detail) & debounce:500\"\r\n              mode.bind=\"currentFile.editorMode\">\r\n  </ace-editor>\r\n\r\n  <result-panel show.bind=\"showResult\"></result-panel>\r\n</template>\r\n";
});

_removeDefine();
})();
System.register("ui/fallback", [], function(_export) {
  "use strict";
  var UnsupportedBrowser;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  return {
    setters: [],
    execute: function() {
      UnsupportedBrowser = function UnsupportedBrowser() {
        _classCallCheck(this, UnsupportedBrowser);
      };
      _export("UnsupportedBrowser", UnsupportedBrowser);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/fallback.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <section class=\"fallback-container\">\r\n    <img alt=\"GistRun\" src=\"img/logo.png\">\r\n    <p>\r\n      <strong>GistRun</strong> runs and edits\r\n      <a href=\"https://gist.github.com/\" target=\"_blank\">GitHub Gists</a>. GistRun is\r\n      built with <a href=\"http://aurelia.io\" target=\"_blank\">Aurelia</a>, uses the\r\n      <a href=\"https://developer.github.com/v3/\" target=\"_blank\">GitHub API</a> and is hosted on\r\n      <a href=\"https://pages.github.com/\" target=\"_blank\">GitHub pages</a>.\r\n      <a href=\"https://www.cloudflare.com/\" target=\"_blank\">CloudFlare</a> provides DNS and\r\n      <a href=\"https://www.heroku.com/\" target=\"_blank\">Heruku</a> hosts GistRun's integration\r\n      with GitHub's OAuth <a href=\"https://developer.github.com/v3/oauth/#web-application-flow\" target=\"_blank\">\r\n      web application flow</a>. <em>Many thanks to the providers of these free\r\n      libraries and services!</em>\r\n    </p>\r\n    <div class=\"flash flash-error\">\r\n      <span class=\"octicon octicon-alert\"></span> Bummer... Your browser doesn't\r\n      support service workers.  Check\r\n      <a href=\"http://caniuse.com/#feat=serviceworkers\" target=\"_blank\">here</a> for a list of\r\n      browsers that support service workers.\r\n    </div>\r\n  </section>\r\n</template>\r\n";
});

_removeDefine();
})();
System.register("ui/focus-target", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "npm:aurelia-event-aggregator@1.0.0-beta.1.1.1", "ui/focus"], function(_export) {
  'use strict';
  var inject,
      customAttribute,
      EventAggregator,
      SetFocusEvent,
      FocusTarget;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
      customAttribute = _aureliaFramework.customAttribute;
    }, function(_aureliaEventAggregator) {
      EventAggregator = _aureliaEventAggregator.EventAggregator;
    }, function(_focus) {
      SetFocusEvent = _focus.SetFocusEvent;
    }],
    execute: function() {
      FocusTarget = (function() {
        function FocusTarget(element, eventAggregator) {
          _classCallCheck(this, _FocusTarget);
          this.element = element;
          this.eventAggregator = eventAggregator;
        }
        _createClass(FocusTarget, [{
          key: 'handleEvent',
          value: function handleEvent(e) {
            var _this = this;
            if (!e.handled && e.name === this.value) {
              e.handled = true;
              setTimeout(function() {
                return _this.element.focus();
              });
            }
          }
        }, {
          key: 'attached',
          value: function attached() {
            this.subscription = this.eventAggregator.subscribe(SetFocusEvent, this.handleEvent.bind(this));
          }
        }, {
          key: 'detached',
          value: function detached() {
            this.subscription.dispose();
          }
        }]);
        var _FocusTarget = FocusTarget;
        FocusTarget = inject(Element, EventAggregator)(FocusTarget) || FocusTarget;
        FocusTarget = customAttribute('focus-target')(FocusTarget) || FocusTarget;
        return FocusTarget;
      })();
      _export('FocusTarget', FocusTarget);
    }
  };
});

System.register("ui/ga", ["npm:aurelia-framework@1.0.0-beta.1.0.8"], function(_export) {
  'use strict';
  var inject,
      GaCustomAttribute;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }],
    execute: function() {
      GaCustomAttribute = (function() {
        function GaCustomAttribute(element) {
          _classCallCheck(this, _GaCustomAttribute);
          this.element = element;
          this.boundClick = this.click.bind(this);
          this.event = element instanceof HTMLFormElement ? 'submit' : 'click';
        }
        _createClass(GaCustomAttribute, [{
          key: 'click',
          value: function click(event) {
            ga('send', 'event', this.element.getAttribute('ga-category'), this.element.getAttribute('ga-action'));
            return true;
          }
        }, {
          key: 'attached',
          value: function attached() {
            this.element.addEventListener(this.event, this.boundClick);
          }
        }, {
          key: 'detached',
          value: function detached() {
            this.element.removeEventListener(this.event, this.boundClick);
          }
        }]);
        var _GaCustomAttribute = GaCustomAttribute;
        GaCustomAttribute = inject(Element)(GaCustomAttribute) || GaCustomAttribute;
        return GaCustomAttribute;
      })();
      _export('GaCustomAttribute', GaCustomAttribute);
    }
  };
});

System.register("ui/header", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "github/user"], function(_export) {
  'use strict';
  var inject,
      bindable,
      User,
      Header;
  var _createDecoratedClass = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === 'function') {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        Object.defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _defineDecoratedPropertyDescriptor(target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor)
      return;
    var descriptor = {};
    for (var _key in _descriptor)
      descriptor[_key] = _descriptor[_key];
    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
      bindable = _aureliaFramework.bindable;
    }, function(_githubUser) {
      User = _githubUser.User;
    }],
    execute: function() {
      Header = (function() {
        var _instanceInitializers = {};
        _createDecoratedClass(Header, [{
          key: 'import',
          decorators: [bindable],
          initializer: null,
          enumerable: true
        }, {
          key: 'new',
          decorators: [bindable],
          initializer: null,
          enumerable: true
        }], null, _instanceInitializers);
        function Header(user) {
          _classCallCheck(this, _Header);
          _defineDecoratedPropertyDescriptor(this, 'import', _instanceInitializers);
          _defineDecoratedPropertyDescriptor(this, 'new', _instanceInitializers);
          this.user = user;
        }
        var _Header = Header;
        Header = inject(User)(Header) || Header;
        return Header;
      })();
      _export('Header', Header);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/header.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <require from=\"./ga\"></require>\r\n\r\n  <img class=\"header-logo\" src=\"img/logo.png\">\r\n\r\n  <form class=\"header-load-gist\" submit.delegate=\"import({ urlOrId: urlOrIdInput.value})\"\r\n        ga ga-category=\"header\" ga-action=\"import\">\r\n    <div class=\"input-group\">\r\n      <input class=\"input-mini\" type=\"text\" placeholder=\"Gist/Plunker/jsFiddle URL...\" ref=\"urlOrIdInput\">\r\n      <span class=\"input-group-button\">\r\n        <button class=\"btn btn-sm\" type=\"submit\">\r\n          <span class=\"octicon octicon-repo-pull\"></span>\r\n        </button>\r\n      </span>\r\n    </div>\r\n  </form>\r\n\r\n  <a class=\"tooltipped tooltipped-sw right\"\r\n     href=\"https://gist.github.com/${user.login}\" target=\"_blank\"\r\n     show.bind=\"user.authenticated\"\r\n     aria-label=\"Signed in as ${user.login}\"\r\n     ga ga-category=\"header\" ga-action=\"avatar\">\r\n    <img class=\"avatar avatar-small\"\r\n         src.bind=\"user.avatar_url + '?v=3&s=32'\"\r\n         width=\"26\" height=\"26\">\r\n  </a>\r\n\r\n  <button class=\"btn btn-sm right\" type=\"button\"\r\n          show.bind=\"!user.authenticated\"\r\n          disabled.bind=\"user.loading\"\r\n          click.delegate=\"user.signIn()\"\r\n          ga ga-category=\"header\" ga-action=\"sign-in\">\r\n    Sign In\r\n  </button>\r\n\r\n  <button class=\"btn btn-sm right\" type=\"button\"\r\n          click.delegate=\"new()\"\r\n          ga ga-category=\"nav-panel\" ga-action=\"new\">\r\n    New Gist\r\n  </button>\r\n</template>\r\n";
});

_removeDefine();
})();
System.register("ui/stack-overflow-markdown", ["util"], function(_export) {
  'use strict';
  var getExtension;
  _export('getStackOverflowMarkdown', getStackOverflowMarkdown);
  function indentCode(code) {
    return code.replace(/^/mg, '    ');
  }
  function formatFile(file) {
    var name = file.name;
    var extension = getExtension(name);
    var content = indentCode(file.content.trim());
    return '**' + name + '**\n\n<!-- language: lang-' + extension + ' -->\n\n' + content;
  }
  function getStackOverflowMarkdown(editSession) {
    return '**Here\'s an example: https://gist.run?id=' + editSession.gist.id + '**\n\n' + editSession.files.map(function(file) {
      return formatFile(file);
    }).join('\n\n');
  }
  return {
    setters: [function(_util) {
      getExtension = _util.getExtension;
    }],
    execute: function() {}
  };
});

System.register("ui/nav-panel", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "ui/stack-overflow-markdown", "util", "worker/worker-client", "npm:alertify.js@1.0.9"], function(_export) {
  'use strict';
  var bindable,
      getStackOverflowMarkdown,
      copyTextToClipboard,
      runUrl,
      alertify,
      successHtml,
      NavPanel;
  var _createDecoratedClass = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === 'function') {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        Object.defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _defineDecoratedPropertyDescriptor(target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor)
      return;
    var descriptor = {};
    for (var _key in _descriptor)
      descriptor[_key] = _descriptor[_key];
    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  }
  return {
    setters: [function(_aureliaFramework) {
      bindable = _aureliaFramework.bindable;
    }, function(_stackOverflowMarkdown) {
      getStackOverflowMarkdown = _stackOverflowMarkdown.getStackOverflowMarkdown;
    }, function(_util) {
      copyTextToClipboard = _util.copyTextToClipboard;
    }, function(_workerWorkerClient) {
      runUrl = _workerWorkerClient.runUrl;
    }, function(_alertifyJs) {
      alertify = _alertifyJs['default'];
    }],
    execute: function() {
      successHtml = '<img class="octicon" style="margin-bottom: -3px" src="img/stack-overflow-icon.png" height="16" width="16"> Stack Overflow markdown copied.';
      NavPanel = (function() {
        var _instanceInitializers = {};
        function NavPanel() {
          _classCallCheck(this, NavPanel);
          _defineDecoratedPropertyDescriptor(this, 'editSession', _instanceInitializers);
          this.runUrl = runUrl;
        }
        _createDecoratedClass(NavPanel, [{
          key: 'copyForStackOverflow',
          value: function copyForStackOverflow() {
            var markdown = getStackOverflowMarkdown(this.editSession);
            copyTextToClipboard(markdown);
            alertify.success(successHtml);
          }
        }, {
          key: 'editSession',
          decorators: [bindable],
          initializer: null,
          enumerable: true
        }], null, _instanceInitializers);
        return NavPanel;
      })();
      _export('NavPanel', NavPanel);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/nav-panel.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <require from=\"./ga\"></require>\r\n\r\n  <nav class=\"menu\">\r\n    <a repeat.for=\"file of editSession.files\"\r\n       class=\"menu-item ${editSession.currentFile === file ? 'selected' : ''}\"\r\n       href=\"#\"\r\n       click.delegate=\"editSession.currentFile = file\"\r\n       ga ga-category=\"nav-panel\" ga-action=\"file\">\r\n       <span class=\"unnamed-file\" show.bind=\"file.name === ''\">unnamed</span>\r\n       <span show.bind=\"file.name !== ''\">${file.name}</span>\r\n   </a>\r\n  </nav>\r\n\r\n  <nav class=\"menu\">\r\n    <a class=\"menu-item\" href=\"${editSession.gist.html_url}\" target=\"_blank\"\r\n       show.bind=\"editSession.gist.html_url\"\r\n       ga ga-category=\"nav-panel\" ga-action=\"gist\">\r\n      <span class=\"octicon octicon-gist\"></span>\r\n      Gist\r\n    </a>\r\n    <a class=\"menu-item\" href=\"${editSession.gist.html_url}/revisions\" target=\"_blank\"\r\n       show.bind=\"editSession.gist.html_url\"\r\n       ga ga-category=\"nav-panel\" ga-action=\"revisions\">\r\n      <span class=\"octicon octicon-git-commit\"></span>\r\n      <span class=\"counter\">${editSession.gist.history.length || 0}</span>\r\n      Revisions\r\n    </a>\r\n    <a class=\"menu-item\" href=\"${editSession.gist.html_url}/forks\" target=\"_blank\"\r\n       show.bind=\"editSession.gist.html_url\"\r\n       ga ga-category=\"nav-panel\" ga-action=\"forks\">\r\n      <span class=\"octicon octicon-repo-forked\"></span>\r\n      <span class=\"counter\">${editSession.gist.forks.length || 0}</span>\r\n      Forks\r\n    </a>\r\n    <a class=\"menu-item\" href=\"#\" click.delegate=\"copyForStackOverflow()\"\r\n       show.bind=\"editSession.gist.html_url\"\r\n       ga ga-category=\"nav-panel\" ga-action=\"stack-overflow-copy\">\r\n      <img class=\"octicon\" style=\"margin-bottom: -3px\" src=\"img/stack-overflow-icon.png\" height=\"16\" width=\"16\">\r\n      Copy\r\n    </a>\r\n    <a class=\"menu-item\" href=\"embed.html?id=${editSession.gist.id}\" target=\"_blank\"\r\n       show.bind=\"editSession.gist.html_url\"\r\n       ga ga-category=\"nav-panel\" ga-action=\"embed\">\r\n      <span class=\"octicon octicon-code\"></span>\r\n      Embed\r\n    </a>\r\n    <!-- <a class=\"menu-item\" href.bind=\"runUrl\" target=\"_blank\">\r\n      <span class=\"octicon octicon-link-external\"></span>\r\n      Run Outside\r\n    </a> -->\r\n    <a class=\"menu-item\" href=\"https://github.com/gist-run/gist-run/blob/master/README.md\" target=\"_blank\"\r\n       ga ga-category=\"nav-panel\" ga-action=\"about\">\r\n      <span class=\"octicon octicon-info\"></span>\r\n      About\r\n    </a>\r\n  </nav>\r\n</template>\r\n";
});

_removeDefine();
})();
System.register("ui/rate-alert", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "github/rate-limit", "github/user"], function(_export) {
  'use strict';
  var inject,
      RateLimit,
      User,
      RateAlert;
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
    }, function(_githubRateLimit) {
      RateLimit = _githubRateLimit.RateLimit;
    }, function(_githubUser) {
      User = _githubUser.User;
    }],
    execute: function() {
      RateAlert = (function() {
        function RateAlert(rateLimit, user) {
          _classCallCheck(this, _RateAlert);
          this.rateLimit = rateLimit;
          this.user = user;
        }
        var _RateAlert = RateAlert;
        RateAlert = inject(RateLimit, User)(RateAlert) || RateAlert;
        return RateAlert;
      })();
      _export('RateAlert', RateAlert);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/rate-alert.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <div class=\"flash text-center\"\r\n       if.bind=\"!user.loading && !user.authenticated && !rateInfoDismissed && rateLimit.remaining > 10\">\r\n    <span class=\"octicon octicon-x flash-close js-flash-close\" click.delegate=\"rateInfoDismissed = true\"></span>\r\n    <span class=\"octicon octicon-info\"></span> Pro Tip: <a href=\"#\" click.delegate=\"user.signIn()\">Sign in</a> to save gists to your GitHub account.\r\n  </div>\r\n  <div class=\"flash flash-warn text-center\"\r\n       if.bind=\"!user.loading && !user.authenticated && !rateWarningDismissed && rateLimit.remaining <= 10 && rateLimit.remaining !== 0\">\r\n    <span class=\"octicon octicon-x flash-close js-flash-close\" click.delegate=\"rateWarningDismissed = true\"></span>\r\n    <span class=\"octicon octicon-alert\"></span> Uh oh... you're about to hit GitHub's rate limit for unauthenticated requests. <a href=\"#\" click.delegate=\"user.signIn()\">Sign in</a> to increase your rate limit.&nbsp;&nbsp;<em>${rateLimit.remaining} requests remaining.</em>\r\n  </div>\r\n  <div class=\"flash flash-error text-center\"\r\n       if.bind=\"!user.loading && !user.authenticated && !rateErrorDismissed && rateLimit.remaining === 0\">\r\n    <span class=\"octicon octicon-x flash-close js-flash-close\" click.delegate=\"rateErrorDismissed = true\"></span>\r\n    <span class=\"octicon octicon-alert\"></span> On snap! You've hit GitHub's rate limit for unauthenticated requests. <a href=\"#\" click.delegate=\"user.signIn()\">Sign in</a> to increase your rate limit.&nbsp;&nbsp;<em>Resets at ${rateLimit.reset}.</em>\r\n  </div>\r\n</template>\r\n";
});

_removeDefine();
})();
System.register("ui/result-panel", ["worker/worker-client", "editing/run-event"], function(_export) {
  'use strict';
  var runUrl,
      RunEvent,
      ResultPanel;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_workerWorkerClient) {
      runUrl = _workerWorkerClient.runUrl;
    }, function(_editingRunEvent) {
      RunEvent = _editingRunEvent.RunEvent;
    }],
    execute: function() {
      ResultPanel = (function() {
        function ResultPanel() {
          _classCallCheck(this, ResultPanel);
        }
        _createClass(ResultPanel, [{
          key: 'run',
          value: function run() {
            this.iframe.src = runUrl;
          }
        }, {
          key: 'attached',
          value: function attached() {
            this.subscription = RunEvent.subscribe(this.run.bind(this));
          }
        }, {
          key: 'detached',
          value: function detached() {
            this.subscription.dispose();
          }
        }]);
        return ResultPanel;
      })();
      _export('ResultPanel', ResultPanel);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/result-panel.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>  \r\n  <iframe ref=\"iframe\" frameborder=\"0\"></iframe>\r\n</template>\r\n";
});

_removeDefine();
})();
System.register("ui/save-buttons", ["npm:aurelia-framework@1.0.0-beta.1.0.8", "npm:alertify.js@1.0.9"], function(_export) {
  'use strict';
  var containerless,
      bindable,
      alertify,
      SaveButtons;
  var _createDecoratedClass = (function() {
    function defineProperties(target, descriptors, initializers) {
      for (var i = 0; i < descriptors.length; i++) {
        var descriptor = descriptors[i];
        var decorators = descriptor.decorators;
        var key = descriptor.key;
        delete descriptor.key;
        delete descriptor.decorators;
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor || descriptor.initializer)
          descriptor.writable = true;
        if (decorators) {
          for (var f = 0; f < decorators.length; f++) {
            var decorator = decorators[f];
            if (typeof decorator === 'function') {
              descriptor = decorator(target, key, descriptor) || descriptor;
            } else {
              throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator);
            }
          }
          if (descriptor.initializer !== undefined) {
            initializers[key] = descriptor;
            continue;
          }
        }
        Object.defineProperty(target, key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps, protoInitializers, staticInitializers) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps, protoInitializers);
      if (staticProps)
        defineProperties(Constructor, staticProps, staticInitializers);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  function _defineDecoratedPropertyDescriptor(target, key, descriptors) {
    var _descriptor = descriptors[key];
    if (!_descriptor)
      return;
    var descriptor = {};
    for (var _key in _descriptor)
      descriptor[_key] = _descriptor[_key];
    descriptor.value = descriptor.initializer ? descriptor.initializer.call(target) : undefined;
    Object.defineProperty(target, key, descriptor);
  }
  return {
    setters: [function(_aureliaFramework) {
      containerless = _aureliaFramework.containerless;
      bindable = _aureliaFramework.bindable;
    }, function(_alertifyJs) {
      alertify = _alertifyJs['default'];
    }],
    execute: function() {
      SaveButtons = (function() {
        var _instanceInitializers = {};
        function SaveButtons() {
          _classCallCheck(this, _SaveButtons);
          _defineDecoratedPropertyDescriptor(this, 'save', _instanceInitializers);
          _defineDecoratedPropertyDescriptor(this, 'public', _instanceInitializers);
          _defineDecoratedPropertyDescriptor(this, 'saveAction', _instanceInitializers);
        }
        _createDecoratedClass(SaveButtons, [{
          key: 'saveClick',
          value: function saveClick(event, instruction) {
            var message = event.target.textContent;
            this.save(instruction).then(function() {
              return alertify.success(message + ' succeeded.');
            }, function() {
              return alertify.error(message + ' failed.');
            });
          }
        }, {
          key: 'save',
          decorators: [bindable],
          initializer: null,
          enumerable: true
        }, {
          key: 'public',
          decorators: [bindable],
          initializer: null,
          enumerable: true
        }, {
          key: 'saveAction',
          decorators: [bindable],
          initializer: null,
          enumerable: true
        }], null, _instanceInitializers);
        var _SaveButtons = SaveButtons;
        SaveButtons = containerless()(SaveButtons) || SaveButtons;
        return SaveButtons;
      })();
      _export('SaveButtons', SaveButtons);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/save-buttons.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <require from=\"./ga\"></require>\r\n\r\n  <button class=\"btn btn-secret tooltipped tooltipped-s\" aria-label=\"Secret gists are hidden from search engines but visible to anyone you give the URL.\"\r\n          click.delegate=\"saveClick($event, { fork: false, secret: true })\"\r\n          show.bind=\"saveAction !== 'Update'\"\r\n          ga ga-category=\"editor-commands\" ga-action=\"fork-secret\">\r\n    ${saveAction === 'Fork' ? 'Fork to' : 'Create'} Secret Gist\r\n  </button>\r\n  <button class=\"btn m-l-5\" click.delegate=\"saveClick($event, { fork: false, secret: false })\"\r\n          show.bind=\"saveAction !== 'Update'\"\r\n          ga ga-category=\"editor-commands\" ga-action=\"fork-public\">\r\n    ${saveAction === 'Fork' ? 'Fork to' : 'Create'} Public Gist\r\n  </button>\r\n\r\n  <button class=\"btn btn-primary\" click.delegate=\"saveClick($event, { fork: false })\"\r\n          show.bind=\"saveAction === 'Update'\"\r\n          ga ga-category=\"editor-commands\" ga-action=\"update\">\r\n    Update${public ? ' ' : ' Secret '}Gist\r\n  </button>\r\n  <button class=\"btn m-l-5\" click.delegate=\"saveClick($event, { fork: true })\"\r\n          show.bind=\"saveAction === 'Update'\"\r\n          ga ga-category=\"editor-commands\" ga-action=\"fork\">\r\n    Fork${public ? ' ' : ' Secret '}Gist\r\n  </button>\r\n</template>\r\n";
});

_removeDefine();
})();
System.registerDynamic("npm:split.js@1.0.6/split", [], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  'use strict';
  (function() {
    var global = this,
        addEventListener = 'addEventListener',
        removeEventListener = 'removeEventListener',
        getBoundingClientRect = 'getBoundingClientRect',
        isIE8 = global.attachEvent && !global[addEventListener],
        document = global.document,
        calc = (function() {
          var el,
              prefixes = ["", "-webkit-", "-moz-", "-o-"];
          for (var i = 0; i < prefixes.length; i++) {
            el = document.createElement('div');
            el.style.cssText = "width:" + prefixes[i] + "calc(9px)";
            if (el.style.length) {
              return prefixes[i] + "calc";
            }
          }
        })(),
        elementOrSelector = function(el) {
          if (typeof el === 'string' || el instanceof String) {
            return document.querySelector(el);
          } else {
            return el;
          }
        },
        Split = function(ids, options) {
          var dimension,
              i,
              clientDimension,
              clientAxis,
              position,
              gutterClass,
              paddingA,
              paddingB,
              pairs = [];
          options = typeof options !== 'undefined' ? options : {};
          if (!options.gutterSize)
            options.gutterSize = 10;
          if (!options.minSize)
            options.minSize = 100;
          if (!options.snapOffset)
            options.snapOffset = 30;
          if (!options.direction)
            options.direction = 'horizontal';
          if (options.direction == 'horizontal') {
            dimension = 'width';
            clientDimension = 'clientWidth';
            clientAxis = 'clientX';
            position = 'left';
            gutterClass = 'gutter gutter-horizontal';
            paddingA = 'paddingLeft';
            paddingB = 'paddingRight';
            if (!options.cursor)
              options.cursor = 'ew-resize';
          } else if (options.direction == 'vertical') {
            dimension = 'height';
            clientDimension = 'clientHeight';
            clientAxis = 'clientY';
            position = 'top';
            gutterClass = 'gutter gutter-vertical';
            paddingA = 'paddingTop';
            paddingB = 'paddingBottom';
            if (!options.cursor)
              options.cursor = 'ns-resize';
          }
          var startDragging = function(e) {
            var self = this,
                a = self.a,
                b = self.b;
            if (!self.dragging && options.onDragStart) {
              options.onDragStart();
            }
            e.preventDefault();
            self.dragging = true;
            self.move = drag.bind(self);
            self.stop = stopDragging.bind(self);
            global[addEventListener]('mouseup', self.stop);
            global[addEventListener]('touchend', self.stop);
            global[addEventListener]('touchcancel', self.stop);
            self.parent[addEventListener]('mousemove', self.move);
            self.parent[addEventListener]('touchmove', self.move);
            a[addEventListener]('selectstart', preventSelection);
            a[addEventListener]('dragstart', preventSelection);
            b[addEventListener]('selectstart', preventSelection);
            b[addEventListener]('dragstart', preventSelection);
            a.style.userSelect = 'none';
            a.style.webkitUserSelect = 'none';
            a.style.MozUserSelect = 'none';
            a.style.pointerEvents = 'none';
            b.style.userSelect = 'none';
            b.style.webkitUserSelect = 'none';
            b.style.MozUserSelect = 'none';
            b.style.pointerEvents = 'none';
            self.gutter.style.cursor = options.cursor;
            self.parent.style.cursor = options.cursor;
            calculateSizes.call(self);
          },
              stopDragging = function() {
                var self = this,
                    a = self.a,
                    b = self.b;
                if (self.dragging && options.onDragEnd) {
                  options.onDragEnd();
                }
                self.dragging = false;
                global[removeEventListener]('mouseup', self.stop);
                global[removeEventListener]('touchend', self.stop);
                global[removeEventListener]('touchcancel', self.stop);
                self.parent[removeEventListener]('mousemove', self.move);
                self.parent[removeEventListener]('touchmove', self.move);
                delete self.stop;
                delete self.move;
                a[removeEventListener]('selectstart', preventSelection);
                a[removeEventListener]('dragstart', preventSelection);
                b[removeEventListener]('selectstart', preventSelection);
                b[removeEventListener]('dragstart', preventSelection);
                a.style.userSelect = '';
                a.style.webkitUserSelect = '';
                a.style.MozUserSelect = '';
                a.style.pointerEvents = '';
                b.style.userSelect = '';
                b.style.webkitUserSelect = '';
                b.style.MozUserSelect = '';
                b.style.pointerEvents = '';
                self.gutter.style.cursor = '';
                self.parent.style.cursor = '';
              },
              drag = function(e) {
                var offset;
                if (!this.dragging)
                  return;
                if ('touches' in e) {
                  offset = e.touches[0][clientAxis] - this.start;
                } else {
                  offset = e[clientAxis] - this.start;
                }
                if (offset <= this.aMin + options.snapOffset) {
                  offset = this.aMin;
                } else if (offset >= this.size - this.bMin - options.snapOffset) {
                  offset = this.size - this.bMin;
                }
                adjust.call(this, offset);
                if (options.onDrag) {
                  options.onDrag();
                }
              },
              calculateSizes = function() {
                var computedStyle = global.getComputedStyle(this.parent),
                    parentSize = this.parent[clientDimension] - parseFloat(computedStyle[paddingA]) - parseFloat(computedStyle[paddingB]);
                this.size = this.a[getBoundingClientRect]()[dimension] + this.b[getBoundingClientRect]()[dimension] + this.aGutterSize + this.bGutterSize;
                this.percentage = Math.min(this.size / parentSize * 100, 100);
                this.start = this.a[getBoundingClientRect]()[position];
              },
              adjust = function(offset) {
                this.a.style[dimension] = calc + '(' + (offset / this.size * this.percentage) + '% - ' + this.aGutterSize + 'px)';
                this.b.style[dimension] = calc + '(' + (this.percentage - (offset / this.size * this.percentage)) + '% - ' + this.bGutterSize + 'px)';
              },
              fitMin = function() {
                var self = this,
                    a = self.a,
                    b = self.b;
                if (a[getBoundingClientRect]()[dimension] < self.aMin) {
                  a.style[dimension] = (self.aMin - self.aGutterSize) + 'px';
                  b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px';
                } else if (b[getBoundingClientRect]()[dimension] < self.bMin) {
                  a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px';
                  b.style[dimension] = (self.bMin - self.bGutterSize) + 'px';
                }
              },
              fitMinReverse = function() {
                var self = this,
                    a = self.a,
                    b = self.b;
                if (b[getBoundingClientRect]()[dimension] < self.bMin) {
                  a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px';
                  b.style[dimension] = (self.bMin - self.bGutterSize) + 'px';
                } else if (a[getBoundingClientRect]()[dimension] < self.aMin) {
                  a.style[dimension] = (self.aMin - self.aGutterSize) + 'px';
                  b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px';
                }
              },
              balancePairs = function(pairs) {
                for (var i = 0; i < pairs.length; i++) {
                  calculateSizes.call(pairs[i]);
                  fitMin.call(pairs[i]);
                }
                for (i = pairs.length - 1; i >= 0; i--) {
                  calculateSizes.call(pairs[i]);
                  fitMinReverse.call(pairs[i]);
                }
              },
              preventSelection = function() {
                return false;
              },
              parent = elementOrSelector(ids[0]).parentNode;
          if (!options.sizes) {
            var percent = 100 / ids.length;
            options.sizes = [];
            for (i = 0; i < ids.length; i++) {
              options.sizes.push(percent);
            }
          }
          if (!Array.isArray(options.minSize)) {
            var minSizes = [];
            for (i = 0; i < ids.length; i++) {
              minSizes.push(options.minSize);
            }
            options.minSize = minSizes;
          }
          for (i = 0; i < ids.length; i++) {
            var el = elementOrSelector(ids[i]),
                isFirst = (i == 1),
                isLast = (i == ids.length - 1),
                size,
                gutterSize = options.gutterSize,
                pair;
            if (i > 0) {
              pair = {
                a: elementOrSelector(ids[i - 1]),
                b: el,
                aMin: options.minSize[i - 1],
                bMin: options.minSize[i],
                dragging: false,
                parent: parent,
                isFirst: isFirst,
                isLast: isLast,
                direction: options.direction
              };
              pair.aGutterSize = options.gutterSize;
              pair.bGutterSize = options.gutterSize;
              if (isFirst) {
                pair.aGutterSize = options.gutterSize / 2;
              }
              if (isLast) {
                pair.bGutterSize = options.gutterSize / 2;
              }
            }
            if (!isIE8) {
              if (i > 0) {
                var gutter = document.createElement('div');
                gutter.className = gutterClass;
                gutter.style[dimension] = options.gutterSize + 'px';
                gutter[addEventListener]('mousedown', startDragging.bind(pair));
                gutter[addEventListener]('touchstart', startDragging.bind(pair));
                parent.insertBefore(gutter, el);
                pair.gutter = gutter;
              }
              if (i === 0 || i == ids.length - 1) {
                gutterSize = options.gutterSize / 2;
              }
              if (typeof options.sizes[i] === 'string' || options.sizes[i] instanceof String) {
                size = options.sizes[i];
              } else {
                size = calc + '(' + options.sizes[i] + '% - ' + gutterSize + 'px)';
              }
            } else {
              if (typeof options.sizes[i] === 'string' || options.sizes[i] instanceof String) {
                size = options.sizes[i];
              } else {
                size = options.sizes[i] + '%';
              }
            }
            el.style[dimension] = size;
            if (i > 0) {
              pairs.push(pair);
            }
          }
          balancePairs(pairs);
        };
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = Split;
      }
      exports.Split = Split;
    } else {
      global.Split = Split;
    }
  }).call(window);
  global.define = __define;
  return module.exports;
});

System.registerDynamic("npm:split.js@1.0.6", ["npm:split.js@1.0.6/split"], true, function(require, exports, module) {
  ;
  var global = this,
      __define = global.define;
  global.define = undefined;
  module.exports = require("npm:split.js@1.0.6/split");
  global.define = __define;
  return module.exports;
});

System.register("ui/split-panel", ["npm:split.js@1.0.6", "npm:aurelia-framework@1.0.0-beta.1.0.8", "npm:aurelia-pal@1.0.0-beta.1.0.2"], function(_export) {
  'use strict';
  var Split,
      inject,
      containerless,
      DOM,
      SplitPanel;
  var _createClass = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ('value' in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError('Cannot call a class as a function');
    }
  }
  return {
    setters: [function(_splitJs) {
      Split = _splitJs.Split;
    }, function(_aureliaFramework) {
      inject = _aureliaFramework.inject;
      containerless = _aureliaFramework.containerless;
    }, function(_aureliaPal) {
      DOM = _aureliaPal.DOM;
    }],
    execute: function() {
      SplitPanel = (function() {
        function SplitPanel(element) {
          _classCallCheck(this, _SplitPanel);
          this.element = element;
        }
        _createClass(SplitPanel, [{
          key: 'attached',
          value: function attached() {
            var _this = this;
            var panels = Array.prototype.slice.call(this.element.querySelectorAll('.split'));
            Split(panels, {
              sizes: [10, 50, 40],
              gutterSize: 15,
              minSize: 200,
              snapOffset: 1,
              onDrag: function onDrag() {
                var event = DOM.createCustomEvent('resize', {bubbles: true});
                _this.element.dispatchEvent(event);
              }
            });
            panels[2].style.cssText = panels[2].style.cssText.replace('2px', '6px');
          }
        }]);
        var _SplitPanel = SplitPanel;
        SplitPanel = inject(Element)(SplitPanel) || SplitPanel;
        return SplitPanel;
      })();
      _export('SplitPanel', SplitPanel);
    }
  };
});

(function() {
var _removeDefine = System.get("@@amd-helpers").createDefine();
define("ui/split-panel.html!github:systemjs/plugin-text@0.0.3", [], function() {
  return "<template>\r\n  <div class=\"split\">\r\n    <template replaceable part=\"left\">\r\n      [Left]\r\n    </template>\r\n  </div>\r\n  <div class=\"split\">\r\n    <template replaceable part=\"center\">\r\n      [Center]\r\n    </template>\r\n  </div>\r\n  <div class=\"split\">\r\n    <template replaceable part=\"right\">\r\n      [Right]\r\n    </template>\r\n  </div>\r\n</template>\r\n";
});

_removeDefine();
})();
//# sourceMappingURL=bundle.js.map